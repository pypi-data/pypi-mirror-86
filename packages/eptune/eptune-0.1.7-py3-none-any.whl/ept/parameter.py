# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_parameter.ipynb (unless otherwise specified).

__all__ = ['Parameter', 'OrderedParameter', 'IntegerParameter', 'InListNumericParameter', 'FloatParameter',
           'CategoricalParameter', 'CallableParameter', 'LogFloatParameter']

# Cell
from enum import Enum
import abc
from random import random, randint, normalvariate as randn
from functools import partial
from math import log, log10, log2
from .utils import logx


class Parameter:
    "Base class for parameter."
    def __init__(self, values, name=None, default_value=None):
        if name is None:
            self.name = str(self.__class__.__name__)
        else:
            self.name = str(name)
        self.set_values(values)
        if default_value is None:
            self.default_value = self.get_rand_value()
        else:
            self.default_value = default_value

    def __repr__(self):
        return f'{self.__class__.__name__}(values={self.values}, name="{self.name}", default_value={self.default_value})'

    @abc.abstractmethod
    def set_values(self, values):
        raise NotImplementedError('Not implemented')

    @abc.abstractmethod
    def get_rand_value(self, *args, **kwargs):
        raise NotImplementedError('Not implemented')

    def __next__(self):
        return self.get_rand_value()

# Cell
class OrderedParameter(Parameter):
    "Base class for parameter that is ordered, such as numerical parameters."
    @abc.abstractmethod
    def get_value(self, ratio=0):
        raise NotImplementedError('Not implemented')

# Cell
class IntegerParameter(OrderedParameter):
    "Integer pramameter with a range."
    def set_values(self, values):
        if len(values) != 2:
            raise ValueError(
                f"values should have and only have two elements as lower and upper bound of the value"
            )
        self.values = sorted(values)

    def get_rand_value(self):
        return randint(*self.values)

    def get_value(self, ratio=0):
        if ratio > 1: ratio = 1
        if ratio < 0: ratio = 0
        return self.values[0] + round(
            (self.values[1] - self.values[0]) * ratio)

# Cell
class InListNumericParameter(OrderedParameter):
    """Numerical pramameter with a known set of values, and the values are ordered.
    Otherwise, it becomes a categorical parameter."""
    def set_values(self, values):
        self.values = sorted(values)
        self._len = len(self.values)

    def get_rand_value(self):
        return self.values[randint(1, self._len) - 1]

    def get_value(self, ratio=0):
        if ratio > 1: ratio = 1
        if ratio < 0: ratio = 0
        return self.values[round(self._len * ratio)]

# Cell
class FloatParameter(OrderedParameter):
    "Floating number parameter with a range."
    def set_values(self, values):
        if len(values) != 2:
            raise ValueError(
                f"values should have and only have two elements as lower and upper bound of the value"
            )
        self.values = sorted(values)
        self._range = self.values[1] - self.values[0]
        self._left = self.values[0]

    def get_rand_value(self, a=None, b=None):
        if a is None or b is None:
            return random() * self._range + self._left
        else:
            return random() * abs(a - b) + a if a < b else b

    def get_value(self, ratio=0):
        if ratio > 1: ratio = 1
        if ratio < 0: ratio = 0
        return self._range * ratio + self._left

# Cell
class CategoricalParameter(Parameter):
    "Categorical parameter"
    def set_values(self, values):
        self.values = list(set(values))
        self._len = len(self.values)

    def get_rand_value(self):
        return self.values[randint(1, self._len) - 1]

# Cell
class CallableParameter(Parameter):
    """The values of the parameter is a callable. When execute the values attribute,
    the callable will return the possible value of the parameter."""
    def set_values(self, values):
        if callable(values):
            self.values = values
        else:
            raise ValueError('values need to be a callable object.')

    def get_rand_value(self, *args, **kwargs):
        return self.values(*args, **kwargs)

# Cell
class LogFloatParameter(OrderedParameter):
    """Floating number parameter with a range, but the sampling is in a logrithmic scale.
    So lower paramter range is sampled more frequentyly than higher range.

    - Note: the parameter range must be positive, as `log` of negative number is not a real number.
    """
    def __init__(self, values, name=None, default_value=None, base=10):
        if base == 10:
            self._log = log10
        elif base == 2:
            self._log = log2
        elif base == 'e':
            self._log = log
        else:
            self._log = partial(logx, x=base)
        self.base = base
        super().__init__(values, name, default_value=default_value)

    def set_values(self, values):
        if len(values) != 2:
            raise ValueError(
                f"values should have and only have two elements as lower and upper bound of the value"
            )
        self.values = sorted(values)
        self._left = self._log(self.values[0])
        self._right = self._log(self.values[1])
        self._range = self._right - self._left

    def get_rand_value(self, a=None, b=None):
        if a is None or b is None:
            return self.base**(random() * self._range + self._left)
        else:
            a = self._log(a)
            b = self._log(b)
            return self.base**(random() * abs(a - b) + a if a < b else b)

    def get_value(self, ratio=0):
        if ratio > 1: ratio = 1
        if ratio < 0: ratio = 0
        a = self._left
        b = self._right
        return self.base**(ratio * abs(a - b) + a if a < b else b)