{"version":3,"sources":["webpack://PMA/./node_modules/rbush/rbush.js"],"names":["module","exports","quickselect","arr","k","left","right","compare","quickselectStep","n","m","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swap","length","defaultCompare","tmp","a","b","RBush","maxEntries","this","_maxEntries","_minEntries","ceil","clear","findItem","item","items","equalsFn","indexOf","calcBBox","node","toBBox","distBBox","children","p","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","stack","pop","mid","push","prototype","all","_all","data","search","bbox","result","nodesToSearch","childBBox","collides","load","insert","_build","slice","_splitRoot","tmpNode","_insert","remove","parent","goingUp","path","indexes","index","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","N2","N1","right2","right3","_chooseSubtree","level","minArea","minEnlargement","targetNode","area","enlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","bbox2","overlap","_allDistMargin","sort","leftBBox","rightBBox","margin","i$1","child$1","siblings","factory"],"mappings":"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","file":"rbush.js","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.RBush = factory());\n}(this, function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) { swap(arr, left, right); }\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) { i++; }\n            while (compare(arr[j], t) > 0) { j--; }\n        }\n\n        if (compare(arr[left], t) === 0) { swap(arr, left, j); }\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nvar RBush = function RBush(maxEntries) {\n    if ( maxEntries === void 0 ) maxEntries = 9;\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n};\n\nRBush.prototype.all = function all () {\n    return this._all(this.data, []);\n};\n\nRBush.prototype.search = function search (bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) { return result; }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf) { result.push(child); }\n                else if (contains(bbox, childBBox)) { this._all(child, result); }\n                else { nodesToSearch.push(child); }\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return result;\n};\n\nRBush.prototype.collides = function collides (bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) { return false; }\n\n    var nodesToSearch = [];\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? this.toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf || contains(bbox, childBBox)) { return true; }\n                nodesToSearch.push(child);\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return false;\n};\n\nRBush.prototype.load = function load (data) {\n    if (!(data && data.length)) { return this; }\n\n    if (data.length < this._minEntries) {\n        for (var i = 0; i < data.length; i++) {\n            this.insert(data[i]);\n        }\n        return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n        // save as is if tree is empty\n        this.data = node;\n\n    } else if (this.data.height === node.height) {\n        // split root if trees have the same height\n        this._splitRoot(this.data, node);\n\n    } else {\n        if (this.data.height < node.height) {\n            // swap trees if inserted one is bigger\n            var tmpNode = this.data;\n            this.data = node;\n            node = tmpNode;\n        }\n\n        // insert the small tree into the large tree at appropriate level\n        this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n};\n\nRBush.prototype.insert = function insert (item) {\n    if (item) { this._insert(item, this.data.height - 1); }\n    return this;\n};\n\nRBush.prototype.clear = function clear () {\n    this.data = createNode([]);\n    return this;\n};\n\nRBush.prototype.remove = function remove (item, equalsFn) {\n    if (!item) { return this; }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n\n        if (!node) { // go up\n            node = path.pop();\n            parent = path[path.length - 1];\n            i = indexes.pop();\n            goingUp = true;\n        }\n\n        if (node.leaf) { // check current node\n            var index = findItem(item, node.children, equalsFn);\n\n            if (index !== -1) {\n                // item found, remove the item and condense tree upwards\n                node.children.splice(index, 1);\n                path.push(node);\n                this._condense(path);\n                return this;\n            }\n        }\n\n        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n            path.push(node);\n            indexes.push(i);\n            i = 0;\n            parent = node;\n            node = node.children[0];\n\n        } else if (parent) { // go right\n            i++;\n            node = parent.children[i];\n            goingUp = false;\n\n        } else { node = null; } // nothing found\n    }\n\n    return this;\n};\n\nRBush.prototype.toBBox = function toBBox (item) { return item; };\n\nRBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };\nRBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };\n\nRBush.prototype.toJSON = function toJSON () { return this.data; };\n\nRBush.prototype.fromJSON = function fromJSON (data) {\n    this.data = data;\n    return this;\n};\n\nRBush.prototype._all = function _all (node, result) {\n    var nodesToSearch = [];\n    while (node) {\n        if (node.leaf) { result.push.apply(result, node.children); }\n        else { nodesToSearch.push.apply(nodesToSearch, node.children); }\n\n        node = nodesToSearch.pop();\n    }\n    return result;\n};\n\nRBush.prototype._build = function _build (items, left, right, height) {\n\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n        // reached leaf level; return leaf\n        node = createNode(items.slice(left, right + 1));\n        calcBBox(node, this.toBBox);\n        return node;\n    }\n\n    if (!height) {\n        // target height of the bulk-loaded tree\n        height = Math.ceil(Math.log(N) / Math.log(M));\n\n        // target number of root entries to maximize storage utilization\n        M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n\n        var right2 = Math.min(i + N1 - 1, right);\n\n        multiSelect(items, i, right2, N2, this.compareMinY);\n\n        for (var j = i; j <= right2; j += N2) {\n\n            var right3 = Math.min(j + N2 - 1, right2);\n\n            // pack each entry recursively\n            node.children.push(this._build(items, j, right3, height - 1));\n        }\n    }\n\n    calcBBox(node, this.toBBox);\n\n    return node;\n};\n\nRBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {\n    while (true) {\n        path.push(node);\n\n        if (node.leaf || path.length - 1 === level) { break; }\n\n        var minArea = Infinity;\n        var minEnlargement = Infinity;\n        var targetNode = (void 0);\n\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var area = bboxArea(child);\n            var enlargement = enlargedArea(bbox, child) - area;\n\n            // choose entry with the least area enlargement\n            if (enlargement < minEnlargement) {\n                minEnlargement = enlargement;\n                minArea = area < minArea ? area : minArea;\n                targetNode = child;\n\n            } else if (enlargement === minEnlargement) {\n                // otherwise choose one with the smallest area\n                if (area < minArea) {\n                    minArea = area;\n                    targetNode = child;\n                }\n            }\n        }\n\n        node = targetNode || node.children[0];\n    }\n\n    return node;\n};\n\nRBush.prototype._insert = function _insert (item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n        if (insertPath[level].children.length > this._maxEntries) {\n            this._split(insertPath, level);\n            level--;\n        } else { break; }\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n};\n\n// split overflowed node into two\nRBush.prototype._split = function _split (insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) { insertPath[level - 1].children.push(newNode); }\n    else { this._splitRoot(node, newNode); }\n};\n\nRBush.prototype._splitRoot = function _splitRoot (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n};\n\nRBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n        var bbox1 = distBBox(node, 0, i, this.toBBox);\n        var bbox2 = distBBox(node, i, M, this.toBBox);\n\n        var overlap = intersectionArea(bbox1, bbox2);\n        var area = bboxArea(bbox1) + bboxArea(bbox2);\n\n        // choose distribution with minimum overlap\n        if (overlap < minOverlap) {\n            minOverlap = overlap;\n            index = i;\n\n            minArea = area < minArea ? area : minArea;\n\n        } else if (overlap === minOverlap) {\n            // otherwise choose distribution with minimum area\n            if (area < minArea) {\n                minArea = area;\n                index = i;\n            }\n        }\n    }\n\n    return index || M - m;\n};\n\n// sorts node children by the best axis for split\nRBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n    var yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) { node.children.sort(compareMinX); }\n};\n\n// total margin of all possible split distributions where each node is at least m full\nRBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {\n    node.children.sort(compare);\n\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n        var child = node.children[i];\n        extend(leftBBox, node.leaf ? toBBox(child) : child);\n        margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n        var child$1 = node.children[i$1];\n        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n        margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n};\n\nRBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n        extend(path[i], bbox);\n    }\n};\n\nRBush.prototype._condense = function _condense (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {\n        if (path[i].children.length === 0) {\n            if (i > 0) {\n                siblings = path[i - 1].children;\n                siblings.splice(siblings.indexOf(path[i]), 1);\n\n            } else { this.clear(); }\n\n        } else { calcBBox(path[i], this.toBBox); }\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) { return items.indexOf(item); }\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) { return i; }\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) { destNode = createNode(null); }\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n        var child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) { continue; }\n\n        var mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nreturn RBush;\n\n}));\n"],"sourceRoot":""}