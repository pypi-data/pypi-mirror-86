# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['GH_HOST', 'GhApi']

# Cell
from fastcore.utils import *
from fastcore.foundation import *
from fastcore.meta import *

import pprint,inspect,json,copy,urllib,mimetypes
from inspect import signature,Parameter,Signature
from urllib.parse import urlencode
from .metadata import funcs
from urllib.request import Request,urlretrieve
from urllib.error import HTTPError

# Cell
GH_HOST = "https://api.github.com"
_DOC_URL = 'https://docs.github.com/'

# Cell
def _mk_param(nm, **kwargs): return Parameter(nm, kind=Parameter.POSITIONAL_OR_KEYWORD, **kwargs)

def _mk_sig(req_args, def_args):
    "Create a signature object with required and default arguments"
    params =  [_mk_param(k) for k in req_args]
    params += [_mk_param(k, default=v) for k,v in def_args.items()]
    return Signature(params)

def _preview_hdr(preview):
    return {'Accept': f'application/vnd.github.{preview}-preview+json'} if preview else {}

# Cell
class _GhVerb:
    __slots__ = 'path,verb,tag,name,summary,url,route_ps,params,data,preview,hdrs,__doc__'.split(',')
    def __init__(self, path, verb, oper, summary, url, params, data, preview, hdrs, kwargs):
        tag,name = oper.split('/')
        name = name.replace('-','_')
        path,route_ps,_ = partial_format(path, **kwargs)
        __doc__ = summary
        data = L(data).itemgot(0)
        store_attr()

    def __call__(self, *args, headers=None, debug=None, **kwargs):
        headers = {**self.hdrs,**_preview_hdr(self.preview),**(headers or {})}
        flds = [o for o in self.route_ps+self.params+self.data if o not in kwargs]
        for a,b in zip(args,flds): kwargs[b]=a
        route_p,query_p,data_p = [{p:kwargs[p] for p in o if p in kwargs}
                                 for o in (self.route_ps,self.params,self.data)]
        if not data_p: data_p=None
        return dict2obj(urlsend(GH_HOST+self.path, self.verb, headers=headers, debug=debug,
                              route=route_p, query=query_p, data=data_p))

    @property
    def __signature__(self): return _mk_sig(self.route_ps, dict.fromkeys(self.params+self.data))
    __call__.__signature__ = __signature__

    def _repr_markdown_(self):
        params = ', '.join(self.route_ps+self.params+self.data)
        return f'[{self.tag}.{self.name}]({_DOC_URL}{self.url.replace(" ","_")})({params}): *{self.summary}*'
    __repr__ = _repr_markdown_

class _GhVerbGroup:
    def __init__(self, verbs):
        self.verbs = verbs
        for o in verbs: setattr(self, o.name, o)
    def _repr_markdown_(self): return "\n".join(f'- {v._repr_markdown_()}' for v in self.verbs)

# Cell
_docroot = 'https://docs.github.com/en/free-pro-team@latest/rest/reference/'

# Cell
class GhApi:
    def __init__(self, owner=None, repo=None, token=None, **kwargs):
        self.headers = { 'Accept': 'application/vnd.github.v3+json' }
        if token: self.headers['Authorization'] = 'token ' + token
        if owner: kwargs['owner'] = owner
        if repo:  kwargs['repo' ] = repo
        funcs_ = L(funcs).starmap(_GhVerb, hdrs=self.headers, kwargs=kwargs)
        self.groups = {k.replace('-','_'):_GhVerbGroup(v) for k,v in groupby(funcs_, 'tag').items()}

    def __dir__(self): return super().__dir__() + list(self.groups)
    def _repr_markdown_(self): return "\n".join(f'- [{o}]({_docroot+o})' for o in sorted(self.groups))
    def __getattr__(self,k): return self.groups[k] if 'groups' in vars(self) and k in self.groups else stop(AttributeError(k))

    def full_docs(self):
        return '\n'.join(f'## {gn}\n\n{group._repr_markdown_()}\n' for gn,group in sorted(self.groups.items()))

# Cell
@patch
def delete_release(self:GhApi, release):
    "Delete a release and its associated tag"
    self.repos.delete_release(release.id)
    self.git.delete_ref(f'tags/{release.tag_name}')

# Cell
@patch
def _upload_file(self:GhApi, url:str, fn):
    "Upload `fn` to endpoint `url`"
    fn = Path(fn)
    mime = mimetypes.guess_type(fn, False)[0] or 'application/octet-stream'
    headers = {**self.headers, 'Content-Type':mime}
    data = fn.read_bytes()
    return urlsend(url, 'POST', headers=headers, query = {'name':fn.name}, data=data)

# Cell
@patch
def create_release(self:GhApi, tag_name, branch='master', name=None, body='',
                   draft=False, prerelease=False, files=None):
    "Wrapper for `GhApi.repos.create_release` which also uploads `files`"
    if name is None: name = 'v'+tag_name
    rel = self.repos.create_release(tag_name, target_commitish=branch, name=name, body=body,
                                   draft=draft, prerelease=prerelease)
    url = rel.upload_url.replace('{?name,label}','')
    for file in listify(files): self._upload_file(url, file)
    return rel

# Cell
@patch
def list_tags(self:GhApi, prefix:str=''):
    "List all tags, optionally filtered to those starting with `prefix`"
    return self.git.list_matching_refs(f'tags/{prefix}')

# Cell
@patch
def list_branches(self:GhApi, prefix:str=''):
    "List all branches, optionally filtered to those starting with `prefix`"
    return self.git.list_matching_refs(f'heads/{prefix}')

# Cell
@patch
def enable_pages(self:GhApi, branch, path):
    """Enable or update pages for a repo to point to a `branch` and `path`."""
    assert path in ['/docs', '/'], "path can only be '/docs' or '/'."
    if not self.repos.get().has_pages:
        # if branch doesn't exist yet, temporarily enable pages on the default branch
        newb = None
        try: self.repos.get_branch(branch)
        except HTTPError as e:
            if e.code == 404: newb = self.repos.get().default_branch
        self.repos.create_pages_site(source={"branch": f"{ifnone(newb, branch)}", "path": f"{path}"})

    # you can update to a branch that doesn't yet exist ONLY if you have already enabled pages
    self.repos.update_information_about_pages_site(source={"branch": f"{branch}", "path": f"{path}"})