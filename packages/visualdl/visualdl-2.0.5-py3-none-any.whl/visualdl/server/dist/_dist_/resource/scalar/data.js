import h from"../../../web_modules/bignumberjs.js";import b from"../../../web_modules/lodash/compact.js";import x from"../../../web_modules/lodash/maxBy.js";import f from"../../../web_modules/lodash/minBy.js";import{quantile as g}from"../../utils/index.js";export const transform=({datasets:e,smoothing:r})=>e.map(i=>{const o=i.map(n=>[...n,Number.NaN,Number.NaN]);let a=new h(o.length>0?0:Number.NaN),m=0,c=0;const l=new h(r);return o.forEach((n,s)=>{const t=new h(n[2]),u=n[0]=Math.floor(n[0]);if(s===0&&(c=u),n[4]=Math.floor(u-c),!t.isFinite())n[3]=t.toNumber();else{a=a.multipliedBy(l).plus(l.minus(1).negated().multipliedBy(t)),m++;let d=new h(1);l.isEqualTo(1)||(d=l.exponentiatedBy(m).minus(1).negated()),n[3]=a.dividedBy(d).toNumber()}}),o}),singlePointRange=e=>({min:e?Math.min(e*2,0):-.5,max:e?Math.max(e*2,0):.5}),range=({datasets:e})=>e==null?void 0:e.map(r=>{var i,o;if(r.length==0)return{min:Number.NaN,max:Number.NaN};const a=r.map(m=>m[2]);return{min:(i=Math.min(...a))!==null&&i!==void 0?i:Number.NaN,max:(o=Math.max(...a))!==null&&o!==void 0?o:Number.NaN}}),axisRange=({datasets:e,outlier:r})=>{var i,o,a,m;const c=b(e==null?void 0:e.map(s=>{if(s.length===0)return;const t=s.map(p=>p[2]);if(r){const p=s.map(N=>N[2]).sort();return{min:g(p,.05),max:g(t,.95)}}else{var u,d;return{min:(u=Math.min(...t))!==null&&u!==void 0?u:0,max:(d=Math.max(...t))!==null&&d!==void 0?d:0}}})),l=(i=(o=f(c,s=>s.min))===null||o===void 0?void 0:o.min)!==null&&i!==void 0?i:0,n=(a=(m=x(c,s=>s.max))===null||m===void 0?void 0:m.max)!==null&&a!==void 0?a:0;if(!(l===0&&n===0))return{min:l>0?l*.9:l*1.1,max:n>0?n*1.1:n*.9}},nearestPoint=(e,r,i,o)=>{const a=[];return e.forEach((m,c)=>{const l=r[c];let n=Number.POSITIVE_INFINITY,s=o;for(let t=0;t<m.length;t++){const u=Math.abs(m[t][i]-o);n>u&&(n=u,s=m[t][i])}a.push(...m.filter(t=>t[i]===s).map(t=>({run:l,item:t})))}),a},parseSmoothing=e=>{const r=Number.parseFloat(String(e));let i=.6;return Number.isFinite(r)&&r<1&&r>=0&&(i=Math.round(r*100)/100),i};
