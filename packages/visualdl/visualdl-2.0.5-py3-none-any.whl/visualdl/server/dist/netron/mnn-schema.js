var $root=flatbuffers.get("mnn");$root.MNN=$root.MNN||{},$root.MNN.OpType={AbsVal:0,QuantizedAdd:1,ArgMax:2,AsString:3,InstanceNorm:4,BatchToSpaceND:5,Bias:6,BinaryOp:7,Bnll:8,Cast:9,Concat:10,Const:11,Convolution:12,ConvolutionDepthwise:13,Crop:14,CropAndResize:15,Cubic:16,Deconvolution:17,DeconvolutionDepthwise:18,Dequantize:19,DetectionOutput:20,Dropout:21,Eltwise:22,ELU:23,Embed:24,Exp:25,ExpandDims:26,Fill:27,Flatten:28,FloorMod:29,Gather:30,GatherV2:31,Im2Seq:32,InnerProduct:33,Input:34,Interp:35,Log:36,LRN:37,LSTM:38,MatMul:39,MVN:40,NonMaxSuppression:41,NonMaxSuppressionV2:42,Normalize:43,Pack:44,Padding:45,Permute:46,Pooling:47,Power:48,PReLU:49,PriorBox:50,Proposal:51,QuantizedAvgPool:52,QuantizedBiasAdd:53,QuantizedConcat:54,QuantizedDepthwiseConv2D:55,QuantizedLogistic:56,QuantizedMatMul:57,QuantizedMaxPool:58,QuantizedRelu:59,QuantizedRelu6:60,QuantizedReshape:61,QuantizedSoftmax:62,QuantizeMaxMin:63,QuantizeV2:64,Range:65,Rank:66,ReduceJoin:67,Reduction:68,ReLU:69,ReLU6:70,RequantizationRange:71,Requantize:72,Reshape:73,Resize:74,RNN:75,ROIPooling:76,Scale:77,Selu:78,Seq2Out:79,Shape:80,Sigmoid:81,Size:82,Slice:83,SliceTf:84,Softmax:85,SpaceToBatchND:86,SpatialProduct:87,Split:88,SPP:89,Squeeze:90,StridedSlice:91,StringJoin:92,StringSplit:93,StringToNumber:94,TanH:95,TfQuantizedConv2D:96,Threshold:97,Tile:98,TopKV2:99,Transpose:100,UnaryOp:101,Unpack:102,Where:103,Moments:104,RNNSequenceGRU:105,BatchMatMul:106,Unsqueeze:107,CosineSimilarity:108,DepthToSpace:109,SpaceToDepth:110,ReverseSequence:111,Pooling3D:112,Convolution3D:113,MatrixBandPart:114,GatherND:115,DetectionPostProcess:116,UnravelIndex:117,ScatterNd:118,OneHot:119,BroadcastTo:120,Dilation2D:121,MaxLayerCount:128,ConvertTensor:129,ArgMin:130,LinSpace:131,Plugin:256,Select:257,ZerosLike:258,Broastcast:259,SetDiff1D:260,ReluGrad:261,Relu6Grad:262,PoolGrad:263,SoftmaxGrad:264,Conv2DBackPropFilter:265,TrainableParam:266,BatchNorm:267,ZeroGrad:268,Extra:512,ConvInt8:513,Int8ToFloat:514,DepthwiseConvInt8:515,PoolInt8:516,FloatToInt8:517,EltwiseInt8:518},$root.MNN.Plugin=class{static decode(e,t){const a=new $root.MNN.Plugin;return a.type=e.string_(t,4,null),a.attr=e.tableArray(t,6,$root.MNN.Attribute.decode),a}},$root.MNN.Extra=class{static decode(e,t){const a=new $root.MNN.Extra;return a.type=e.string_(t,4,null),a.engine=e.string_(t,6,null),a.info=e.typedArray(t,8,Int8Array),a.attr=e.tableArray(t,10,$root.MNN.Attribute.decode),a}},$root.MNN.OpParameter=class{static decode(n,e,t){switch(t){case 1:return $root.MNN.QuantizedAdd.decode(n,e);case 2:return $root.MNN.ArgMax.decode(n,e);case 3:return $root.MNN.AsString.decode(n,e);case 4:return $root.MNN.Axis.decode(n,e);case 5:return $root.MNN.BatchNorm.decode(n,e);case 6:return $root.MNN.BinaryOp.decode(n,e);case 7:return $root.MNN.Blob.decode(n,e);case 8:return $root.MNN.CastParam.decode(n,e);case 9:return $root.MNN.Convolution2D.decode(n,e);case 10:return $root.MNN.Crop.decode(n,e);case 11:return $root.MNN.CropAndResize.decode(n,e);case 12:return $root.MNN.Dequantize.decode(n,e);case 13:return $root.MNN.DetectionOutput.decode(n,e);case 14:return $root.MNN.Eltwise.decode(n,e);case 15:return $root.MNN.ExpandDims.decode(n,e);case 16:return $root.MNN.Fill.decode(n,e);case 17:return $root.MNN.Flatten.decode(n,e);case 18:return $root.MNN.Gather.decode(n,e);case 19:return $root.MNN.GatherV2.decode(n,e);case 20:return $root.MNN.InnerProduct.decode(n,e);case 21:return $root.MNN.Input.decode(n,e);case 22:return $root.MNN.Interp.decode(n,e);case 23:return $root.MNN.LRN.decode(n,e);case 24:return $root.MNN.LSTM.decode(n,e);case 25:return $root.MNN.MatMul.decode(n,e);case 26:return $root.MNN.NonMaxSuppressionV2.decode(n,e);case 27:return $root.MNN.Normalize.decode(n,e);case 28:return $root.MNN.PackParam.decode(n,e);case 29:return $root.MNN.Permute.decode(n,e);case 30:return $root.MNN.Plugin.decode(n,e);case 31:return $root.MNN.Pool.decode(n,e);case 32:return $root.MNN.PRelu.decode(n,e);case 33:return $root.MNN.PriorBox.decode(n,e);case 34:return $root.MNN.Proposal.decode(n,e);case 35:return $root.MNN.QuantizedAvgPool.decode(n,e);case 36:return $root.MNN.QuantizedBiasAdd.decode(n,e);case 37:return $root.MNN.QuantizedConcat.decode(n,e);case 38:return $root.MNN.QuantizedLogistic.decode(n,e);case 39:return $root.MNN.QuantizedMatMul.decode(n,e);case 40:return $root.MNN.QuantizedMaxPool.decode(n,e);case 41:return $root.MNN.QuantizedRelu.decode(n,e);case 42:return $root.MNN.QuantizedRelu6.decode(n,e);case 43:return $root.MNN.QuantizedReshape.decode(n,e);case 44:return $root.MNN.QuantizedSoftmax.decode(n,e);case 45:return $root.MNN.QuantizeMaxMin.decode(n,e);case 46:return $root.MNN.QuantizeV2.decode(n,e);case 47:return $root.MNN.Range.decode(n,e);case 48:return $root.MNN.Rank.decode(n,e);case 49:return $root.MNN.ReduceJoin.decode(n,e);case 50:return $root.MNN.ReductionParam.decode(n,e);case 51:return $root.MNN.Relu.decode(n,e);case 52:return $root.MNN.Relu6.decode(n,e);case 53:return $root.MNN.RequantizationRange.decode(n,e);case 54:return $root.MNN.Requantize.decode(n,e);case 55:return $root.MNN.Reshape.decode(n,e);case 56:return $root.MNN.Resize.decode(n,e);case 57:return $root.MNN.RoiPooling.decode(n,e);case 58:return $root.MNN.Scale.decode(n,e);case 59:return $root.MNN.Selu.decode(n,e);case 60:return $root.MNN.Size.decode(n,e);case 61:return $root.MNN.Slice.decode(n,e);case 62:return $root.MNN.SliceTf.decode(n,e);case 63:return $root.MNN.SpaceBatch.decode(n,e);case 64:return $root.MNN.SqueezeParam.decode(n,e);case 65:return $root.MNN.StridedSliceParam.decode(n,e);case 66:return $root.MNN.TensorConvertInfo.decode(n,e);case 67:return $root.MNN.TfQuantizedConv2D.decode(n,e);case 68:return $root.MNN.TopKV2.decode(n,e);case 69:return $root.MNN.Transpose.decode(n,e);case 70:return $root.MNN.UnaryOp.decode(n,e);case 71:return $root.MNN.MomentsParam.decode(n,e);case 72:return $root.MNN.RNNParam.decode(n,e);case 73:return $root.MNN.BatchMatMulParam.decode(n,e);case 74:return $root.MNN.QuantizedFloatParam.decode(n,e);case 75:return $root.MNN.DepthSpaceParam.decode(n,e);case 76:return $root.MNN.EltwiseInt8.decode(n,e);case 77:return $root.MNN.ReverseSequenceParam.decode(n,e);case 78:return $root.MNN.Extra.decode(n,e);case 79:return $root.MNN.Pool3D.decode(n,e);case 80:return $root.MNN.Convolution3D.decode(n,e);case 81:return $root.MNN.ELU.decode(n,e);case 82:return $root.MNN.DetectionPostProcessParam.decode(n,e);case 83:return $root.MNN.OneHotParam.decode(n,e);case 84:return $root.MNN.PadParam.decode(n,e)}}static decodeText(n,e,t){switch(t){case"QuantizedAdd":return $root.MNN.QuantizedAdd.decodeText(n,e);case"ArgMax":return $root.MNN.ArgMax.decodeText(n,e);case"AsString":return $root.MNN.AsString.decodeText(n,e);case"Axis":return $root.MNN.Axis.decodeText(n,e);case"BatchNorm":return $root.MNN.BatchNorm.decodeText(n,e);case"BinaryOp":return $root.MNN.BinaryOp.decodeText(n,e);case"Blob":return $root.MNN.Blob.decodeText(n,e);case"CastParam":return $root.MNN.CastParam.decodeText(n,e);case"Convolution2D":return $root.MNN.Convolution2D.decodeText(n,e);case"Crop":return $root.MNN.Crop.decodeText(n,e);case"CropAndResize":return $root.MNN.CropAndResize.decodeText(n,e);case"Dequantize":return $root.MNN.Dequantize.decodeText(n,e);case"DetectionOutput":return $root.MNN.DetectionOutput.decodeText(n,e);case"Eltwise":return $root.MNN.Eltwise.decodeText(n,e);case"ExpandDims":return $root.MNN.ExpandDims.decodeText(n,e);case"Fill":return $root.MNN.Fill.decodeText(n,e);case"Flatten":return $root.MNN.Flatten.decodeText(n,e);case"Gather":return $root.MNN.Gather.decodeText(n,e);case"GatherV2":return $root.MNN.GatherV2.decodeText(n,e);case"InnerProduct":return $root.MNN.InnerProduct.decodeText(n,e);case"Input":return $root.MNN.Input.decodeText(n,e);case"Interp":return $root.MNN.Interp.decodeText(n,e);case"LRN":return $root.MNN.LRN.decodeText(n,e);case"LSTM":return $root.MNN.LSTM.decodeText(n,e);case"MatMul":return $root.MNN.MatMul.decodeText(n,e);case"NonMaxSuppressionV2":return $root.MNN.NonMaxSuppressionV2.decodeText(n,e);case"Normalize":return $root.MNN.Normalize.decodeText(n,e);case"PackParam":return $root.MNN.PackParam.decodeText(n,e);case"Permute":return $root.MNN.Permute.decodeText(n,e);case"Plugin":return $root.MNN.Plugin.decodeText(n,e);case"Pool":return $root.MNN.Pool.decodeText(n,e);case"PRelu":return $root.MNN.PRelu.decodeText(n,e);case"PriorBox":return $root.MNN.PriorBox.decodeText(n,e);case"Proposal":return $root.MNN.Proposal.decodeText(n,e);case"QuantizedAvgPool":return $root.MNN.QuantizedAvgPool.decodeText(n,e);case"QuantizedBiasAdd":return $root.MNN.QuantizedBiasAdd.decodeText(n,e);case"QuantizedConcat":return $root.MNN.QuantizedConcat.decodeText(n,e);case"QuantizedLogistic":return $root.MNN.QuantizedLogistic.decodeText(n,e);case"QuantizedMatMul":return $root.MNN.QuantizedMatMul.decodeText(n,e);case"QuantizedMaxPool":return $root.MNN.QuantizedMaxPool.decodeText(n,e);case"QuantizedRelu":return $root.MNN.QuantizedRelu.decodeText(n,e);case"QuantizedRelu6":return $root.MNN.QuantizedRelu6.decodeText(n,e);case"QuantizedReshape":return $root.MNN.QuantizedReshape.decodeText(n,e);case"QuantizedSoftmax":return $root.MNN.QuantizedSoftmax.decodeText(n,e);case"QuantizeMaxMin":return $root.MNN.QuantizeMaxMin.decodeText(n,e);case"QuantizeV2":return $root.MNN.QuantizeV2.decodeText(n,e);case"Range":return $root.MNN.Range.decodeText(n,e);case"Rank":return $root.MNN.Rank.decodeText(n,e);case"ReduceJoin":return $root.MNN.ReduceJoin.decodeText(n,e);case"ReductionParam":return $root.MNN.ReductionParam.decodeText(n,e);case"Relu":return $root.MNN.Relu.decodeText(n,e);case"Relu6":return $root.MNN.Relu6.decodeText(n,e);case"RequantizationRange":return $root.MNN.RequantizationRange.decodeText(n,e);case"Requantize":return $root.MNN.Requantize.decodeText(n,e);case"Reshape":return $root.MNN.Reshape.decodeText(n,e);case"Resize":return $root.MNN.Resize.decodeText(n,e);case"RoiPooling":return $root.MNN.RoiPooling.decodeText(n,e);case"Scale":return $root.MNN.Scale.decodeText(n,e);case"Selu":return $root.MNN.Selu.decodeText(n,e);case"Size":return $root.MNN.Size.decodeText(n,e);case"Slice":return $root.MNN.Slice.decodeText(n,e);case"SliceTf":return $root.MNN.SliceTf.decodeText(n,e);case"SpaceBatch":return $root.MNN.SpaceBatch.decodeText(n,e);case"SqueezeParam":return $root.MNN.SqueezeParam.decodeText(n,e);case"StridedSliceParam":return $root.MNN.StridedSliceParam.decodeText(n,e);case"TensorConvertInfo":return $root.MNN.TensorConvertInfo.decodeText(n,e);case"TfQuantizedConv2D":return $root.MNN.TfQuantizedConv2D.decodeText(n,e);case"TopKV2":return $root.MNN.TopKV2.decodeText(n,e);case"Transpose":return $root.MNN.Transpose.decodeText(n,e);case"UnaryOp":return $root.MNN.UnaryOp.decodeText(n,e);case"MomentsParam":return $root.MNN.MomentsParam.decodeText(n,e);case"RNNParam":return $root.MNN.RNNParam.decodeText(n,e);case"BatchMatMulParam":return $root.MNN.BatchMatMulParam.decodeText(n,e);case"QuantizedFloatParam":return $root.MNN.QuantizedFloatParam.decodeText(n,e);case"DepthSpaceParam":return $root.MNN.DepthSpaceParam.decodeText(n,e);case"EltwiseInt8":return $root.MNN.EltwiseInt8.decodeText(n,e);case"ReverseSequenceParam":return $root.MNN.ReverseSequenceParam.decodeText(n,e);case"Extra":return $root.MNN.Extra.decodeText(n,e);case"Pool3D":return $root.MNN.Pool3D.decodeText(n,e);case"Convolution3D":return $root.MNN.Convolution3D.decodeText(n,e);case"ELU":return $root.MNN.ELU.decodeText(n,e);case"DetectionPostProcessParam":return $root.MNN.DetectionPostProcessParam.decodeText(n,e);case"OneHotParam":return $root.MNN.OneHotParam.decodeText(n,e);case"PadParam":return $root.MNN.PadParam.decodeText(n,e)}}},$root.MNN.Op=class{static decode(e,t){const a=new $root.MNN.Op;return a.inputIndexes=e.typedArray(t,4,Int32Array),a.main=e.union(t,6,$root.MNN.OpParameter.decode),a.name=e.string_(t,10,null),a.outputIndexes=e.typedArray(t,12,Int32Array),a.type=e.int32_(t,14,0),a.defaultDimentionFormat=e.int8_(t,16,void 0),a}},$root.MNN.TensorDescribe=class{static decode(e,t){const a=new $root.MNN.TensorDescribe;return a.blob=e.table(t,4,$root.MNN.Blob.decode),a.index=e.int32_(t,6,0),a.name=e.string_(t,8,null),a}},$root.MNN.ForwardType={CPU:0,METAL:1,OPENCL:2,OPENGLES:3,VULKAN:4},$root.MNN.Usage={INFERENCE:0,TRAIN:1},$root.MNN.Net=class{static create(e){return $root.MNN.Net.decode(e,e.root)}static decode(e,t){const a=new $root.MNN.Net;return a.bizCode=e.string_(t,4,null),a.extraTensorDescribe=e.tableArray(t,6,$root.MNN.TensorDescribe.decode),a.gpulibrary=e.table(t,8,$root.MNN.GpuLibrary.decode),a.oplists=e.tableArray(t,10,$root.MNN.Op.decode),a.outputName=e.strings_(t,12),a.preferForwardType=e.int8_(t,14,0),a.sourceType=e.int8_(t,16,0),a.tensorName=e.strings_(t,18),a.tensorNumber=e.int32_(t,20,0),a.usage=e.int8_(t,22,0),a}},$root.MNN.PadMode={CAFFE:0,VALID:1,SAME:2},$root.MNN.Convolution2DCommon=class{static decode(e,t){const a=new $root.MNN.Convolution2DCommon;return a.padX=e.int32_(t,4,0),a.padY=e.int32_(t,6,0),a.kernelX=e.int32_(t,8,1),a.kernelY=e.int32_(t,10,1),a.strideX=e.int32_(t,12,1),a.strideY=e.int32_(t,14,1),a.dilateX=e.int32_(t,16,1),a.dilateY=e.int32_(t,18,1),a.padMode=e.int8_(t,20,0),a.group=e.int32_(t,22,1),a.outputCount=e.int32_(t,24,0),a.inputCount=e.int32_(t,26,0),a.relu=e.bool_(t,28,!1),a.relu6=e.bool_(t,30,!1),a.pads=e.typedArray(t,32,Int32Array),a}},$root.MNN.Convolution3DCommon=class{static decode(e,t){const a=new $root.MNN.Convolution3DCommon;return a.dilates=e.typedArray(t,4,Int32Array),a.strides=e.typedArray(t,6,Int32Array),a.kernels=e.typedArray(t,8,Int32Array),a.pads=e.typedArray(t,10,Int32Array),a.padMode=e.int8_(t,12,0),a.inputCount=e.int32_(t,14,0),a.outputCount=e.int32_(t,16,0),a.relu=e.bool_(t,18,!1),a.relu6=e.bool_(t,20,!1),a}},$root.MNN.IDSTQuan=class{static decode(e,t){const a=new $root.MNN.IDSTQuan;return a.buffer=e.typedArray(t,4,Int8Array),a.alpha=e.typedArray(t,6,Float32Array),a.type=e.int32_(t,8,0),a.useInt32=e.bool_(t,10,!1),a.quantScale=e.float32_(t,12,0),a.scaleIn=e.float32_(t,14,0),a.scaleOut=e.float32_(t,16,0),a.aMax=e.int32_(t,18,0),a.aMin=e.int32_(t,20,0),a.readType=e.int32_(t,22,0),a.has_scaleInt=e.bool_(t,24,!1),a}},$root.MNN.QuantizeAlgo={DEFAULT:0,OVERFLOW_AWARE:1},$root.MNN.QuantizedFloatParam=class{static decode(e,t){const a=new $root.MNN.QuantizedFloatParam;return a.weight=e.typedArray(t,4,Int8Array),a.bias=e.typedArray(t,6,Int32Array),a.scale=e.typedArray(t,8,Float32Array),a.tensorScale=e.typedArray(t,10,Float32Array),a.method=e.int8_(t,12,0),a}},$root.MNN.Convolution2D=class{static decode(e,t){const a=new $root.MNN.Convolution2D;return a.common=e.table(t,4,$root.MNN.Convolution2DCommon.decode),a.weight=e.typedArray(t,6,Float32Array),a.bias=e.typedArray(t,8,Float32Array),a.quanParameter=e.table(t,10,$root.MNN.IDSTQuan.decode),a.symmetricQuan=e.table(t,12,$root.MNN.QuantizedFloatParam.decode),a}},$root.MNN.Convolution3D=class{static decode(e,t){const a=new $root.MNN.Convolution3D;return a.common=e.table(t,4,$root.MNN.Convolution3DCommon.decode),a.weight=e.typedArray(t,6,Float32Array),a.bias=e.typedArray(t,8,Float32Array),a}},$root.MNN.InnerProduct=class{static decode(e,t){const a=new $root.MNN.InnerProduct;return a.outputCount=e.int32_(t,4,0),a.biasTerm=e.int32_(t,6,0),a.weightSize=e.int32_(t,8,0),a.weight=e.typedArray(t,10,Float32Array),a.bias=e.typedArray(t,12,Float32Array),a.axis=e.int32_(t,14,0),a.transpose=e.bool_(t,16,!1),a.quanParameter=e.table(t,18,$root.MNN.IDSTQuan.decode),a}},$root.MNN.PoolType={MAXPOOL:0,AVEPOOL:1},$root.MNN.PoolPadType={CAFFE:0,VALID:1,SAME:2},$root.MNN.Pool=class{static decode(e,t){const a=new $root.MNN.Pool;return a.padX=e.int32_(t,4,0),a.padY=e.int32_(t,6,0),a.isGlobal=e.bool_(t,8,!1),a.kernelX=e.int32_(t,10,0),a.kernelY=e.int32_(t,12,0),a.strideX=e.int32_(t,14,0),a.strideY=e.int32_(t,16,0),a.type=e.int8_(t,18,0),a.padType=e.int8_(t,20,0),a.dataType=e.int32_(t,22,1),a.ceilModel=e.bool_(t,24,!0),a.pads=e.typedArray(t,26,Int32Array),a}},$root.MNN.Pool3D=class{static decode(e,t){const a=new $root.MNN.Pool3D;return a.strides=e.typedArray(t,4,Int32Array),a.kernels=e.typedArray(t,6,Int32Array),a.pads=e.typedArray(t,8,Int32Array),a.type=e.int8_(t,10,0),a.padType=e.int8_(t,12,0),a}},$root.MNN.Relu=class{static decode(e,t){const a=new $root.MNN.Relu;return a.slope=e.float32_(t,4,0),a}},$root.MNN.Relu6=class{static decode(e,t){const a=new $root.MNN.Relu6;return a.minValue=e.float32_(t,4,0),a.maxValue=e.float32_(t,6,6),a}},$root.MNN.PRelu=class{static decode(e,t){const a=new $root.MNN.PRelu;return a.slopeCount=e.int32_(t,4,0),a.slope=e.typedArray(t,6,Float32Array),a}},$root.MNN.ELU=class{static decode(e,t){const a=new $root.MNN.ELU;return a.alpha=e.float32_(t,4,0),a}},$root.MNN.LRN=class{static decode(e,t){const a=new $root.MNN.LRN;return a.regionType=e.int32_(t,4,0),a.localSize=e.int32_(t,6,0),a.alpha=e.float32_(t,8,0),a.beta=e.float32_(t,10,0),a}},$root.MNN.ArgMax=class{static decode(e,t){const a=new $root.MNN.ArgMax;return a.outMaxVal=e.int32_(t,4,0),a.topK=e.int32_(t,6,0),a.axis=e.int32_(t,8,0),a.softmaxThreshold=e.int32_(t,10,0),a}},$root.MNN.Axis=class{static decode(e,t){const a=new $root.MNN.Axis;return a.axis=e.int32_(t,4,0),a}},$root.MNN.Input=class{static decode(e,t){const a=new $root.MNN.Input;return a.dims=e.typedArray(t,4,Int32Array),a.dtype=e.int32_(t,6,1),a.dformat=e.int8_(t,8,void 0),a}},$root.MNN.LSTM=class{static decode(e,t){const a=new $root.MNN.LSTM;return a.outputCount=e.int32_(t,4,0),a.weightSize=e.int32_(t,6,0),a.clippingThreshold=e.float32_(t,8,0),a.weightI=e.table(t,10,$root.MNN.Blob.decode),a.weightH=e.table(t,12,$root.MNN.Blob.decode),a.bias=e.table(t,14,$root.MNN.Blob.decode),a.weightIQ=e.table(t,16,$root.MNN.Blob.decode),a.weightIA=e.table(t,18,$root.MNN.Blob.decode),a.quantScale=e.float32_(t,20,0),a}},$root.MNN.Slice=class{static decode(e,t){const a=new $root.MNN.Slice;return a.axis=e.int32_(t,4,0),a.slicePoints=e.typedArray(t,6,Int32Array),a.sourceType=e.int8_(t,8,0),a}},$root.MNN.BatchNorm=class{static decode(e,t){const a=new $root.MNN.BatchNorm;return a.channels=e.int32_(t,4,0),a.slopeData=e.typedArray(t,6,Float32Array),a.meanData=e.typedArray(t,8,Float32Array),a.varData=e.typedArray(t,10,Float32Array),a.biasData=e.typedArray(t,12,Float32Array),a.Adata=e.typedArray(t,14,Float32Array),a.Bdata=e.typedArray(t,16,Float32Array),a.epsilon=e.float32_(t,18,.001),a}},$root.MNN.Scale=class{static decode(e,t){const a=new $root.MNN.Scale;return a.channels=e.int32_(t,4,0),a.scaleData=e.typedArray(t,6,Float32Array),a.biasData=e.typedArray(t,8,Float32Array),a}},$root.MNN.EltwiseType={PROD:0,SUM:1,MAXIMUM:2,SUB:3},$root.MNN.Eltwise=class{static decode(e,t){const a=new $root.MNN.Eltwise;return a.type=e.int8_(t,4,0),a.coeff=e.typedArray(t,6,Float32Array),a}},$root.MNN.Flatten=class{static decode(e,t){const a=new $root.MNN.Flatten;return a.axis=e.int32_(t,4,0),a.endAxis=e.int32_(t,6,0),a}},$root.MNN.Permute=class{static decode(e,t){const a=new $root.MNN.Permute;return a.dims=e.typedArray(t,4,Int32Array),a}},$root.MNN.Reshape=class{static decode(e,t){const a=new $root.MNN.Reshape;return a.dims=e.typedArray(t,4,Int32Array),a.dimType=e.int8_(t,6,void 0),a}},$root.MNN.DetectionOutput=class{static decode(e,t){const a=new $root.MNN.DetectionOutput;return a.classCount=e.int32_(t,4,0),a.nmsThresholdold=e.float32_(t,6,0),a.nmsTopK=e.int32_(t,8,0),a.keepTopK=e.int32_(t,10,0),a.confidenceThreshold=e.float32_(t,12,0),a.shareLocation=e.int32_(t,14,0),a.backgroundLable=e.int32_(t,16,0),a.varianceEncodedTarget=e.int32_(t,18,0),a.codeType=e.int32_(t,20,0),a.objectnessScore=e.float32_(t,22,.01),a}},$root.MNN.RoiPooling=class{static decode(e,t){const a=new $root.MNN.RoiPooling;return a.pooledWidth=e.int32_(t,4,0),a.pooledHeight=e.int32_(t,6,0),a.spatialScale=e.float32_(t,8,0),a}},$root.MNN.Proposal=class{static decode(e,t){const a=new $root.MNN.Proposal;return a.featStride=e.int32_(t,4,0),a.baseSize=e.int32_(t,6,0),a.preNmsTopN=e.int32_(t,8,0),a.afterNmsTopN=e.int32_(t,10,0),a.nmsThreshold=e.float32_(t,12,0),a.minSize=e.int32_(t,14,0),a.ratios=e.table(t,16,$root.MNN.Blob.decode),a.scales=e.table(t,18,$root.MNN.Blob.decode),a.anchors=e.table(t,20,$root.MNN.Blob.decode),a}},$root.MNN.Interp=class{static decode(e,t){const a=new $root.MNN.Interp;return a.widthScale=e.float32_(t,4,0),a.heightScale=e.float32_(t,6,0),a.outputWidth=e.int32_(t,8,0),a.outputHeight=e.int32_(t,10,0),a.resizeType=e.int32_(t,12,0),a.alignCorners=e.bool_(t,14,!1),a.halfPixelCenters=e.bool_(t,16,!1),a}},$root.MNN.Resize=class{static decode(e,t){const a=new $root.MNN.Resize;return a.xScale=e.float32_(t,4,0),a.yScale=e.float32_(t,6,0),a}},$root.MNN.PriorBox=class{static decode(e,t){const a=new $root.MNN.PriorBox;return a.minSizes=e.typedArray(t,4,Float32Array),a.maxSizes=e.typedArray(t,6,Float32Array),a.aspectRatios=e.typedArray(t,8,Float32Array),a.variances=e.typedArray(t,10,Float32Array),a.flip=e.bool_(t,12,!1),a.clip=e.bool_(t,14,!1),a.imageWidth=e.int32_(t,16,0),a.imageHeight=e.int32_(t,18,0),a.stepWidth=e.int32_(t,20,0),a.stepHeight=e.int32_(t,22,0),a.offset=e.float32_(t,24,0),a}},$root.MNN.Normalize=class{static decode(e,t){const a=new $root.MNN.Normalize;return a.acrossSpatial=e.int32_(t,4,0),a.channelShared=e.int32_(t,6,0),a.eps=e.float32_(t,8,0),a.scale=e.typedArray(t,10,Float32Array),a}},$root.MNN.EltwiseInt8=class{static decode(e,t){const a=new $root.MNN.EltwiseInt8;return a.type=e.int8_(t,4,0),a.inputQuan0=e.table(t,6,$root.MNN.QuantizedFloatParam.decode),a.inputQuan1=e.table(t,8,$root.MNN.QuantizedFloatParam.decode),a.outputQuan=e.table(t,10,$root.MNN.QuantizedFloatParam.decode),a}},$root.MNN.MNN_DATA_FORMAT={NCHW:0,NHWC:1,NC4HW4:2,NHWC4:3,UNKNOWN:4},$root.MNN.Blob=class{static decode(e,t){const a=new $root.MNN.Blob;return a.dims=e.typedArray(t,4,Int32Array),a.dataFormat=e.int8_(t,6,0),a.dataType=e.int32_(t,8,1),a.uint8s=e.typedArray(t,10,Uint8Array),a.int8s=e.typedArray(t,12,Int8Array),a.int32s=e.typedArray(t,14,Int32Array),a.int64s=e.int64s_(t,16),a.float32s=e.typedArray(t,18,Float32Array),a.strings=e.strings_(t,20),a}},$root.MNN.ListValue=class{static decode(e,t){const a=new $root.MNN.ListValue;return a.s=e.strings_(t,4),a.i=e.typedArray(t,6,Int32Array),a.f=e.typedArray(t,8,Float32Array),a.b=e.bools_(t,10),a.type=e.typedArray(t,12,Int32Array),a}},$root.MNN.Attribute=class{static decode(e,t){const a=new $root.MNN.Attribute;return a.s=e.string_(t,4,null),a.i=e.int32_(t,6,0),a.b=e.bool_(t,8,!1),a.key=e.string_(t,10,null),a.type=e.int32_(t,12,void 0),a.f=e.float32_(t,14,0),a.tensor=e.table(t,16,$root.MNN.Blob.decode),a.list=e.table(t,18,$root.MNN.ListValue.decode),a}},$root.MNN.NetSource={CAFFE:0,TENSORFLOW:1,TFLITE:2,ONNX:3},$root.MNN.DataType={DT_INVALID:0,DT_FLOAT:1,DT_DOUBLE:2,DT_INT32:3,DT_UINT8:4,DT_INT16:5,DT_INT8:6,DT_STRING:7,DT_COMPLEX64:8,DT_INT64:9,DT_BOOL:10,DT_QINT8:11,DT_QUINT8:12,DT_QINT32:13,DT_BFLOAT16:14,DT_QINT16:15,DT_QUINT16:16,DT_UINT16:17,DT_COMPLEX128:18,DT_HALF:19,DT_RESOURCE:20,DT_VARIANT:21},$root.MNN.BinaryOpOperation={ADD:0,SUB:1,MUL:2,DIV:3,MAX_TEMP:4,MIN_TEMP:5,POW:6,REALDIV:7,MINIMUM:8,MAXIMUM:9,GREATER:10,GREATER_EQUAL:11,LESS:12,FLOORDIV:13,SquaredDifference:14,EQUAL:15,LESS_EQUAL:16,FLOORMOD:17,MOD:19,ATAN2:20,LOGICALOR:21,NOTEQUAL:22},$root.MNN.BinaryOp=class{static decode(e,t){const a=new $root.MNN.BinaryOp;return a.opType=e.int32_(t,4,0),a.T=e.int32_(t,6,1),a}},$root.MNN.PackParam=class{static decode(e,t){const a=new $root.MNN.PackParam;return a.dataType=e.int32_(t,4,0),a.axis=e.int32_(t,6,0),a}},$root.MNN.StridedSliceParam=class{static decode(e,t){const a=new $root.MNN.StridedSliceParam;return a.Index=e.int32_(t,4,0),a.T=e.int32_(t,6,0),a.beginMask=e.int32_(t,8,0),a.endMask=e.int32_(t,10,0),a.ellipsisMask=e.int32_(t,12,0),a.newAxisMask=e.int32_(t,14,0),a.shrinkAxisMask=e.int32_(t,16,0),a}},$root.MNN.SqueezeParam=class{static decode(e,t){const a=new $root.MNN.SqueezeParam;return a.squeezeDims=e.typedArray(t,4,Int32Array),a}},$root.MNN.CastParam=class{static decode(e,t){const a=new $root.MNN.CastParam;return a.srcT=e.int32_(t,4,0),a.dstT=e.int32_(t,6,0),a}},$root.MNN.ReductionType={SUM:0,ASUM:1,SUMSQ:2,MEAN:3,MAXIMUM:4,MINIMUM:5,PROD:6,ANY:7,ALL:8},$root.MNN.ReductionParam=class{static decode(e,t){const a=new $root.MNN.ReductionParam;return a.operation=e.int8_(t,4,0),a.dim=e.typedArray(t,6,Int32Array),a.coeff=e.float32_(t,8,0),a.keepDims=e.bool_(t,10,!1),a.dType=e.int32_(t,12,1),a}},$root.MNN.Gather=class{static decode(e,t){const a=new $root.MNN.Gather;return a.Tindices=e.int32_(t,4,0),a.Tparams=e.int32_(t,6,0),a.validateIndices=e.bool_(t,8,!1),a.axis=e.int32_(t,10,0),a}},$root.MNN.ExpandDims=class{static decode(e,t){const a=new $root.MNN.ExpandDims;return a.T=e.int32_(t,4,0),a.Tdim=e.int32_(t,6,0),a.axis=e.int32_(t,8,0),a}},$root.MNN.Selu=class{static decode(e,t){const a=new $root.MNN.Selu;return a.scale=e.float32_(t,4,0),a.alpha=e.float32_(t,6,0),a}},$root.MNN.AsString=class{static decode(e,t){const a=new $root.MNN.AsString;return a.T=e.int32_(t,4,0),a.precision=e.int32_(t,6,0),a.scientific=e.bool_(t,8,!1),a.shortest=e.bool_(t,10,!1),a.width=e.int32_(t,12,0),a.fillString=e.string_(t,14,null),a}},$root.MNN.ReduceJoin=class{static decode(e,t){const a=new $root.MNN.ReduceJoin;return a.keepDims=e.bool_(t,4,!1),a.separator=e.string_(t,6,null),a}},$root.MNN.UnaryOpOperation={ABS:0,NEG:1,FLOOR:2,CEIL:3,SQUARE:4,SQRT:5,RSQRT:6,EXP:7,LOG:8,SIN:9,COS:10,TAN:11,ASIN:12,ACOS:13,ATAN:14,RECIPROCAL:15,LOG1P:16,BNLL:17,ACOSH:18,SINH:19,ASINH:20,ATANH:21,SIGN:22,ROUND:23,COSH:24,ERF:25,ERFC:26,ERFINV:27,EXPM1:28},$root.MNN.UnaryOp=class{static decode(e,t){const a=new $root.MNN.UnaryOp;return a.opType=e.int32_(t,4,0),a.T=e.int32_(t,6,0),a}},$root.MNN.TopKV2=class{static decode(e,t){const a=new $root.MNN.TopKV2;return a.T=e.int32_(t,4,1),a.sorted=e.bool_(t,6,!1),a}},$root.MNN.CropAndResizeMethod={BILINEAR:0,NEAREST:1},$root.MNN.CropAndResize=class{static decode(e,t){const a=new $root.MNN.CropAndResize;return a.extrapolationValue=e.float32_(t,4,0),a.method=e.int8_(t,6,0),a}},$root.MNN.Fill=class{static decode(e,t){return new $root.MNN.Fill}},$root.MNN.GatherV2=class{static decode(e,t){const a=new $root.MNN.GatherV2;return a.Taxis=e.int32_(t,4,0),a.Tindices=e.int32_(t,6,0),a.Tparams=e.int32_(t,8,0),a}},$root.MNN.NonMaxSuppressionV2=class{static decode(e,t){return new $root.MNN.NonMaxSuppressionV2}},$root.MNN.Range=class{static decode(e,t){const a=new $root.MNN.Range;return a.Tidx=e.int32_(t,4,0),a}},$root.MNN.Rank=class{static decode(e,t){return new $root.MNN.Rank}},$root.MNN.Size=class{static decode(e,t){const a=new $root.MNN.Size;return a.outputDataType=e.int32_(t,4,0),a}},$root.MNN.Transpose=class{static decode(e,t){const a=new $root.MNN.Transpose;return a.Tperm=e.int32_(t,4,0),a}},$root.MNN.SliceTf=class{static decode(e,t){const a=new $root.MNN.SliceTf;return a.T=e.int32_(t,4,0),a}},$root.MNN.QuantizeMaxMin=class{static decode(e,t){const a=new $root.MNN.QuantizeMaxMin;return a.T=e.int32_(t,4,0),a}},$root.MNN.Crop=class{static decode(e,t){const a=new $root.MNN.Crop;return a.axis=e.int32_(t,4,2),a.offset=e.typedArray(t,6,Int32Array),a}},$root.MNN.SpaceBatch=class{static decode(e,t){const a=new $root.MNN.SpaceBatch;return a.blockShape=e.table(t,4,$root.MNN.Blob.decode),a.padding=e.table(t,6,$root.MNN.Blob.decode),a}},$root.MNN.MatMul=class{static decode(e,t){const a=new $root.MNN.MatMul;return a.T=e.int32_(t,4,0),a.transposeA=e.bool_(t,6,!1),a.transposeB=e.bool_(t,8,!1),a.weight=e.typedArray(t,10,Float32Array),a.bias=e.typedArray(t,12,Float32Array),a}},$root.MNN.MomentsParam=class{static decode(e,t){const a=new $root.MNN.MomentsParam;return a.dim=e.typedArray(t,4,Int32Array),a.keepDims=e.bool_(t,6,!0),a.dType=e.int32_(t,8,1),a}},$root.MNN.RNNParam=class{static decode(e,t){const a=new $root.MNN.RNNParam;return a.numUnits=e.int32_(t,4,0),a.isBidirectionalRNN=e.bool_(t,6,!1),a.keepAllOutputs=e.bool_(t,8,!1),a.fwGateWeight=e.table(t,10,$root.MNN.Blob.decode),a.fwGateBias=e.table(t,12,$root.MNN.Blob.decode),a.fwCandidateWeight=e.table(t,14,$root.MNN.Blob.decode),a.fwCandidateBias=e.table(t,16,$root.MNN.Blob.decode),a.bwGateWeight=e.table(t,18,$root.MNN.Blob.decode),a.bwGateBias=e.table(t,20,$root.MNN.Blob.decode),a.bwCandidateWeight=e.table(t,22,$root.MNN.Blob.decode),a.bwCandidateBias=e.table(t,24,$root.MNN.Blob.decode),a}},$root.MNN.BatchMatMulParam=class{static decode(e,t){const a=new $root.MNN.BatchMatMulParam;return a.adjX=e.bool_(t,4,!1),a.adjY=e.bool_(t,6,!1),a}},$root.MNN.DepthSpaceParam=class{static decode(e,t){const a=new $root.MNN.DepthSpaceParam;return a.blockSize=e.int32_(t,4,0),a}},$root.MNN.ReverseSequenceParam=class{static decode(e,t){const a=new $root.MNN.ReverseSequenceParam;return a.batchDim=e.int32_(t,4,0),a.seqDim=e.int32_(t,6,0),a}},$root.MNN.DetectionPostProcessParam=class{static decode(e,t){const a=new $root.MNN.DetectionPostProcessParam;return a.maxDetections=e.int32_(t,4,0),a.maxClassesPerDetection=e.int32_(t,6,0),a.detectionsPerClass=e.int32_(t,8,0),a.nmsScoreThreshold=e.float32_(t,10,0),a.iouThreshold=e.float32_(t,12,0),a.numClasses=e.int32_(t,14,0),a.useRegularNMS=e.bool_(t,16,!1),a.centerSizeEncoding=e.typedArray(t,18,Float32Array),a}},$root.MNN.OneHotParam=class{static decode(e,t){const a=new $root.MNN.OneHotParam;return a.dType=e.int32_(t,4,1),a.axis=e.int32_(t,6,-1),a}},$root.MNN.PadValueMode={CONSTANT:0,REFLECT:1,SYMMETRIC:2},$root.MNN.PadParam=class{static decode(e,t){const a=new $root.MNN.PadParam;return a.mode=e.int8_(t,4,0),a}},$root.MNN.FusedActivation={kTfLiteActNone:0,kTfLiteActRelu:1,kTfLiteActRelu1:2,kTfLiteActRelu6:3,kTfLiteActTanh:4,kTfLiteActSignBit:5,kTfLiteActSigmoid:6},$root.MNN.QuantizedParam=class{static decode(e,t){const a=new $root.MNN.QuantizedParam;return a.zeroPoint=e.int32_(t,4,0),a.scale=e.float32_(t,6,0),a}},$root.MNN.QuantizedAdd=class{static decode(e,t){const a=new $root.MNN.QuantizedAdd;return a.activationType=e.int8_(t,4,0),a.input1QuantizedParam=e.table(t,6,$root.MNN.QuantizedParam.decode),a.input2QuantizedParam=e.table(t,8,$root.MNN.QuantizedParam.decode),a.outputQuantizedParam=e.table(t,10,$root.MNN.QuantizedParam.decode),a}},$root.MNN.ModeFormat={TENSORFLOW:0,TFLITE:1},$root.MNN.QuantizeMode={MIN_COMBINED:0,MIN_FIRST:1,SCALED:2},$root.MNN.Dequantize=class{static decode(e,t){const a=new $root.MNN.Dequantize;return a.inputQuantizedParam=e.table(t,4,$root.MNN.QuantizedParam.decode),a.mode=e.int8_(t,6,0),a.modelFormat=e.int8_(t,8,0),a.type=e.int32_(t,10,0),a}},$root.MNN.QuantizedAvgPool=class{static decode(e,t){const a=new $root.MNN.QuantizedAvgPool;return a.kernelX=e.int32_(t,4,0),a.kernelY=e.int32_(t,6,0),a.modelFormat=e.int8_(t,8,0),a.outputActivationMax=e.int32_(t,10,0),a.outputActivationMin=e.int32_(t,12,0),a.padType=e.int8_(t,14,0),a.padX=e.int32_(t,16,0),a.padY=e.int32_(t,18,0),a.strideX=e.int32_(t,20,0),a.strideY=e.int32_(t,22,0),a.type=e.int32_(t,24,0),a}},$root.MNN.QuantizedBiasAdd=class{static decode(e,t){const a=new $root.MNN.QuantizedBiasAdd;return a.bias=e.typedArray(t,4,Int32Array),a.inputType=e.int32_(t,6,0),a.max=e.int32_(t,8,0),a.min=e.int32_(t,10,0),a.outputType=e.int32_(t,12,0),a}},$root.MNN.QuantizedConcat=class{static decode(e,t){const a=new $root.MNN.QuantizedConcat;return a.activationType=e.int8_(t,4,0),a.axis=e.int32_(t,6,0),a.inputScale=e.typedArray(t,8,Float32Array),a.inputZeroPoint=e.typedArray(t,10,Int32Array),a.outputQuantizedParam=e.table(t,12,$root.MNN.QuantizedParam.decode),a}},$root.MNN.QuantizedLogistic=class{static decode(e,t){const a=new $root.MNN.QuantizedLogistic;return a.inputQuantizedParam=e.table(t,4,$root.MNN.QuantizedParam.decode),a.outputQuantizedParam=e.table(t,6,$root.MNN.QuantizedParam.decode),a}},$root.MNN.QuantizedMatMul=class{static decode(e,t){const a=new $root.MNN.QuantizedMatMul;return a.transposeA=e.bool_(t,4,!1),a.transposeB=e.bool_(t,6,!1),a}},$root.MNN.QuantizedMaxPool=class{static decode(e,t){const a=new $root.MNN.QuantizedMaxPool;return a.kernelX=e.int32_(t,4,0),a.kernelY=e.int32_(t,6,0),a.modelFormat=e.int8_(t,8,0),a.outputActivationMax=e.int32_(t,10,0),a.outputActivationMin=e.int32_(t,12,0),a.padType=e.int8_(t,14,0),a.padX=e.int32_(t,16,0),a.padY=e.int32_(t,18,0),a.strideX=e.int32_(t,20,0),a.strideY=e.int32_(t,22,0),a.type=e.int32_(t,24,0),a}},$root.MNN.QuantizedRelu=class{static decode(e,t){const a=new $root.MNN.QuantizedRelu;return a.type=e.int32_(t,4,0),a}},$root.MNN.QuantizedRelu6=class{static decode(e,t){const a=new $root.MNN.QuantizedRelu6;return a.type=e.int32_(t,4,0),a}},$root.MNN.QuantizedReshape=class{static decode(e,t){const a=new $root.MNN.QuantizedReshape;return a.dims=e.typedArray(t,4,Int32Array),a.modelFormat=e.int8_(t,6,0),a}},$root.MNN.QuantizedSoftmax=class{static decode(e,t){const a=new $root.MNN.QuantizedSoftmax;return a.beta=e.float32_(t,4,0),a.inputScale=e.float32_(t,6,0),a}},$root.MNN.QuantizeRoundMode={HALF_AWAY_FROM_ZERO:0,HALF_TO_EVEN:1},$root.MNN.QuantizeV2=class{static decode(e,t){const a=new $root.MNN.QuantizeV2;return a.type=e.int32_(t,4,0),a.mode=e.int8_(t,6,0),a.roundMode=e.int8_(t,8,0),a}},$root.MNN.RequantizationRange=class{static decode(e,t){return new $root.MNN.RequantizationRange}},$root.MNN.Requantize=class{static decode(e,t){return new $root.MNN.Requantize}},$root.MNN.TfQuantizedConv2D=class{static decode(e,t){const a=new $root.MNN.TfQuantizedConv2D;return a.bias=e.typedArray(t,4,Int32Array),a.biasflag=e.bool_(t,6,!1),a.common=e.table(t,8,$root.MNN.Convolution2DCommon.decode),a.weight=e.typedArray(t,10,Uint8Array),a.activationType=e.int8_(t,12,0),a.multiplier=e.int32_(t,14,0),a.outMax=e.int32_(t,16,0),a.outMin=e.int32_(t,18,0),a.shift=e.int32_(t,20,0),a.biasQuantizedParam=e.table(t,22,$root.MNN.QuantizedParam.decode),a.depthMultiplier=e.int32_(t,24,0),a.filterQuantizedParam=e.table(t,26,$root.MNN.QuantizedParam.decode),a.inputQuantizedParam=e.table(t,28,$root.MNN.QuantizedParam.decode),a.modelFormat=e.int8_(t,30,0),a.outputQuantizedParam=e.table(t,32,$root.MNN.QuantizedParam.decode),a}},$root.MNN.STORAGE_TYPE={BUFFER:0,UNIFORM:1,IMAGE:2},$root.MNN.ACCESS_TYPE={READ_ONLY:0,WRITE_ONLY:1,READ_WRITE:2},$root.MNN.GpuBuffer=class{static decode(e,t){const a=new $root.MNN.GpuBuffer;return a.access=e.int8_(t,4,0),a.storage=e.int8_(t,6,0),a.content=e.table(t,8,$root.MNN.Blob.decode),a}},$root.MNN.GpuPipeline=class{static decode(e,t){const a=new $root.MNN.GpuPipeline;return a.localSize=e.typedArray(t,4,Int32Array),a.key=e.string_(t,6,null),a.metal=e.typedArray(t,8,Int8Array),a.vulkan=e.typedArray(t,10,Int8Array),a.openglComputeShader=e.string_(t,12,null),a.openclKernel=e.string_(t,14,null),a}},$root.MNN.GpuStage=class{static decode(e,t){const a=new $root.MNN.GpuStage;return a.pipeline=e.string_(t,4,null),a.groupSize=e.typedArray(t,6,Int32Array),a.inputIndexes=e.typedArray(t,8,Int32Array),a.outputIndexes=e.typedArray(t,10,Int32Array),a.middleBuffer=e.tableArray(t,12,$root.MNN.GpuBuffer.decode),a.constBuffer=e.tableArray(t,14,$root.MNN.GpuBuffer.decode),a.globalSizeIndex=e.int32_(t,16,0),a.globalSizeDivide=e.typedArray(t,18,Int32Array),a.requireSize=e.bool_(t,20,!1),a}},$root.MNN.GpuFunction=class{static decode(e,t){const a=new $root.MNN.GpuFunction;return a.stags=e.tableArray(t,4,$root.MNN.GpuStage.decode),a.name=e.string_(t,6,null),a}},$root.MNN.GpuLibrary=class{static decode(e,t){const a=new $root.MNN.GpuLibrary;return a.functions=e.tableArray(t,4,$root.MNN.GpuFunction.decode),a.pipeline=e.tableArray(t,6,$root.MNN.GpuPipeline.decode),a.name=e.string_(t,8,null),a}},$root.MNN.TensorConvertInfo=class{static decode(e,t){const a=new $root.MNN.TensorConvertInfo;return a.source=e.int8_(t,4,0),a.dest=e.int8_(t,6,0),a}};
