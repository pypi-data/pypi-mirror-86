# AUTOGENERATED! DO NOT EDIT! File to edit: 01_modelo_risco_coletivo.ipynb (unless otherwise specified).

__all__ = ['ModeloRiscoCol']

# Cell
import numpy as np
from scipy import stats

class ModeloRiscoCol:

    def __init__(self, N, PN, X, PX):
        '''
        Argumentos:
            N (Int): lista com quantidade de sinistros.
            PN (Float): lista com as probabilidade de ocorrência de N de sinistros
            X (Float): lista com os valores da distribuição valor de '1' sinistro
            PX (Float): lista com as probabilidades de X.
        '''
        self.N = N
        self.PN = PN
        self.X = X
        self.PX = PX

        self.setup()


    def setup(self):
        '''
        Inicialização das funções
        '''
        self.EX = np.dot(self.X, self.PX)
        self.EX2 = np.dot(np.array(self.X)**2, self.PX)
        self.VX = self.EX2 - self.EX**2

        self.EN = np.dot(self.N, self.PN)
        self.EN2 = np.dot(np.array(self.N)**2, self.PN)
        self.VN = self.EN2 - self.EN**2


    def __str__(self):
         return f'Modelo de Risco Coletivo:\nE[N] = {self.EN}\nV[N] = {self.VN}\nE[X] = {self.EX}\nV[X] = {self.VX}'

    def esperanca(self):
        '''
        Calcula a esperança dos sinistros.
        '''
        return self.EN * self.EX

    def variancia(self):
        '''
        Calcula a variância dos sinistros.
        '''
        return (self.EN * self.VX) + (self.EX**2 * self.VN)

    def desv_pad(self):
        '''
        Calcula o desvio padrão dos sinistros.
        '''
        return np.sqrt(self.variancia())

    def coef_var(self):
        '''
        Calcula o coeficiente de variação dos sinistros.
        '''
        return self.desv_pad()/self.esperanca()

    def premio_puro(self, carreg_seg):
        '''
        Calcula o prêmio puro para o modelo de risco coletivo
        Argumentos:
            carreg_seg (Float): carregamento de segurança estatístico
        Retorna:
            premio (Float): prêmio puro
        '''

        return round(self.esperanca() * (1 + carreg_seg), 2)

    def premio_comercial(self, carreg_seg, carreg_adm):
        '''
        Calcula o prêmio comercial para o modelo de risco individual
        Argumentos:
            carreg_seg (Float): carregamento de segurança estatístico
            carreg_adm (Float): carregamento de administração

        Retorna:
            premio (Float): prêmio comercial
        '''
        return round(self.premio_puro(carreg_seg)/(1 - carreg_adm), 2)


    def premio_aprox_normal(self, alfa):
        '''
        Calcula o prêmio pela aproximação normal.
        Argumentos:
            alfa (Float): probabilidade de o sinistro individual superar o prêmio puro total

        Retorna:
            premio (Float): prêmio pela aproximação normal
        '''
        z = stats.norm.ppf(1-alfa)
        return self.esperanca() + z * self.desv_pad()

    def carreg_seg(self, alfa):
        '''
        Calcula o carregamento de segurança pela aproximação normal.
        Argumentos:
            alfa (Float): probabilidade de o sinistro individual superar o prêmio puro total
        '''
        z = stats.norm.ppf(1-alfa)
        return z * self.coef_var()
