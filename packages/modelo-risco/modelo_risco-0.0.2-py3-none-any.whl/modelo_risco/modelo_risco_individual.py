# AUTOGENERATED! DO NOT EDIT! File to edit: 00_modelo_risco_individual.ipynb (unless otherwise specified).

__all__ = ['ModeloRiscoInd']

# Cell
import numpy as np
from scipy import stats

class ModeloRiscoInd:

    def __init__(self, n, qi, B, qtd_riscos = 1):
        '''
        Argumentos:
            Se qtd_riscos == 1:
                n (Int): quantidade de apólices
                qi (Float): probabilidade de ocorrência de sinistros
                B (dictionary): dicionário com 'PBi': lista com probabilidades de Bi; 'Bi': lista com valores de Bi
            Caso qtd_riscos > 1:
                n (numpy array): quantidade de apólices
                qi (numpy array): probabilidade de ocorrência de sinistros
                B (dictionary): dicionário com 'PBi': numpy array com probabilidades de Bi; 'Bi': numpy array com valores de Bi
        '''
        self.n = n
        self.EI = qi
        self.VI = qi * (1-qi)
        self.B = B
        self.qtd_riscos = qtd_riscos

        self.setup()


    def setup(self):
        '''
        Inicialização da distribuição do valor do sinistro dado que ocorreu o sinistro.
        Calcula
        '''
        if self.qtd_riscos == 1:
            PBi = np.array(self.B['PBi'])
            Bi = np.array(self.B['Bi'])

            self.EB = np.dot(PBi, Bi)
            self.VB = np.dot(PBi, Bi**2) - self.EB**2

        else:
            PBi = self.B['PBi']
            Bi = self.B['Bi']

            self.EB = (PBi * Bi).sum(axis=1)
            self.VB = ((PBi * (Bi**2)).sum(axis=1) - (self.EB**2))


    def __str__(self):
        return f'Modelo de Risco Individual:\nn = {self.n}\nE[I] = {self.EI}\nV[I] = {self.VI}\nE[B] = {self.EB}\nV[B] = {self.VB}'


    def esperanca(self):
        '''
        Calcula a esperança dos sinistros.
        '''
        if self.qtd_riscos == 1:
            return self.n * self.EI * self.EB
        else:
            return (self.n * self.EI * self.EB).sum()


    def variancia(self):
        '''
        Calcula a variância dos sinistros.
        '''

        if self.qtd_riscos == 1:
            return (self.n * self.EI * self.VB) + (self.n * self.VI * self.EB**2)
        else:
            return ((self.n * self.EI * self.VB) + (self.n * self.VI * self.EB**2)).sum()


    def desv_pad(self):
        '''
        Calcula o desvio padrão dos sinistros.
        '''
        return np.sqrt(self.variancia())


    def coef_var(self):
        '''
        Calcula o coeficiente de variação dos sinistros.
        '''
        return self.desv_pad()/self.esperanca()


    def premio_puro(self, carreg_seg):
        '''
        Calcula o prêmio puro para o modelo de risco individual
        Argumentos:
            carreg_seg (Float): carregamento de segurança estatístico.

        Retorna:
            premio (Float): prêmio puro
        '''

        return round(self.esperanca() * (1 + carreg_seg), 2)


    def premio_comercial(self, carreg_seg, carreg_adm):
        '''
        Calcula o prêmio comercial para o modelo de risco individual
        Argumentos:
            carreg_seg (Float): carregamento de segurança estatístico
            carreg_adm (Float): carregamento de administração

        Retorna:
            premio (Float): prêmio comercial
        '''
        return round(self.premio_puro(carreg_seg)/(1 - carreg_adm), 2)


    def premio_aprox_normal(self, alfa):
        '''
        Calcula o prêmio pela aproximação normal.
        Argumentos:
            alfa (Float): probabilidade de o sinistro individual superar o prêmio puro total

        Retorna:
            premio (Float): prêmio pela aproximação normal
        '''
        z = stats.norm.ppf(1-alfa)
        return self.esperanca() + z * self.desv_pad()


    def carreg_seg(self, alfa):
        '''
        Calcula o carregamento de segurança pela aproximação normal.
        Argumentos:
            alfa (Float): probabilidade de o sinistro individual superar o prêmio puro total
        '''
        z = stats.norm.ppf(1-alfa)
        return z * self.coef_var()
