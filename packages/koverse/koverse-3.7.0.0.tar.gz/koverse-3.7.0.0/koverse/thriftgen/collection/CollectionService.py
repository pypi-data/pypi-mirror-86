#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getCollectionById(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def getCollectionByIdNotDeleted(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def getCollectionByName(self, auth, collectionName):
        """
        Parameters:
         - auth
         - collectionName

        """
        pass

    def listCollections(self, auth, getRecordCounts):
        """
        Parameters:
         - auth
         - getRecordCounts

        """
        pass

    def createCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        pass

    def updateCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        pass

    def deleteCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        pass

    def clearCollection(self, auth, collectionId, removeFieldNamesSeen):
        """
        Parameters:
         - auth
         - collectionId
         - removeFieldNamesSeen

        """
        pass

    def repair(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
        """
        Parameters:
         - auth
         - collectionId
         - maxRecords
         - removeByteArrayFieldValues
         - maxStringValueLength

        """
        pass

    def getAllRecords(self, auth, collectionId, maxRecords):
        """
        Parameters:
         - auth
         - collectionId
         - maxRecords

        """
        pass

    def startDownloadRecords(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def downloadMoreRecords(self, auth, downloadId, maxToReturn):
        """
        Parameters:
         - auth
         - downloadId
         - maxToReturn

        """
        pass

    def stopDownloadRecords(self, auth, downloadId):
        """
        Parameters:
         - auth
         - downloadId

        """
        pass

    def startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
        """
        Parameters:
         - auth
         - collectionId
         - removeByteArrayFieldValues

        """
        pass

    def downloadMoreSamples(self, auth, downloadId, maxToReturn):
        """
        Parameters:
         - auth
         - downloadId
         - maxToReturn

        """
        pass

    def stopDownloadSamples(self, auth, downloadId):
        """
        Parameters:
         - auth
         - downloadId

        """
        pass

    def getSqlSchema(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def getAllSqlRecords(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def getSparkRDDConf(self, auth, collectionName):
        """
        Parameters:
         - auth
         - collectionName

        """
        pass

    def getNewSparkJobOutputPath(self, auth):
        """
        Parameters:
         - auth

        """
        pass

    def addSparkFilesToCollection(self, auth, collectionName, path):
        """
        Parameters:
         - auth
         - collectionName
         - path

        """
        pass

    def cleanupSparkImportDir(self, auth, importId):
        """
        Parameters:
         - auth
         - importId

        """
        pass

    def getCollectionSchema(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def getFlatCollectionSchema(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        pass

    def getDataSetAttributes(self, auth, dataSetId, detailLevel):
        """
        Parameters:
         - auth
         - dataSetId
         - detailLevel

        """
        pass

    def getDataSetAttributeNames(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def createLabel(self, auth, name):
        """
        Parameters:
         - auth
         - name

        """
        pass

    def getLabels(self, auth):
        """
        Parameters:
         - auth

        """
        pass

    def getLabel(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        pass

    def deleteLabel(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        pass

    def updateLabel(self, auth, label):
        """
        Parameters:
         - auth
         - label

        """
        pass

    def createLabelAssignment(self, auth, labelId, dataSetId):
        """
        Parameters:
         - auth
         - labelId
         - dataSetId

        """
        pass

    def getLabelAssignments(self, auth):
        """
        Parameters:
         - auth

        """
        pass

    def getLabelAssigmentById(self, auth, labelAssignmentId):
        """
        Parameters:
         - auth
         - labelAssignmentId

        """
        pass

    def deleteLabelAssignment(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        pass

    def getDataSetPermissions(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def createDataSetPermission(self, auth, permission):
        """
        Parameters:
         - auth
         - permission

        """
        pass

    def updateDataSetPermission(self, auth, permission):
        """
        Parameters:
         - auth
         - permission

        """
        pass

    def deleteDataSetPermission(self, auth, permissionId):
        """
        Parameters:
         - auth
         - permissionId

        """
        pass

    def getIndexingPolicy(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def updateIndexingPolicy(self, auth, indexingPolicy):
        """
        Parameters:
         - auth
         - indexingPolicy

        """
        pass

    def updateMaskedAttributes(self, auth, attributes):
        """
        Parameters:
         - auth
         - attributes

        """
        pass

    def getFieldMaskerDescriptions(self):
        pass

    def registerTable(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def unregisterTable(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        pass

    def writeRecord(self, auth, record):
        """
        Parameters:
         - auth
         - record

        """
        pass

    def writeRecords(self, auth, records):
        """
        Parameters:
         - auth
         - records

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getCollectionById(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_getCollectionById(auth, collectionId)
        return self.recv_getCollectionById()

    def send_getCollectionById(self, auth, collectionId):
        self._oprot.writeMessageBegin('getCollectionById', TMessageType.CALL, self._seqid)
        args = getCollectionById_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCollectionById(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCollectionById_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.nfe is not None:
            raise result.nfe
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionById failed: unknown result")

    def getCollectionByIdNotDeleted(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_getCollectionByIdNotDeleted(auth, collectionId)
        return self.recv_getCollectionByIdNotDeleted()

    def send_getCollectionByIdNotDeleted(self, auth, collectionId):
        self._oprot.writeMessageBegin('getCollectionByIdNotDeleted', TMessageType.CALL, self._seqid)
        args = getCollectionByIdNotDeleted_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCollectionByIdNotDeleted(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCollectionByIdNotDeleted_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.nfe is not None:
            raise result.nfe
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionByIdNotDeleted failed: unknown result")

    def getCollectionByName(self, auth, collectionName):
        """
        Parameters:
         - auth
         - collectionName

        """
        self.send_getCollectionByName(auth, collectionName)
        return self.recv_getCollectionByName()

    def send_getCollectionByName(self, auth, collectionName):
        self._oprot.writeMessageBegin('getCollectionByName', TMessageType.CALL, self._seqid)
        args = getCollectionByName_args()
        args.auth = auth
        args.collectionName = collectionName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCollectionByName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCollectionByName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.nfe is not None:
            raise result.nfe
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionByName failed: unknown result")

    def listCollections(self, auth, getRecordCounts):
        """
        Parameters:
         - auth
         - getRecordCounts

        """
        self.send_listCollections(auth, getRecordCounts)
        return self.recv_listCollections()

    def send_listCollections(self, auth, getRecordCounts):
        self._oprot.writeMessageBegin('listCollections', TMessageType.CALL, self._seqid)
        args = listCollections_args()
        args.auth = auth
        args.getRecordCounts = getRecordCounts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listCollections(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listCollections_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listCollections failed: unknown result")

    def createCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        self.send_createCollection(auth, collection)
        return self.recv_createCollection()

    def send_createCollection(self, auth, collection):
        self._oprot.writeMessageBegin('createCollection', TMessageType.CALL, self._seqid)
        args = createCollection_args()
        args.auth = auth
        args.collection = collection
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createCollection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createCollection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createCollection failed: unknown result")

    def updateCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        self.send_updateCollection(auth, collection)
        return self.recv_updateCollection()

    def send_updateCollection(self, auth, collection):
        self._oprot.writeMessageBegin('updateCollection', TMessageType.CALL, self._seqid)
        args = updateCollection_args()
        args.auth = auth
        args.collection = collection
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateCollection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateCollection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateCollection failed: unknown result")

    def deleteCollection(self, auth, collection):
        """
        Parameters:
         - auth
         - collection

        """
        self.send_deleteCollection(auth, collection)
        return self.recv_deleteCollection()

    def send_deleteCollection(self, auth, collection):
        self._oprot.writeMessageBegin('deleteCollection', TMessageType.CALL, self._seqid)
        args = deleteCollection_args()
        args.auth = auth
        args.collection = collection
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteCollection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteCollection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteCollection failed: unknown result")

    def clearCollection(self, auth, collectionId, removeFieldNamesSeen):
        """
        Parameters:
         - auth
         - collectionId
         - removeFieldNamesSeen

        """
        self.send_clearCollection(auth, collectionId, removeFieldNamesSeen)
        self.recv_clearCollection()

    def send_clearCollection(self, auth, collectionId, removeFieldNamesSeen):
        self._oprot.writeMessageBegin('clearCollection', TMessageType.CALL, self._seqid)
        args = clearCollection_args()
        args.auth = auth
        args.collectionId = collectionId
        args.removeFieldNamesSeen = removeFieldNamesSeen
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearCollection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearCollection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def repair(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_repair(auth, collectionId)
        self.recv_repair()

    def send_repair(self, auth, collectionId):
        self._oprot.writeMessageBegin('repair', TMessageType.CALL, self._seqid)
        args = repair_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_repair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = repair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
        """
        Parameters:
         - auth
         - collectionId
         - maxRecords
         - removeByteArrayFieldValues
         - maxStringValueLength

        """
        self.send_getCollectionSample(auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength)
        return self.recv_getCollectionSample()

    def send_getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
        self._oprot.writeMessageBegin('getCollectionSample', TMessageType.CALL, self._seqid)
        args = getCollectionSample_args()
        args.auth = auth
        args.collectionId = collectionId
        args.maxRecords = maxRecords
        args.removeByteArrayFieldValues = removeByteArrayFieldValues
        args.maxStringValueLength = maxStringValueLength
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCollectionSample(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCollectionSample_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ae is not None:
            raise result.ae
        if result.ke is not None:
            raise result.ke
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionSample failed: unknown result")

    def getAllRecords(self, auth, collectionId, maxRecords):
        """
        Parameters:
         - auth
         - collectionId
         - maxRecords

        """
        self.send_getAllRecords(auth, collectionId, maxRecords)
        return self.recv_getAllRecords()

    def send_getAllRecords(self, auth, collectionId, maxRecords):
        self._oprot.writeMessageBegin('getAllRecords', TMessageType.CALL, self._seqid)
        args = getAllRecords_args()
        args.auth = auth
        args.collectionId = collectionId
        args.maxRecords = maxRecords
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ae is not None:
            raise result.ae
        if result.ke is not None:
            raise result.ke
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllRecords failed: unknown result")

    def startDownloadRecords(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_startDownloadRecords(auth, collectionId)
        return self.recv_startDownloadRecords()

    def send_startDownloadRecords(self, auth, collectionId):
        self._oprot.writeMessageBegin('startDownloadRecords', TMessageType.CALL, self._seqid)
        args = startDownloadRecords_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startDownloadRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startDownloadRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadRecords failed: unknown result")

    def downloadMoreRecords(self, auth, downloadId, maxToReturn):
        """
        Parameters:
         - auth
         - downloadId
         - maxToReturn

        """
        self.send_downloadMoreRecords(auth, downloadId, maxToReturn)
        return self.recv_downloadMoreRecords()

    def send_downloadMoreRecords(self, auth, downloadId, maxToReturn):
        self._oprot.writeMessageBegin('downloadMoreRecords', TMessageType.CALL, self._seqid)
        args = downloadMoreRecords_args()
        args.auth = auth
        args.downloadId = downloadId
        args.maxToReturn = maxToReturn
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_downloadMoreRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = downloadMoreRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreRecords failed: unknown result")

    def stopDownloadRecords(self, auth, downloadId):
        """
        Parameters:
         - auth
         - downloadId

        """
        self.send_stopDownloadRecords(auth, downloadId)
        self.recv_stopDownloadRecords()

    def send_stopDownloadRecords(self, auth, downloadId):
        self._oprot.writeMessageBegin('stopDownloadRecords', TMessageType.CALL, self._seqid)
        args = stopDownloadRecords_args()
        args.auth = auth
        args.downloadId = downloadId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopDownloadRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopDownloadRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
        """
        Parameters:
         - auth
         - collectionId
         - removeByteArrayFieldValues

        """
        self.send_startDownloadSamples(auth, collectionId, removeByteArrayFieldValues)
        return self.recv_startDownloadSamples()

    def send_startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
        self._oprot.writeMessageBegin('startDownloadSamples', TMessageType.CALL, self._seqid)
        args = startDownloadSamples_args()
        args.auth = auth
        args.collectionId = collectionId
        args.removeByteArrayFieldValues = removeByteArrayFieldValues
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startDownloadSamples(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startDownloadSamples_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadSamples failed: unknown result")

    def downloadMoreSamples(self, auth, downloadId, maxToReturn):
        """
        Parameters:
         - auth
         - downloadId
         - maxToReturn

        """
        self.send_downloadMoreSamples(auth, downloadId, maxToReturn)
        return self.recv_downloadMoreSamples()

    def send_downloadMoreSamples(self, auth, downloadId, maxToReturn):
        self._oprot.writeMessageBegin('downloadMoreSamples', TMessageType.CALL, self._seqid)
        args = downloadMoreSamples_args()
        args.auth = auth
        args.downloadId = downloadId
        args.maxToReturn = maxToReturn
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_downloadMoreSamples(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = downloadMoreSamples_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreSamples failed: unknown result")

    def stopDownloadSamples(self, auth, downloadId):
        """
        Parameters:
         - auth
         - downloadId

        """
        self.send_stopDownloadSamples(auth, downloadId)
        self.recv_stopDownloadSamples()

    def send_stopDownloadSamples(self, auth, downloadId):
        self._oprot.writeMessageBegin('stopDownloadSamples', TMessageType.CALL, self._seqid)
        args = stopDownloadSamples_args()
        args.auth = auth
        args.downloadId = downloadId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stopDownloadSamples(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stopDownloadSamples_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def getSqlSchema(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_getSqlSchema(auth, dataSetId)
        return self.recv_getSqlSchema()

    def send_getSqlSchema(self, auth, dataSetId):
        self._oprot.writeMessageBegin('getSqlSchema', TMessageType.CALL, self._seqid)
        args = getSqlSchema_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSqlSchema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSqlSchema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ae is not None:
            raise result.ae
        if result.ke is not None:
            raise result.ke
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSqlSchema failed: unknown result")

    def getAllSqlRecords(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_getAllSqlRecords(auth, dataSetId)
        return self.recv_getAllSqlRecords()

    def send_getAllSqlRecords(self, auth, dataSetId):
        self._oprot.writeMessageBegin('getAllSqlRecords', TMessageType.CALL, self._seqid)
        args = getAllSqlRecords_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllSqlRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllSqlRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ae is not None:
            raise result.ae
        if result.ke is not None:
            raise result.ke
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllSqlRecords failed: unknown result")

    def getSparkRDDConf(self, auth, collectionName):
        """
        Parameters:
         - auth
         - collectionName

        """
        self.send_getSparkRDDConf(auth, collectionName)
        return self.recv_getSparkRDDConf()

    def send_getSparkRDDConf(self, auth, collectionName):
        self._oprot.writeMessageBegin('getSparkRDDConf', TMessageType.CALL, self._seqid)
        args = getSparkRDDConf_args()
        args.auth = auth
        args.collectionName = collectionName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSparkRDDConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSparkRDDConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSparkRDDConf failed: unknown result")

    def getNewSparkJobOutputPath(self, auth):
        """
        Parameters:
         - auth

        """
        self.send_getNewSparkJobOutputPath(auth)
        return self.recv_getNewSparkJobOutputPath()

    def send_getNewSparkJobOutputPath(self, auth):
        self._oprot.writeMessageBegin('getNewSparkJobOutputPath', TMessageType.CALL, self._seqid)
        args = getNewSparkJobOutputPath_args()
        args.auth = auth
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNewSparkJobOutputPath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNewSparkJobOutputPath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNewSparkJobOutputPath failed: unknown result")

    def addSparkFilesToCollection(self, auth, collectionName, path):
        """
        Parameters:
         - auth
         - collectionName
         - path

        """
        self.send_addSparkFilesToCollection(auth, collectionName, path)
        self.recv_addSparkFilesToCollection()

    def send_addSparkFilesToCollection(self, auth, collectionName, path):
        self._oprot.writeMessageBegin('addSparkFilesToCollection', TMessageType.CALL, self._seqid)
        args = addSparkFilesToCollection_args()
        args.auth = auth
        args.collectionName = collectionName
        args.path = path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addSparkFilesToCollection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addSparkFilesToCollection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def cleanupSparkImportDir(self, auth, importId):
        """
        Parameters:
         - auth
         - importId

        """
        self.send_cleanupSparkImportDir(auth, importId)
        self.recv_cleanupSparkImportDir()

    def send_cleanupSparkImportDir(self, auth, importId):
        self._oprot.writeMessageBegin('cleanupSparkImportDir', TMessageType.CALL, self._seqid)
        args = cleanupSparkImportDir_args()
        args.auth = auth
        args.importId = importId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cleanupSparkImportDir(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cleanupSparkImportDir_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def getCollectionSchema(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_getCollectionSchema(auth, collectionId)
        return self.recv_getCollectionSchema()

    def send_getCollectionSchema(self, auth, collectionId):
        self._oprot.writeMessageBegin('getCollectionSchema', TMessageType.CALL, self._seqid)
        args = getCollectionSchema_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCollectionSchema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCollectionSchema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionSchema failed: unknown result")

    def getFlatCollectionSchema(self, auth, collectionId):
        """
        Parameters:
         - auth
         - collectionId

        """
        self.send_getFlatCollectionSchema(auth, collectionId)
        return self.recv_getFlatCollectionSchema()

    def send_getFlatCollectionSchema(self, auth, collectionId):
        self._oprot.writeMessageBegin('getFlatCollectionSchema', TMessageType.CALL, self._seqid)
        args = getFlatCollectionSchema_args()
        args.auth = auth
        args.collectionId = collectionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFlatCollectionSchema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFlatCollectionSchema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFlatCollectionSchema failed: unknown result")

    def getDataSetAttributes(self, auth, dataSetId, detailLevel):
        """
        Parameters:
         - auth
         - dataSetId
         - detailLevel

        """
        self.send_getDataSetAttributes(auth, dataSetId, detailLevel)
        return self.recv_getDataSetAttributes()

    def send_getDataSetAttributes(self, auth, dataSetId, detailLevel):
        self._oprot.writeMessageBegin('getDataSetAttributes', TMessageType.CALL, self._seqid)
        args = getDataSetAttributes_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.detailLevel = detailLevel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataSetAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataSetAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetAttributes failed: unknown result")

    def getDataSetAttributeNames(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_getDataSetAttributeNames(auth, dataSetId)
        return self.recv_getDataSetAttributeNames()

    def send_getDataSetAttributeNames(self, auth, dataSetId):
        self._oprot.writeMessageBegin('getDataSetAttributeNames', TMessageType.CALL, self._seqid)
        args = getDataSetAttributeNames_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataSetAttributeNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataSetAttributeNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetAttributeNames failed: unknown result")

    def createLabel(self, auth, name):
        """
        Parameters:
         - auth
         - name

        """
        self.send_createLabel(auth, name)
        return self.recv_createLabel()

    def send_createLabel(self, auth, name):
        self._oprot.writeMessageBegin('createLabel', TMessageType.CALL, self._seqid)
        args = createLabel_args()
        args.auth = auth
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createLabel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createLabel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createLabel failed: unknown result")

    def getLabels(self, auth):
        """
        Parameters:
         - auth

        """
        self.send_getLabels(auth)
        return self.recv_getLabels()

    def send_getLabels(self, auth):
        self._oprot.writeMessageBegin('getLabels', TMessageType.CALL, self._seqid)
        args = getLabels_args()
        args.auth = auth
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabels failed: unknown result")

    def getLabel(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        self.send_getLabel(auth, labelId)
        return self.recv_getLabel()

    def send_getLabel(self, auth, labelId):
        self._oprot.writeMessageBegin('getLabel', TMessageType.CALL, self._seqid)
        args = getLabel_args()
        args.auth = auth
        args.labelId = labelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLabel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLabel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabel failed: unknown result")

    def deleteLabel(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        self.send_deleteLabel(auth, labelId)
        self.recv_deleteLabel()

    def send_deleteLabel(self, auth, labelId):
        self._oprot.writeMessageBegin('deleteLabel', TMessageType.CALL, self._seqid)
        args = deleteLabel_args()
        args.auth = auth
        args.labelId = labelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteLabel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteLabel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return

    def updateLabel(self, auth, label):
        """
        Parameters:
         - auth
         - label

        """
        self.send_updateLabel(auth, label)
        return self.recv_updateLabel()

    def send_updateLabel(self, auth, label):
        self._oprot.writeMessageBegin('updateLabel', TMessageType.CALL, self._seqid)
        args = updateLabel_args()
        args.auth = auth
        args.label = label
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateLabel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateLabel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLabel failed: unknown result")

    def createLabelAssignment(self, auth, labelId, dataSetId):
        """
        Parameters:
         - auth
         - labelId
         - dataSetId

        """
        self.send_createLabelAssignment(auth, labelId, dataSetId)
        return self.recv_createLabelAssignment()

    def send_createLabelAssignment(self, auth, labelId, dataSetId):
        self._oprot.writeMessageBegin('createLabelAssignment', TMessageType.CALL, self._seqid)
        args = createLabelAssignment_args()
        args.auth = auth
        args.labelId = labelId
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createLabelAssignment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createLabelAssignment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createLabelAssignment failed: unknown result")

    def getLabelAssignments(self, auth):
        """
        Parameters:
         - auth

        """
        self.send_getLabelAssignments(auth)
        return self.recv_getLabelAssignments()

    def send_getLabelAssignments(self, auth):
        self._oprot.writeMessageBegin('getLabelAssignments', TMessageType.CALL, self._seqid)
        args = getLabelAssignments_args()
        args.auth = auth
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLabelAssignments(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLabelAssignments_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabelAssignments failed: unknown result")

    def getLabelAssigmentById(self, auth, labelAssignmentId):
        """
        Parameters:
         - auth
         - labelAssignmentId

        """
        self.send_getLabelAssigmentById(auth, labelAssignmentId)
        return self.recv_getLabelAssigmentById()

    def send_getLabelAssigmentById(self, auth, labelAssignmentId):
        self._oprot.writeMessageBegin('getLabelAssigmentById', TMessageType.CALL, self._seqid)
        args = getLabelAssigmentById_args()
        args.auth = auth
        args.labelAssignmentId = labelAssignmentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLabelAssigmentById(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLabelAssigmentById_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabelAssigmentById failed: unknown result")

    def deleteLabelAssignment(self, auth, labelId):
        """
        Parameters:
         - auth
         - labelId

        """
        self.send_deleteLabelAssignment(auth, labelId)
        self.recv_deleteLabelAssignment()

    def send_deleteLabelAssignment(self, auth, labelId):
        self._oprot.writeMessageBegin('deleteLabelAssignment', TMessageType.CALL, self._seqid)
        args = deleteLabelAssignment_args()
        args.auth = auth
        args.labelId = labelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteLabelAssignment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteLabelAssignment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return

    def getDataSetPermissions(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_getDataSetPermissions(auth, dataSetId)
        return self.recv_getDataSetPermissions()

    def send_getDataSetPermissions(self, auth, dataSetId):
        self._oprot.writeMessageBegin('getDataSetPermissions', TMessageType.CALL, self._seqid)
        args = getDataSetPermissions_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataSetPermissions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataSetPermissions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetPermissions failed: unknown result")

    def createDataSetPermission(self, auth, permission):
        """
        Parameters:
         - auth
         - permission

        """
        self.send_createDataSetPermission(auth, permission)
        return self.recv_createDataSetPermission()

    def send_createDataSetPermission(self, auth, permission):
        self._oprot.writeMessageBegin('createDataSetPermission', TMessageType.CALL, self._seqid)
        args = createDataSetPermission_args()
        args.auth = auth
        args.permission = permission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createDataSetPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createDataSetPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createDataSetPermission failed: unknown result")

    def updateDataSetPermission(self, auth, permission):
        """
        Parameters:
         - auth
         - permission

        """
        self.send_updateDataSetPermission(auth, permission)
        return self.recv_updateDataSetPermission()

    def send_updateDataSetPermission(self, auth, permission):
        self._oprot.writeMessageBegin('updateDataSetPermission', TMessageType.CALL, self._seqid)
        args = updateDataSetPermission_args()
        args.auth = auth
        args.permission = permission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateDataSetPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateDataSetPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDataSetPermission failed: unknown result")

    def deleteDataSetPermission(self, auth, permissionId):
        """
        Parameters:
         - auth
         - permissionId

        """
        self.send_deleteDataSetPermission(auth, permissionId)
        self.recv_deleteDataSetPermission()

    def send_deleteDataSetPermission(self, auth, permissionId):
        self._oprot.writeMessageBegin('deleteDataSetPermission', TMessageType.CALL, self._seqid)
        args = deleteDataSetPermission_args()
        args.auth = auth
        args.permissionId = permissionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteDataSetPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteDataSetPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return

    def getIndexingPolicy(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_getIndexingPolicy(auth, dataSetId)
        return self.recv_getIndexingPolicy()

    def send_getIndexingPolicy(self, auth, dataSetId):
        self._oprot.writeMessageBegin('getIndexingPolicy', TMessageType.CALL, self._seqid)
        args = getIndexingPolicy_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getIndexingPolicy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getIndexingPolicy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getIndexingPolicy failed: unknown result")

    def updateIndexingPolicy(self, auth, indexingPolicy):
        """
        Parameters:
         - auth
         - indexingPolicy

        """
        self.send_updateIndexingPolicy(auth, indexingPolicy)
        return self.recv_updateIndexingPolicy()

    def send_updateIndexingPolicy(self, auth, indexingPolicy):
        self._oprot.writeMessageBegin('updateIndexingPolicy', TMessageType.CALL, self._seqid)
        args = updateIndexingPolicy_args()
        args.auth = auth
        args.indexingPolicy = indexingPolicy
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateIndexingPolicy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateIndexingPolicy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateIndexingPolicy failed: unknown result")

    def updateMaskedAttributes(self, auth, attributes):
        """
        Parameters:
         - auth
         - attributes

        """
        self.send_updateMaskedAttributes(auth, attributes)
        return self.recv_updateMaskedAttributes()

    def send_updateMaskedAttributes(self, auth, attributes):
        self._oprot.writeMessageBegin('updateMaskedAttributes', TMessageType.CALL, self._seqid)
        args = updateMaskedAttributes_args()
        args.auth = auth
        args.attributes = attributes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateMaskedAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateMaskedAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateMaskedAttributes failed: unknown result")

    def getFieldMaskerDescriptions(self):
        self.send_getFieldMaskerDescriptions()
        return self.recv_getFieldMaskerDescriptions()

    def send_getFieldMaskerDescriptions(self):
        self._oprot.writeMessageBegin('getFieldMaskerDescriptions', TMessageType.CALL, self._seqid)
        args = getFieldMaskerDescriptions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFieldMaskerDescriptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFieldMaskerDescriptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFieldMaskerDescriptions failed: unknown result")

    def registerTable(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_registerTable(auth, dataSetId)
        self.recv_registerTable()

    def send_registerTable(self, auth, dataSetId):
        self._oprot.writeMessageBegin('registerTable', TMessageType.CALL, self._seqid)
        args = registerTable_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_registerTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = registerTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def unregisterTable(self, auth, dataSetId):
        """
        Parameters:
         - auth
         - dataSetId

        """
        self.send_unregisterTable(auth, dataSetId)
        self.recv_unregisterTable()

    def send_unregisterTable(self, auth, dataSetId):
        self._oprot.writeMessageBegin('unregisterTable', TMessageType.CALL, self._seqid)
        args = unregisterTable_args()
        args.auth = auth
        args.dataSetId = dataSetId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unregisterTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unregisterTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        return

    def writeRecord(self, auth, record):
        """
        Parameters:
         - auth
         - record

        """
        self.send_writeRecord(auth, record)
        return self.recv_writeRecord()

    def send_writeRecord(self, auth, record):
        self._oprot.writeMessageBegin('writeRecord', TMessageType.CALL, self._seqid)
        args = writeRecord_args()
        args.auth = auth
        args.record = record
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_writeRecord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = writeRecord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "writeRecord failed: unknown result")

    def writeRecords(self, auth, records):
        """
        Parameters:
         - auth
         - records

        """
        self.send_writeRecords(auth, records)
        return self.recv_writeRecords()

    def send_writeRecords(self, auth, records):
        self._oprot.writeMessageBegin('writeRecords', TMessageType.CALL, self._seqid)
        args = writeRecords_args()
        args.auth = auth
        args.records = records
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_writeRecords(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = writeRecords_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "writeRecords failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getCollectionById"] = Processor.process_getCollectionById
        self._processMap["getCollectionByIdNotDeleted"] = Processor.process_getCollectionByIdNotDeleted
        self._processMap["getCollectionByName"] = Processor.process_getCollectionByName
        self._processMap["listCollections"] = Processor.process_listCollections
        self._processMap["createCollection"] = Processor.process_createCollection
        self._processMap["updateCollection"] = Processor.process_updateCollection
        self._processMap["deleteCollection"] = Processor.process_deleteCollection
        self._processMap["clearCollection"] = Processor.process_clearCollection
        self._processMap["repair"] = Processor.process_repair
        self._processMap["getCollectionSample"] = Processor.process_getCollectionSample
        self._processMap["getAllRecords"] = Processor.process_getAllRecords
        self._processMap["startDownloadRecords"] = Processor.process_startDownloadRecords
        self._processMap["downloadMoreRecords"] = Processor.process_downloadMoreRecords
        self._processMap["stopDownloadRecords"] = Processor.process_stopDownloadRecords
        self._processMap["startDownloadSamples"] = Processor.process_startDownloadSamples
        self._processMap["downloadMoreSamples"] = Processor.process_downloadMoreSamples
        self._processMap["stopDownloadSamples"] = Processor.process_stopDownloadSamples
        self._processMap["getSqlSchema"] = Processor.process_getSqlSchema
        self._processMap["getAllSqlRecords"] = Processor.process_getAllSqlRecords
        self._processMap["getSparkRDDConf"] = Processor.process_getSparkRDDConf
        self._processMap["getNewSparkJobOutputPath"] = Processor.process_getNewSparkJobOutputPath
        self._processMap["addSparkFilesToCollection"] = Processor.process_addSparkFilesToCollection
        self._processMap["cleanupSparkImportDir"] = Processor.process_cleanupSparkImportDir
        self._processMap["getCollectionSchema"] = Processor.process_getCollectionSchema
        self._processMap["getFlatCollectionSchema"] = Processor.process_getFlatCollectionSchema
        self._processMap["getDataSetAttributes"] = Processor.process_getDataSetAttributes
        self._processMap["getDataSetAttributeNames"] = Processor.process_getDataSetAttributeNames
        self._processMap["createLabel"] = Processor.process_createLabel
        self._processMap["getLabels"] = Processor.process_getLabels
        self._processMap["getLabel"] = Processor.process_getLabel
        self._processMap["deleteLabel"] = Processor.process_deleteLabel
        self._processMap["updateLabel"] = Processor.process_updateLabel
        self._processMap["createLabelAssignment"] = Processor.process_createLabelAssignment
        self._processMap["getLabelAssignments"] = Processor.process_getLabelAssignments
        self._processMap["getLabelAssigmentById"] = Processor.process_getLabelAssigmentById
        self._processMap["deleteLabelAssignment"] = Processor.process_deleteLabelAssignment
        self._processMap["getDataSetPermissions"] = Processor.process_getDataSetPermissions
        self._processMap["createDataSetPermission"] = Processor.process_createDataSetPermission
        self._processMap["updateDataSetPermission"] = Processor.process_updateDataSetPermission
        self._processMap["deleteDataSetPermission"] = Processor.process_deleteDataSetPermission
        self._processMap["getIndexingPolicy"] = Processor.process_getIndexingPolicy
        self._processMap["updateIndexingPolicy"] = Processor.process_updateIndexingPolicy
        self._processMap["updateMaskedAttributes"] = Processor.process_updateMaskedAttributes
        self._processMap["getFieldMaskerDescriptions"] = Processor.process_getFieldMaskerDescriptions
        self._processMap["registerTable"] = Processor.process_registerTable
        self._processMap["unregisterTable"] = Processor.process_unregisterTable
        self._processMap["writeRecord"] = Processor.process_writeRecord
        self._processMap["writeRecords"] = Processor.process_writeRecords
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getCollectionById(self, seqid, iprot, oprot):
        args = getCollectionById_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCollectionById_result()
        try:
            result.success = self._handler.getCollectionById(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TNotFoundException as nfe:
            msg_type = TMessageType.REPLY
            result.nfe = nfe
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCollectionById", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCollectionByIdNotDeleted(self, seqid, iprot, oprot):
        args = getCollectionByIdNotDeleted_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCollectionByIdNotDeleted_result()
        try:
            result.success = self._handler.getCollectionByIdNotDeleted(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TNotFoundException as nfe:
            msg_type = TMessageType.REPLY
            result.nfe = nfe
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCollectionByIdNotDeleted", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCollectionByName(self, seqid, iprot, oprot):
        args = getCollectionByName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCollectionByName_result()
        try:
            result.success = self._handler.getCollectionByName(args.auth, args.collectionName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TNotFoundException as nfe:
            msg_type = TMessageType.REPLY
            result.nfe = nfe
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCollectionByName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listCollections(self, seqid, iprot, oprot):
        args = listCollections_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listCollections_result()
        try:
            result.success = self._handler.listCollections(args.auth, args.getRecordCounts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listCollections", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createCollection(self, seqid, iprot, oprot):
        args = createCollection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createCollection_result()
        try:
            result.success = self._handler.createCollection(args.auth, args.collection)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createCollection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateCollection(self, seqid, iprot, oprot):
        args = updateCollection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateCollection_result()
        try:
            result.success = self._handler.updateCollection(args.auth, args.collection)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateCollection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteCollection(self, seqid, iprot, oprot):
        args = deleteCollection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteCollection_result()
        try:
            result.success = self._handler.deleteCollection(args.auth, args.collection)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteCollection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearCollection(self, seqid, iprot, oprot):
        args = clearCollection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearCollection_result()
        try:
            self._handler.clearCollection(args.auth, args.collectionId, args.removeFieldNamesSeen)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearCollection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_repair(self, seqid, iprot, oprot):
        args = repair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = repair_result()
        try:
            self._handler.repair(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("repair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCollectionSample(self, seqid, iprot, oprot):
        args = getCollectionSample_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCollectionSample_result()
        try:
            result.success = self._handler.getCollectionSample(args.auth, args.collectionId, args.maxRecords, args.removeByteArrayFieldValues, args.maxStringValueLength)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCollectionSample", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllRecords(self, seqid, iprot, oprot):
        args = getAllRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllRecords_result()
        try:
            result.success = self._handler.getAllRecords(args.auth, args.collectionId, args.maxRecords)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startDownloadRecords(self, seqid, iprot, oprot):
        args = startDownloadRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startDownloadRecords_result()
        try:
            result.success = self._handler.startDownloadRecords(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startDownloadRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_downloadMoreRecords(self, seqid, iprot, oprot):
        args = downloadMoreRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = downloadMoreRecords_result()
        try:
            result.success = self._handler.downloadMoreRecords(args.auth, args.downloadId, args.maxToReturn)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("downloadMoreRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopDownloadRecords(self, seqid, iprot, oprot):
        args = stopDownloadRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopDownloadRecords_result()
        try:
            self._handler.stopDownloadRecords(args.auth, args.downloadId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopDownloadRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startDownloadSamples(self, seqid, iprot, oprot):
        args = startDownloadSamples_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startDownloadSamples_result()
        try:
            result.success = self._handler.startDownloadSamples(args.auth, args.collectionId, args.removeByteArrayFieldValues)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startDownloadSamples", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_downloadMoreSamples(self, seqid, iprot, oprot):
        args = downloadMoreSamples_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = downloadMoreSamples_result()
        try:
            result.success = self._handler.downloadMoreSamples(args.auth, args.downloadId, args.maxToReturn)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("downloadMoreSamples", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stopDownloadSamples(self, seqid, iprot, oprot):
        args = stopDownloadSamples_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stopDownloadSamples_result()
        try:
            self._handler.stopDownloadSamples(args.auth, args.downloadId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stopDownloadSamples", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSqlSchema(self, seqid, iprot, oprot):
        args = getSqlSchema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSqlSchema_result()
        try:
            result.success = self._handler.getSqlSchema(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSqlSchema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllSqlRecords(self, seqid, iprot, oprot):
        args = getAllSqlRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllSqlRecords_result()
        try:
            result.success = self._handler.getAllSqlRecords(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllSqlRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSparkRDDConf(self, seqid, iprot, oprot):
        args = getSparkRDDConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSparkRDDConf_result()
        try:
            result.success = self._handler.getSparkRDDConf(args.auth, args.collectionName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSparkRDDConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNewSparkJobOutputPath(self, seqid, iprot, oprot):
        args = getNewSparkJobOutputPath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNewSparkJobOutputPath_result()
        try:
            result.success = self._handler.getNewSparkJobOutputPath(args.auth)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNewSparkJobOutputPath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addSparkFilesToCollection(self, seqid, iprot, oprot):
        args = addSparkFilesToCollection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addSparkFilesToCollection_result()
        try:
            self._handler.addSparkFilesToCollection(args.auth, args.collectionName, args.path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addSparkFilesToCollection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cleanupSparkImportDir(self, seqid, iprot, oprot):
        args = cleanupSparkImportDir_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cleanupSparkImportDir_result()
        try:
            self._handler.cleanupSparkImportDir(args.auth, args.importId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cleanupSparkImportDir", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCollectionSchema(self, seqid, iprot, oprot):
        args = getCollectionSchema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCollectionSchema_result()
        try:
            result.success = self._handler.getCollectionSchema(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCollectionSchema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFlatCollectionSchema(self, seqid, iprot, oprot):
        args = getFlatCollectionSchema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFlatCollectionSchema_result()
        try:
            result.success = self._handler.getFlatCollectionSchema(args.auth, args.collectionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFlatCollectionSchema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataSetAttributes(self, seqid, iprot, oprot):
        args = getDataSetAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataSetAttributes_result()
        try:
            result.success = self._handler.getDataSetAttributes(args.auth, args.dataSetId, args.detailLevel)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataSetAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataSetAttributeNames(self, seqid, iprot, oprot):
        args = getDataSetAttributeNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataSetAttributeNames_result()
        try:
            result.success = self._handler.getDataSetAttributeNames(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataSetAttributeNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createLabel(self, seqid, iprot, oprot):
        args = createLabel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createLabel_result()
        try:
            result.success = self._handler.createLabel(args.auth, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createLabel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLabels(self, seqid, iprot, oprot):
        args = getLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLabels_result()
        try:
            result.success = self._handler.getLabels(args.auth)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLabel(self, seqid, iprot, oprot):
        args = getLabel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLabel_result()
        try:
            result.success = self._handler.getLabel(args.auth, args.labelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLabel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteLabel(self, seqid, iprot, oprot):
        args = deleteLabel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteLabel_result()
        try:
            self._handler.deleteLabel(args.auth, args.labelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteLabel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateLabel(self, seqid, iprot, oprot):
        args = updateLabel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateLabel_result()
        try:
            result.success = self._handler.updateLabel(args.auth, args.label)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateLabel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createLabelAssignment(self, seqid, iprot, oprot):
        args = createLabelAssignment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createLabelAssignment_result()
        try:
            result.success = self._handler.createLabelAssignment(args.auth, args.labelId, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createLabelAssignment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLabelAssignments(self, seqid, iprot, oprot):
        args = getLabelAssignments_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLabelAssignments_result()
        try:
            result.success = self._handler.getLabelAssignments(args.auth)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLabelAssignments", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLabelAssigmentById(self, seqid, iprot, oprot):
        args = getLabelAssigmentById_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLabelAssigmentById_result()
        try:
            result.success = self._handler.getLabelAssigmentById(args.auth, args.labelAssignmentId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLabelAssigmentById", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteLabelAssignment(self, seqid, iprot, oprot):
        args = deleteLabelAssignment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteLabelAssignment_result()
        try:
            self._handler.deleteLabelAssignment(args.auth, args.labelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteLabelAssignment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataSetPermissions(self, seqid, iprot, oprot):
        args = getDataSetPermissions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataSetPermissions_result()
        try:
            result.success = self._handler.getDataSetPermissions(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataSetPermissions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createDataSetPermission(self, seqid, iprot, oprot):
        args = createDataSetPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createDataSetPermission_result()
        try:
            result.success = self._handler.createDataSetPermission(args.auth, args.permission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createDataSetPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateDataSetPermission(self, seqid, iprot, oprot):
        args = updateDataSetPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateDataSetPermission_result()
        try:
            result.success = self._handler.updateDataSetPermission(args.auth, args.permission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateDataSetPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteDataSetPermission(self, seqid, iprot, oprot):
        args = deleteDataSetPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteDataSetPermission_result()
        try:
            self._handler.deleteDataSetPermission(args.auth, args.permissionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteDataSetPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getIndexingPolicy(self, seqid, iprot, oprot):
        args = getIndexingPolicy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getIndexingPolicy_result()
        try:
            result.success = self._handler.getIndexingPolicy(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getIndexingPolicy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateIndexingPolicy(self, seqid, iprot, oprot):
        args = updateIndexingPolicy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateIndexingPolicy_result()
        try:
            result.success = self._handler.updateIndexingPolicy(args.auth, args.indexingPolicy)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateIndexingPolicy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateMaskedAttributes(self, seqid, iprot, oprot):
        args = updateMaskedAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateMaskedAttributes_result()
        try:
            result.success = self._handler.updateMaskedAttributes(args.auth, args.attributes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateMaskedAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFieldMaskerDescriptions(self, seqid, iprot, oprot):
        args = getFieldMaskerDescriptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFieldMaskerDescriptions_result()
        try:
            result.success = self._handler.getFieldMaskerDescriptions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFieldMaskerDescriptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_registerTable(self, seqid, iprot, oprot):
        args = registerTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerTable_result()
        try:
            self._handler.registerTable(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("registerTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unregisterTable(self, seqid, iprot, oprot):
        args = unregisterTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unregisterTable_result()
        try:
            self._handler.unregisterTable(args.auth, args.dataSetId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unregisterTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_writeRecord(self, seqid, iprot, oprot):
        args = writeRecord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = writeRecord_result()
        try:
            result.success = self._handler.writeRecord(args.auth, args.record)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("writeRecord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_writeRecords(self, seqid, iprot, oprot):
        args = writeRecords_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = writeRecords_result()
        try:
            result.success = self._handler.writeRecords(args.auth, args.records)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("writeRecords", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getCollectionById_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionById_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionById_args)
getCollectionById_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class getCollectionById_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - nfe
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.nfe = nfe
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollection()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
                    self.nfe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionById_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.nfe is not None:
            oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
            self.nfe.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 4)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionById_result)
getCollectionById_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollection, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'nfe', [koverse.thriftgen.ttypes.TNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 4
)


class getCollectionByIdNotDeleted_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionByIdNotDeleted_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionByIdNotDeleted_args)
getCollectionByIdNotDeleted_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class getCollectionByIdNotDeleted_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - nfe
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.nfe = nfe
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollection()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
                    self.nfe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionByIdNotDeleted_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.nfe is not None:
            oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
            self.nfe.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 4)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionByIdNotDeleted_result)
getCollectionByIdNotDeleted_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollection, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'nfe', [koverse.thriftgen.ttypes.TNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 4
)


class getCollectionByName_args(object):
    """
    Attributes:
     - auth
     - collectionName

    """


    def __init__(self, auth=None, collectionName=None,):
        self.auth = auth
        self.collectionName = collectionName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionByName_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionName is not None:
            oprot.writeFieldBegin('collectionName', TType.STRING, 2)
            oprot.writeString(self.collectionName.encode('utf-8') if sys.version_info[0] == 2 else self.collectionName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionByName_args)
getCollectionByName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionName', 'UTF8', None, ),  # 2
)


class getCollectionByName_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - nfe
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.nfe = nfe
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollection()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
                    self.nfe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionByName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.nfe is not None:
            oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
            self.nfe.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 4)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionByName_result)
getCollectionByName_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollection, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'nfe', [koverse.thriftgen.ttypes.TNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 4
)


class listCollections_args(object):
    """
    Attributes:
     - auth
     - getRecordCounts

    """


    def __init__(self, auth=None, getRecordCounts=None,):
        self.auth = auth
        self.getRecordCounts = getRecordCounts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.getRecordCounts = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listCollections_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.getRecordCounts is not None:
            oprot.writeFieldBegin('getRecordCounts', TType.BOOL, 2)
            oprot.writeBool(self.getRecordCounts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listCollections_args)
listCollections_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.BOOL, 'getRecordCounts', None, None, ),  # 2
)


class listCollections_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = TCollection()
                        _elem260.read(iprot)
                        self.success.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listCollections_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter261 in self.success:
                iter261.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listCollections_result)
listCollections_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TCollection, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class createCollection_args(object):
    """
    Attributes:
     - auth
     - collection

    """


    def __init__(self, auth=None, collection=None,):
        self.auth = auth
        self.collection = collection

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.collection = TCollection()
                    self.collection.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCollection_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collection is not None:
            oprot.writeFieldBegin('collection', TType.STRUCT, 2)
            self.collection.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCollection_args)
createCollection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'collection', [TCollection, None], None, ),  # 2
)


class createCollection_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollection()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCollection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCollection_result)
createCollection_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollection, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class updateCollection_args(object):
    """
    Attributes:
     - auth
     - collection

    """


    def __init__(self, auth=None, collection=None,):
        self.auth = auth
        self.collection = collection

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.collection = TCollection()
                    self.collection.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCollection_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collection is not None:
            oprot.writeFieldBegin('collection', TType.STRUCT, 2)
            self.collection.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCollection_args)
updateCollection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'collection', [TCollection, None], None, ),  # 2
)


class updateCollection_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollection()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCollection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCollection_result)
updateCollection_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollection, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class deleteCollection_args(object):
    """
    Attributes:
     - auth
     - collection

    """


    def __init__(self, auth=None, collection=None,):
        self.auth = auth
        self.collection = collection

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.collection = TCollection()
                    self.collection.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteCollection_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collection is not None:
            oprot.writeFieldBegin('collection', TType.STRUCT, 2)
            self.collection.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteCollection_args)
deleteCollection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'collection', [TCollection, None], None, ),  # 2
)


class deleteCollection_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteCollection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteCollection_result)
deleteCollection_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class clearCollection_args(object):
    """
    Attributes:
     - auth
     - collectionId
     - removeFieldNamesSeen

    """


    def __init__(self, auth=None, collectionId=None, removeFieldNamesSeen=None,):
        self.auth = auth
        self.collectionId = collectionId
        self.removeFieldNamesSeen = removeFieldNamesSeen

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.removeFieldNamesSeen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearCollection_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        if self.removeFieldNamesSeen is not None:
            oprot.writeFieldBegin('removeFieldNamesSeen', TType.BOOL, 3)
            oprot.writeBool(self.removeFieldNamesSeen)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearCollection_args)
clearCollection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'removeFieldNamesSeen', None, None, ),  # 3
)


class clearCollection_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearCollection_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearCollection_result)
clearCollection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class repair_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('repair_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(repair_args)
repair_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class repair_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('repair_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(repair_result)
repair_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getCollectionSample_args(object):
    """
    Attributes:
     - auth
     - collectionId
     - maxRecords
     - removeByteArrayFieldValues
     - maxStringValueLength

    """


    def __init__(self, auth=None, collectionId=None, maxRecords=None, removeByteArrayFieldValues=None, maxStringValueLength=None,):
        self.auth = auth
        self.collectionId = collectionId
        self.maxRecords = maxRecords
        self.removeByteArrayFieldValues = removeByteArrayFieldValues
        self.maxStringValueLength = maxStringValueLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.maxRecords = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.removeByteArrayFieldValues = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.maxStringValueLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionSample_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        if self.maxRecords is not None:
            oprot.writeFieldBegin('maxRecords', TType.I32, 3)
            oprot.writeI32(self.maxRecords)
            oprot.writeFieldEnd()
        if self.removeByteArrayFieldValues is not None:
            oprot.writeFieldBegin('removeByteArrayFieldValues', TType.BOOL, 4)
            oprot.writeBool(self.removeByteArrayFieldValues)
            oprot.writeFieldEnd()
        if self.maxStringValueLength is not None:
            oprot.writeFieldBegin('maxStringValueLength', TType.I32, 5)
            oprot.writeI32(self.maxStringValueLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionSample_args)
getCollectionSample_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'maxRecords', None, None, ),  # 3
    (4, TType.BOOL, 'removeByteArrayFieldValues', None, None, ),  # 4
    (5, TType.I32, 'maxStringValueLength', None, None, ),  # 5
)


class getCollectionSample_result(object):
    """
    Attributes:
     - success
     - ae
     - ke
     - ce

    """


    def __init__(self, success=None, ae=None, ke=None, ce=None,):
        self.success = success
        self.ae = ae
        self.ke = ke
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype265, _size262) = iprot.readListBegin()
                    for _i266 in range(_size262):
                        _elem267 = koverse.thriftgen.ttypes.TSimpleRecord()
                        _elem267.read(iprot)
                        self.success.append(_elem267)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionSample_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter268 in self.success:
                iter268.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 2)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionSample_result)
getCollectionSample_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [koverse.thriftgen.ttypes.TSimpleRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 1
    (2, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getAllRecords_args(object):
    """
    Attributes:
     - auth
     - collectionId
     - maxRecords

    """


    def __init__(self, auth=None, collectionId=None, maxRecords=None,):
        self.auth = auth
        self.collectionId = collectionId
        self.maxRecords = maxRecords

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.maxRecords = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        if self.maxRecords is not None:
            oprot.writeFieldBegin('maxRecords', TType.I32, 3)
            oprot.writeI32(self.maxRecords)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRecords_args)
getAllRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'maxRecords', None, None, ),  # 3
)


class getAllRecords_result(object):
    """
    Attributes:
     - success
     - ae
     - ke
     - ce

    """


    def __init__(self, success=None, ae=None, ke=None, ce=None,):
        self.success = success
        self.ae = ae
        self.ke = ke
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype272, _size269) = iprot.readListBegin()
                    for _i273 in range(_size269):
                        _elem274 = koverse.thriftgen.ttypes.TSimpleRecord()
                        _elem274.read(iprot)
                        self.success.append(_elem274)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter275 in self.success:
                iter275.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 2)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRecords_result)
getAllRecords_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [koverse.thriftgen.ttypes.TSimpleRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 1
    (2, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class startDownloadRecords_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startDownloadRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startDownloadRecords_args)
startDownloadRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class startDownloadRecords_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startDownloadRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startDownloadRecords_result)
startDownloadRecords_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class downloadMoreRecords_args(object):
    """
    Attributes:
     - auth
     - downloadId
     - maxToReturn

    """


    def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
        self.auth = auth
        self.downloadId = downloadId
        self.maxToReturn = maxToReturn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.downloadId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.maxToReturn = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('downloadMoreRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.downloadId is not None:
            oprot.writeFieldBegin('downloadId', TType.STRING, 2)
            oprot.writeString(self.downloadId.encode('utf-8') if sys.version_info[0] == 2 else self.downloadId)
            oprot.writeFieldEnd()
        if self.maxToReturn is not None:
            oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
            oprot.writeI16(self.maxToReturn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(downloadMoreRecords_args)
downloadMoreRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'downloadId', 'UTF8', None, ),  # 2
    (3, TType.I16, 'maxToReturn', None, None, ),  # 3
)


class downloadMoreRecords_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TDownloadRecords()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('downloadMoreRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(downloadMoreRecords_result)
downloadMoreRecords_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TDownloadRecords, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class stopDownloadRecords_args(object):
    """
    Attributes:
     - auth
     - downloadId

    """


    def __init__(self, auth=None, downloadId=None,):
        self.auth = auth
        self.downloadId = downloadId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.downloadId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopDownloadRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.downloadId is not None:
            oprot.writeFieldBegin('downloadId', TType.STRING, 2)
            oprot.writeString(self.downloadId.encode('utf-8') if sys.version_info[0] == 2 else self.downloadId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopDownloadRecords_args)
stopDownloadRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'downloadId', 'UTF8', None, ),  # 2
)


class stopDownloadRecords_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopDownloadRecords_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopDownloadRecords_result)
stopDownloadRecords_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class startDownloadSamples_args(object):
    """
    Attributes:
     - auth
     - collectionId
     - removeByteArrayFieldValues

    """


    def __init__(self, auth=None, collectionId=None, removeByteArrayFieldValues=None,):
        self.auth = auth
        self.collectionId = collectionId
        self.removeByteArrayFieldValues = removeByteArrayFieldValues

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.removeByteArrayFieldValues = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startDownloadSamples_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        if self.removeByteArrayFieldValues is not None:
            oprot.writeFieldBegin('removeByteArrayFieldValues', TType.BOOL, 3)
            oprot.writeBool(self.removeByteArrayFieldValues)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startDownloadSamples_args)
startDownloadSamples_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'removeByteArrayFieldValues', None, None, ),  # 3
)


class startDownloadSamples_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startDownloadSamples_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startDownloadSamples_result)
startDownloadSamples_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class downloadMoreSamples_args(object):
    """
    Attributes:
     - auth
     - downloadId
     - maxToReturn

    """


    def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
        self.auth = auth
        self.downloadId = downloadId
        self.maxToReturn = maxToReturn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.downloadId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.maxToReturn = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('downloadMoreSamples_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.downloadId is not None:
            oprot.writeFieldBegin('downloadId', TType.STRING, 2)
            oprot.writeString(self.downloadId.encode('utf-8') if sys.version_info[0] == 2 else self.downloadId)
            oprot.writeFieldEnd()
        if self.maxToReturn is not None:
            oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
            oprot.writeI16(self.maxToReturn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(downloadMoreSamples_args)
downloadMoreSamples_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'downloadId', 'UTF8', None, ),  # 2
    (3, TType.I16, 'maxToReturn', None, None, ),  # 3
)


class downloadMoreSamples_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TDownloadRecords()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('downloadMoreSamples_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(downloadMoreSamples_result)
downloadMoreSamples_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TDownloadRecords, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class stopDownloadSamples_args(object):
    """
    Attributes:
     - auth
     - downloadId

    """


    def __init__(self, auth=None, downloadId=None,):
        self.auth = auth
        self.downloadId = downloadId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.downloadId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopDownloadSamples_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.downloadId is not None:
            oprot.writeFieldBegin('downloadId', TType.STRING, 2)
            oprot.writeString(self.downloadId.encode('utf-8') if sys.version_info[0] == 2 else self.downloadId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopDownloadSamples_args)
stopDownloadSamples_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'downloadId', 'UTF8', None, ),  # 2
)


class stopDownloadSamples_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stopDownloadSamples_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stopDownloadSamples_result)
stopDownloadSamples_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getSqlSchema_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSqlSchema_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSqlSchema_args)
getSqlSchema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class getSqlSchema_result(object):
    """
    Attributes:
     - success
     - ae
     - ke
     - ce

    """


    def __init__(self, success=None, ae=None, ke=None, ce=None,):
        self.success = success
        self.ae = ae
        self.ke = ke
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.queryservice.ttypes.TSqlSchema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSqlSchema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 2)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSqlSchema_result)
getSqlSchema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.queryservice.ttypes.TSqlSchema, None], None, ),  # 0
    (1, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 1
    (2, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getAllSqlRecords_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllSqlRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllSqlRecords_args)
getAllSqlRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class getAllSqlRecords_result(object):
    """
    Attributes:
     - success
     - ae
     - ke
     - ce

    """


    def __init__(self, success=None, ae=None, ke=None, ce=None,):
        self.success = success
        self.ae = ae
        self.ke = ke
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = koverse.thriftgen.queryservice.ttypes.TSqlTableRow()
                        _elem281.read(iprot)
                        self.success.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllSqlRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter282 in self.success:
                iter282.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 2)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllSqlRecords_result)
getAllSqlRecords_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [koverse.thriftgen.queryservice.ttypes.TSqlTableRow, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 1
    (2, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getSparkRDDConf_args(object):
    """
    Attributes:
     - auth
     - collectionName

    """


    def __init__(self, auth=None, collectionName=None,):
        self.auth = auth
        self.collectionName = collectionName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSparkRDDConf_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionName is not None:
            oprot.writeFieldBegin('collectionName', TType.STRING, 2)
            oprot.writeString(self.collectionName.encode('utf-8') if sys.version_info[0] == 2 else self.collectionName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSparkRDDConf_args)
getSparkRDDConf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionName', 'UTF8', None, ),  # 2
)


class getSparkRDDConf_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype284, _vtype285, _size283) = iprot.readMapBegin()
                    for _i287 in range(_size283):
                        _key288 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val289 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key288] = _val289
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSparkRDDConf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter290, viter291 in self.success.items():
                oprot.writeString(kiter290.encode('utf-8') if sys.version_info[0] == 2 else kiter290)
                oprot.writeString(viter291.encode('utf-8') if sys.version_info[0] == 2 else viter291)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSparkRDDConf_result)
getSparkRDDConf_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getNewSparkJobOutputPath_args(object):
    """
    Attributes:
     - auth

    """


    def __init__(self, auth=None,):
        self.auth = auth

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNewSparkJobOutputPath_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNewSparkJobOutputPath_args)
getNewSparkJobOutputPath_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
)


class getNewSparkJobOutputPath_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNewSparkJobOutputPath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNewSparkJobOutputPath_result)
getNewSparkJobOutputPath_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class addSparkFilesToCollection_args(object):
    """
    Attributes:
     - auth
     - collectionName
     - path

    """


    def __init__(self, auth=None, collectionName=None, path=None,):
        self.auth = auth
        self.collectionName = collectionName
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSparkFilesToCollection_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionName is not None:
            oprot.writeFieldBegin('collectionName', TType.STRING, 2)
            oprot.writeString(self.collectionName.encode('utf-8') if sys.version_info[0] == 2 else self.collectionName)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSparkFilesToCollection_args)
addSparkFilesToCollection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)


class addSparkFilesToCollection_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSparkFilesToCollection_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSparkFilesToCollection_result)
addSparkFilesToCollection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class cleanupSparkImportDir_args(object):
    """
    Attributes:
     - auth
     - importId

    """


    def __init__(self, auth=None, importId=None,):
        self.auth = auth
        self.importId = importId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.importId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cleanupSparkImportDir_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.importId is not None:
            oprot.writeFieldBegin('importId', TType.I32, 2)
            oprot.writeI32(self.importId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cleanupSparkImportDir_args)
cleanupSparkImportDir_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I32, 'importId', None, None, ),  # 2
)


class cleanupSparkImportDir_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cleanupSparkImportDir_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cleanupSparkImportDir_result)
cleanupSparkImportDir_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class getCollectionSchema_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionSchema_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionSchema_args)
getCollectionSchema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class getCollectionSchema_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollectionSchema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCollectionSchema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCollectionSchema_result)
getCollectionSchema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollectionSchema, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getFlatCollectionSchema_args(object):
    """
    Attributes:
     - auth
     - collectionId

    """


    def __init__(self, auth=None, collectionId=None,):
        self.auth = auth
        self.collectionId = collectionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFlatCollectionSchema_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionId is not None:
            oprot.writeFieldBegin('collectionId', TType.STRING, 2)
            oprot.writeString(self.collectionId.encode('utf-8') if sys.version_info[0] == 2 else self.collectionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFlatCollectionSchema_args)
getFlatCollectionSchema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionId', 'UTF8', None, ),  # 2
)


class getFlatCollectionSchema_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TFlatCollectionSchema()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFlatCollectionSchema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFlatCollectionSchema_result)
getFlatCollectionSchema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TFlatCollectionSchema, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getDataSetAttributes_args(object):
    """
    Attributes:
     - auth
     - dataSetId
     - detailLevel

    """


    def __init__(self, auth=None, dataSetId=None, detailLevel=None,):
        self.auth = auth
        self.dataSetId = dataSetId
        self.detailLevel = detailLevel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.detailLevel = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetAttributes_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        if self.detailLevel is not None:
            oprot.writeFieldBegin('detailLevel', TType.STRING, 3)
            oprot.writeString(self.detailLevel.encode('utf-8') if sys.version_info[0] == 2 else self.detailLevel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetAttributes_args)
getDataSetAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'detailLevel', 'UTF8', None, ),  # 3
)


class getDataSetAttributes_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype295, _size292) = iprot.readListBegin()
                    for _i296 in range(_size292):
                        _elem297 = TDataSetAttribute()
                        _elem297.read(iprot)
                        self.success.append(_elem297)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter298 in self.success:
                iter298.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetAttributes_result)
getDataSetAttributes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDataSetAttribute, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getDataSetAttributeNames_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetAttributeNames_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetAttributeNames_args)
getDataSetAttributeNames_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class getDataSetAttributeNames_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype302, _size299) = iprot.readListBegin()
                    for _i303 in range(_size299):
                        _elem304 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem304)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetAttributeNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter305 in self.success:
                oprot.writeString(iter305.encode('utf-8') if sys.version_info[0] == 2 else iter305)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetAttributeNames_result)
getDataSetAttributeNames_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class createLabel_args(object):
    """
    Attributes:
     - auth
     - name

    """


    def __init__(self, auth=None, name=None,):
        self.auth = auth
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLabel_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLabel_args)
createLabel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)


class createLabel_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TLabel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLabel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLabel_result)
createLabel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TLabel, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getLabels_args(object):
    """
    Attributes:
     - auth

    """


    def __init__(self, auth=None,):
        self.auth = auth

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabels_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabels_args)
getLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
)


class getLabels_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = koverse.thriftgen.ttypes.TLabel()
                        _elem311.read(iprot)
                        self.success.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter312 in self.success:
                iter312.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabels_result)
getLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [koverse.thriftgen.ttypes.TLabel, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getLabel_args(object):
    """
    Attributes:
     - auth
     - labelId

    """


    def __init__(self, auth=None, labelId=None,):
        self.auth = auth
        self.labelId = labelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.labelId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabel_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.labelId is not None:
            oprot.writeFieldBegin('labelId', TType.I64, 2)
            oprot.writeI64(self.labelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabel_args)
getLabel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'labelId', None, None, ),  # 2
)


class getLabel_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TLabel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabel_result)
getLabel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TLabel, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class deleteLabel_args(object):
    """
    Attributes:
     - auth
     - labelId

    """


    def __init__(self, auth=None, labelId=None,):
        self.auth = auth
        self.labelId = labelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.labelId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteLabel_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.labelId is not None:
            oprot.writeFieldBegin('labelId', TType.I64, 2)
            oprot.writeI64(self.labelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteLabel_args)
deleteLabel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'labelId', None, None, ),  # 2
)


class deleteLabel_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteLabel_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteLabel_result)
deleteLabel_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class updateLabel_args(object):
    """
    Attributes:
     - auth
     - label

    """


    def __init__(self, auth=None, label=None,):
        self.auth = auth
        self.label = label

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.label = koverse.thriftgen.ttypes.TLabel()
                    self.label.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateLabel_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRUCT, 2)
            self.label.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateLabel_args)
updateLabel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'label', [koverse.thriftgen.ttypes.TLabel, None], None, ),  # 2
)


class updateLabel_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TLabel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateLabel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateLabel_result)
updateLabel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TLabel, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class createLabelAssignment_args(object):
    """
    Attributes:
     - auth
     - labelId
     - dataSetId

    """


    def __init__(self, auth=None, labelId=None, dataSetId=None,):
        self.auth = auth
        self.labelId = labelId
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.labelId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLabelAssignment_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.labelId is not None:
            oprot.writeFieldBegin('labelId', TType.I64, 2)
            oprot.writeI64(self.labelId)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 3)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLabelAssignment_args)
createLabelAssignment_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'labelId', None, None, ),  # 2
    (3, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 3
)


class createLabelAssignment_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TLabelAssignment()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLabelAssignment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLabelAssignment_result)
createLabelAssignment_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TLabelAssignment, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getLabelAssignments_args(object):
    """
    Attributes:
     - auth

    """


    def __init__(self, auth=None,):
        self.auth = auth

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabelAssignments_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabelAssignments_args)
getLabelAssignments_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
)


class getLabelAssignments_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype316, _size313) = iprot.readListBegin()
                    for _i317 in range(_size313):
                        _elem318 = TLabelAssignment()
                        _elem318.read(iprot)
                        self.success.append(_elem318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabelAssignments_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter319 in self.success:
                iter319.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabelAssignments_result)
getLabelAssignments_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TLabelAssignment, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getLabelAssigmentById_args(object):
    """
    Attributes:
     - auth
     - labelAssignmentId

    """


    def __init__(self, auth=None, labelAssignmentId=None,):
        self.auth = auth
        self.labelAssignmentId = labelAssignmentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.labelAssignmentId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabelAssigmentById_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.labelAssignmentId is not None:
            oprot.writeFieldBegin('labelAssignmentId', TType.I64, 2)
            oprot.writeI64(self.labelAssignmentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabelAssigmentById_args)
getLabelAssigmentById_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'labelAssignmentId', None, None, ),  # 2
)


class getLabelAssigmentById_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TLabelAssignment()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLabelAssigmentById_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLabelAssigmentById_result)
getLabelAssigmentById_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TLabelAssignment, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class deleteLabelAssignment_args(object):
    """
    Attributes:
     - auth
     - labelId

    """


    def __init__(self, auth=None, labelId=None,):
        self.auth = auth
        self.labelId = labelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.labelId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteLabelAssignment_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.labelId is not None:
            oprot.writeFieldBegin('labelId', TType.I64, 2)
            oprot.writeI64(self.labelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteLabelAssignment_args)
deleteLabelAssignment_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'labelId', None, None, ),  # 2
)


class deleteLabelAssignment_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteLabelAssignment_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteLabelAssignment_result)
deleteLabelAssignment_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getDataSetPermissions_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetPermissions_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetPermissions_args)
getDataSetPermissions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class getDataSetPermissions_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype323, _size320) = iprot.readListBegin()
                    for _i324 in range(_size320):
                        _elem325 = TCollectionGroupPermission()
                        _elem325.read(iprot)
                        self.success.append(_elem325)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDataSetPermissions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter326 in self.success:
                iter326.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDataSetPermissions_result)
getDataSetPermissions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TCollectionGroupPermission, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class createDataSetPermission_args(object):
    """
    Attributes:
     - auth
     - permission

    """


    def __init__(self, auth=None, permission=None,):
        self.auth = auth
        self.permission = permission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.permission = TCollectionGroupPermission()
                    self.permission.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataSetPermission_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.STRUCT, 2)
            self.permission.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataSetPermission_args)
createDataSetPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'permission', [TCollectionGroupPermission, None], None, ),  # 2
)


class createDataSetPermission_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollectionGroupPermission()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDataSetPermission_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDataSetPermission_result)
createDataSetPermission_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollectionGroupPermission, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class updateDataSetPermission_args(object):
    """
    Attributes:
     - auth
     - permission

    """


    def __init__(self, auth=None, permission=None,):
        self.auth = auth
        self.permission = permission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.permission = TCollectionGroupPermission()
                    self.permission.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateDataSetPermission_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.permission is not None:
            oprot.writeFieldBegin('permission', TType.STRUCT, 2)
            self.permission.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateDataSetPermission_args)
updateDataSetPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'permission', [TCollectionGroupPermission, None], None, ),  # 2
)


class updateDataSetPermission_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TCollectionGroupPermission()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateDataSetPermission_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateDataSetPermission_result)
updateDataSetPermission_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TCollectionGroupPermission, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class deleteDataSetPermission_args(object):
    """
    Attributes:
     - auth
     - permissionId

    """


    def __init__(self, auth=None, permissionId=None,):
        self.auth = auth
        self.permissionId = permissionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.permissionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDataSetPermission_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.permissionId is not None:
            oprot.writeFieldBegin('permissionId', TType.I64, 2)
            oprot.writeI64(self.permissionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDataSetPermission_args)
deleteDataSetPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'permissionId', None, None, ),  # 2
)


class deleteDataSetPermission_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDataSetPermission_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDataSetPermission_result)
deleteDataSetPermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getIndexingPolicy_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIndexingPolicy_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIndexingPolicy_args)
getIndexingPolicy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class getIndexingPolicy_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIndexingPolicy()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIndexingPolicy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIndexingPolicy_result)
getIndexingPolicy_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIndexingPolicy, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class updateIndexingPolicy_args(object):
    """
    Attributes:
     - auth
     - indexingPolicy

    """


    def __init__(self, auth=None, indexingPolicy=None,):
        self.auth = auth
        self.indexingPolicy = indexingPolicy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.indexingPolicy = TIndexingPolicy()
                    self.indexingPolicy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateIndexingPolicy_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.indexingPolicy is not None:
            oprot.writeFieldBegin('indexingPolicy', TType.STRUCT, 2)
            self.indexingPolicy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateIndexingPolicy_args)
updateIndexingPolicy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'indexingPolicy', [TIndexingPolicy, None], None, ),  # 2
)


class updateIndexingPolicy_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIndexingPolicy()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateIndexingPolicy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateIndexingPolicy_result)
updateIndexingPolicy_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIndexingPolicy, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class updateMaskedAttributes_args(object):
    """
    Attributes:
     - auth
     - attributes

    """


    def __init__(self, auth=None, attributes=None,):
        self.auth = auth
        self.attributes = attributes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.attributes = TMaskedAttributes()
                    self.attributes.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateMaskedAttributes_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.STRUCT, 2)
            self.attributes.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateMaskedAttributes_args)
updateMaskedAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'attributes', [TMaskedAttributes, None], None, ),  # 2
)


class updateMaskedAttributes_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype330, _size327) = iprot.readListBegin()
                    for _i331 in range(_size327):
                        _elem332 = TDataSetAttribute()
                        _elem332.read(iprot)
                        self.success.append(_elem332)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateMaskedAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter333 in self.success:
                iter333.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateMaskedAttributes_result)
updateMaskedAttributes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TDataSetAttribute, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getFieldMaskerDescriptions_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFieldMaskerDescriptions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFieldMaskerDescriptions_args)
getFieldMaskerDescriptions_args.thrift_spec = (
)


class getFieldMaskerDescriptions_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype337, _size334) = iprot.readListBegin()
                    for _i338 in range(_size334):
                        _elem339 = TFieldMaskerDescription()
                        _elem339.read(iprot)
                        self.success.append(_elem339)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFieldMaskerDescriptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter340 in self.success:
                iter340.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFieldMaskerDescriptions_result)
getFieldMaskerDescriptions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TFieldMaskerDescription, None], False), None, ),  # 0
)


class registerTable_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerTable_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerTable_args)
registerTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class registerTable_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerTable_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerTable_result)
registerTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class unregisterTable_args(object):
    """
    Attributes:
     - auth
     - dataSetId

    """


    def __init__(self, auth=None, dataSetId=None,):
        self.auth = auth
        self.dataSetId = dataSetId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataSetId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unregisterTable_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.dataSetId is not None:
            oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
            oprot.writeString(self.dataSetId.encode('utf-8') if sys.version_info[0] == 2 else self.dataSetId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unregisterTable_args)
unregisterTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'dataSetId', 'UTF8', None, ),  # 2
)


class unregisterTable_result(object):
    """
    Attributes:
     - ke
     - ae
     - ce

    """


    def __init__(self, ke=None, ae=None, ce=None,):
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('unregisterTable_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(unregisterTable_result)
unregisterTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class writeRecord_args(object):
    """
    Attributes:
     - auth
     - record

    """


    def __init__(self, auth=None, record=None,):
        self.auth = auth
        self.record = record

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.record = koverse.thriftgen.ttypes.TSimpleRecord()
                    self.record.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeRecord_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.record is not None:
            oprot.writeFieldBegin('record', TType.STRUCT, 2)
            self.record.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeRecord_args)
writeRecord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'record', [koverse.thriftgen.ttypes.TSimpleRecord, None], None, ),  # 2
)


class writeRecord_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = koverse.thriftgen.ttypes.TSimpleRecord()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeRecord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeRecord_result)
writeRecord_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [koverse.thriftgen.ttypes.TSimpleRecord, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class writeRecords_args(object):
    """
    Attributes:
     - auth
     - records

    """


    def __init__(self, auth=None, records=None,):
        self.auth = auth
        self.records = records

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.records = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = koverse.thriftgen.ttypes.TSimpleRecord()
                        _elem346.read(iprot)
                        self.records.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeRecords_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.records is not None:
            oprot.writeFieldBegin('records', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.records))
            for iter347 in self.records:
                iter347.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeRecords_args)
writeRecords_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.LIST, 'records', (TType.STRUCT, [koverse.thriftgen.ttypes.TSimpleRecord, None], False), None, ),  # 2
)


class writeRecords_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = koverse.thriftgen.ttypes.TSimpleRecord()
                        _elem353.read(iprot)
                        self.success.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeRecords_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter354 in self.success:
                iter354.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeRecords_result)
writeRecords_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [koverse.thriftgen.ttypes.TSimpleRecord, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)
fix_spec(all_structs)
del all_structs

