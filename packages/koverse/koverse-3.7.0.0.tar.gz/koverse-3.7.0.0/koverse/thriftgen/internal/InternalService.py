#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def storeImportSample(self, auth, sample, importFlowId):
        """
        Parameters:
         - auth
         - sample
         - importFlowId

        """
        pass

    def updateImportState(self, auth, importFlowId, key, values, operator):
        """
        Parameters:
         - auth
         - importFlowId
         - key
         - values
         - operator

        """
        pass

    def getImportState(self, auth, importFlowId, key):
        """
        Parameters:
         - auth
         - importFlowId
         - key

        """
        pass

    def markPySparkTransformComplete(self, auth, collectionName, path, transformJobId):
        """
        Parameters:
         - auth
         - collectionName
         - path
         - transformJobId

        """
        pass

    def getTransformJobConfig(self, auth, transformJobId):
        """
        Parameters:
         - auth
         - transformJobId

        """
        pass

    def getNewSparkJobOutputPath(self, auth):
        """
        Parameters:
         - auth

        """
        pass

    def markTransformFailure(self, auth, jobId, errorMessage):
        """
        Parameters:
         - auth
         - jobId
         - errorMessage

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def storeImportSample(self, auth, sample, importFlowId):
        """
        Parameters:
         - auth
         - sample
         - importFlowId

        """
        self.send_storeImportSample(auth, sample, importFlowId)
        self.recv_storeImportSample()

    def send_storeImportSample(self, auth, sample, importFlowId):
        self._oprot.writeMessageBegin('storeImportSample', TMessageType.CALL, self._seqid)
        args = storeImportSample_args()
        args.auth = auth
        args.sample = sample
        args.importFlowId = importFlowId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeImportSample(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeImportSample_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def updateImportState(self, auth, importFlowId, key, values, operator):
        """
        Parameters:
         - auth
         - importFlowId
         - key
         - values
         - operator

        """
        self.send_updateImportState(auth, importFlowId, key, values, operator)
        self.recv_updateImportState()

    def send_updateImportState(self, auth, importFlowId, key, values, operator):
        self._oprot.writeMessageBegin('updateImportState', TMessageType.CALL, self._seqid)
        args = updateImportState_args()
        args.auth = auth
        args.importFlowId = importFlowId
        args.key = key
        args.values = values
        args.operator = operator
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateImportState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateImportState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return

    def getImportState(self, auth, importFlowId, key):
        """
        Parameters:
         - auth
         - importFlowId
         - key

        """
        self.send_getImportState(auth, importFlowId, key)
        return self.recv_getImportState()

    def send_getImportState(self, auth, importFlowId, key):
        self._oprot.writeMessageBegin('getImportState', TMessageType.CALL, self._seqid)
        args = getImportState_args()
        args.auth = auth
        args.importFlowId = importFlowId
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getImportState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getImportState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getImportState failed: unknown result")

    def markPySparkTransformComplete(self, auth, collectionName, path, transformJobId):
        """
        Parameters:
         - auth
         - collectionName
         - path
         - transformJobId

        """
        self.send_markPySparkTransformComplete(auth, collectionName, path, transformJobId)
        self.recv_markPySparkTransformComplete()

    def send_markPySparkTransformComplete(self, auth, collectionName, path, transformJobId):
        self._oprot.writeMessageBegin('markPySparkTransformComplete', TMessageType.CALL, self._seqid)
        args = markPySparkTransformComplete_args()
        args.auth = auth
        args.collectionName = collectionName
        args.path = path
        args.transformJobId = transformJobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markPySparkTransformComplete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markPySparkTransformComplete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return

    def getTransformJobConfig(self, auth, transformJobId):
        """
        Parameters:
         - auth
         - transformJobId

        """
        self.send_getTransformJobConfig(auth, transformJobId)
        return self.recv_getTransformJobConfig()

    def send_getTransformJobConfig(self, auth, transformJobId):
        self._oprot.writeMessageBegin('getTransformJobConfig', TMessageType.CALL, self._seqid)
        args = getTransformJobConfig_args()
        args.auth = auth
        args.transformJobId = transformJobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTransformJobConfig(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTransformJobConfig_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTransformJobConfig failed: unknown result")

    def getNewSparkJobOutputPath(self, auth):
        """
        Parameters:
         - auth

        """
        self.send_getNewSparkJobOutputPath(auth)
        return self.recv_getNewSparkJobOutputPath()

    def send_getNewSparkJobOutputPath(self, auth):
        self._oprot.writeMessageBegin('getNewSparkJobOutputPath', TMessageType.CALL, self._seqid)
        args = getNewSparkJobOutputPath_args()
        args.auth = auth
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNewSparkJobOutputPath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNewSparkJobOutputPath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        if result.ce is not None:
            raise result.ce
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNewSparkJobOutputPath failed: unknown result")

    def markTransformFailure(self, auth, jobId, errorMessage):
        """
        Parameters:
         - auth
         - jobId
         - errorMessage

        """
        self.send_markTransformFailure(auth, jobId, errorMessage)
        self.recv_markTransformFailure()

    def send_markTransformFailure(self, auth, jobId, errorMessage):
        self._oprot.writeMessageBegin('markTransformFailure', TMessageType.CALL, self._seqid)
        args = markTransformFailure_args()
        args.auth = auth
        args.jobId = jobId
        args.errorMessage = errorMessage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markTransformFailure(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markTransformFailure_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ke is not None:
            raise result.ke
        if result.ae is not None:
            raise result.ae
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["storeImportSample"] = Processor.process_storeImportSample
        self._processMap["updateImportState"] = Processor.process_updateImportState
        self._processMap["getImportState"] = Processor.process_getImportState
        self._processMap["markPySparkTransformComplete"] = Processor.process_markPySparkTransformComplete
        self._processMap["getTransformJobConfig"] = Processor.process_getTransformJobConfig
        self._processMap["getNewSparkJobOutputPath"] = Processor.process_getNewSparkJobOutputPath
        self._processMap["markTransformFailure"] = Processor.process_markTransformFailure
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_storeImportSample(self, seqid, iprot, oprot):
        args = storeImportSample_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeImportSample_result()
        try:
            self._handler.storeImportSample(args.auth, args.sample, args.importFlowId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeImportSample", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateImportState(self, seqid, iprot, oprot):
        args = updateImportState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateImportState_result()
        try:
            self._handler.updateImportState(args.auth, args.importFlowId, args.key, args.values, args.operator)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateImportState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getImportState(self, seqid, iprot, oprot):
        args = getImportState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getImportState_result()
        try:
            result.success = self._handler.getImportState(args.auth, args.importFlowId, args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getImportState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markPySparkTransformComplete(self, seqid, iprot, oprot):
        args = markPySparkTransformComplete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markPySparkTransformComplete_result()
        try:
            self._handler.markPySparkTransformComplete(args.auth, args.collectionName, args.path, args.transformJobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markPySparkTransformComplete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTransformJobConfig(self, seqid, iprot, oprot):
        args = getTransformJobConfig_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTransformJobConfig_result()
        try:
            result.success = self._handler.getTransformJobConfig(args.auth, args.transformJobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTransformJobConfig", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNewSparkJobOutputPath(self, seqid, iprot, oprot):
        args = getNewSparkJobOutputPath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNewSparkJobOutputPath_result()
        try:
            result.success = self._handler.getNewSparkJobOutputPath(args.auth)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNewSparkJobOutputPath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markTransformFailure(self, seqid, iprot, oprot):
        args = markTransformFailure_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markTransformFailure_result()
        try:
            self._handler.markTransformFailure(args.auth, args.jobId, args.errorMessage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except koverse.thriftgen.ttypes.TKoverseException as ke:
            msg_type = TMessageType.REPLY
            result.ke = ke
        except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
            msg_type = TMessageType.REPLY
            result.ae = ae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markTransformFailure", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class storeImportSample_args(object):
    """
    Attributes:
     - auth
     - sample
     - importFlowId

    """


    def __init__(self, auth=None, sample=None, importFlowId=None,):
        self.auth = auth
        self.sample = sample
        self.importFlowId = importFlowId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sample = koverse.thriftgen.dataflow.ttypes.TImportSample()
                    self.sample.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.importFlowId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeImportSample_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.sample is not None:
            oprot.writeFieldBegin('sample', TType.STRUCT, 2)
            self.sample.write(oprot)
            oprot.writeFieldEnd()
        if self.importFlowId is not None:
            oprot.writeFieldBegin('importFlowId', TType.I64, 3)
            oprot.writeI64(self.importFlowId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeImportSample_args)
storeImportSample_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'sample', [koverse.thriftgen.dataflow.ttypes.TImportSample, None], None, ),  # 2
    (3, TType.I64, 'importFlowId', None, None, ),  # 3
)


class storeImportSample_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('storeImportSample_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(storeImportSample_result)
storeImportSample_result.thrift_spec = (
)


class updateImportState_args(object):
    """
    Attributes:
     - auth
     - importFlowId
     - key
     - values
     - operator

    """


    def __init__(self, auth=None, importFlowId=None, key=None, values=None, operator=None,):
        self.auth = auth
        self.importFlowId = importFlowId
        self.key = key
        self.values = values
        self.operator = operator

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.importFlowId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.operator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateImportState_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.importFlowId is not None:
            oprot.writeFieldBegin('importFlowId', TType.I64, 2)
            oprot.writeI64(self.importFlowId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter69 in self.values:
                oprot.writeString(iter69.encode('utf-8') if sys.version_info[0] == 2 else iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operator is not None:
            oprot.writeFieldBegin('operator', TType.STRING, 5)
            oprot.writeString(self.operator.encode('utf-8') if sys.version_info[0] == 2 else self.operator)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateImportState_args)
updateImportState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'importFlowId', None, None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'operator', 'UTF8', None, ),  # 5
)


class updateImportState_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateImportState_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateImportState_result)
updateImportState_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getImportState_args(object):
    """
    Attributes:
     - auth
     - importFlowId
     - key

    """


    def __init__(self, auth=None, importFlowId=None, key=None,):
        self.auth = auth
        self.importFlowId = importFlowId
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.importFlowId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImportState_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.importFlowId is not None:
            oprot.writeFieldBegin('importFlowId', TType.I64, 2)
            oprot.writeI64(self.importFlowId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImportState_args)
getImportState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'importFlowId', None, None, ),  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
)


class getImportState_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getImportState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter76 in self.success:
                oprot.writeString(iter76.encode('utf-8') if sys.version_info[0] == 2 else iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getImportState_result)
getImportState_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class markPySparkTransformComplete_args(object):
    """
    Attributes:
     - auth
     - collectionName
     - path
     - transformJobId

    """


    def __init__(self, auth=None, collectionName=None, path=None, transformJobId=None,):
        self.auth = auth
        self.collectionName = collectionName
        self.path = path
        self.transformJobId = transformJobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.collectionName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.transformJobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markPySparkTransformComplete_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.collectionName is not None:
            oprot.writeFieldBegin('collectionName', TType.STRING, 2)
            oprot.writeString(self.collectionName.encode('utf-8') if sys.version_info[0] == 2 else self.collectionName)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.transformJobId is not None:
            oprot.writeFieldBegin('transformJobId', TType.I64, 4)
            oprot.writeI64(self.transformJobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markPySparkTransformComplete_args)
markPySparkTransformComplete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.STRING, 'collectionName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
    (4, TType.I64, 'transformJobId', None, None, ),  # 4
)


class markPySparkTransformComplete_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markPySparkTransformComplete_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markPySparkTransformComplete_result)
markPySparkTransformComplete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getTransformJobConfig_args(object):
    """
    Attributes:
     - auth
     - transformJobId

    """


    def __init__(self, auth=None, transformJobId=None,):
        self.auth = auth
        self.transformJobId = transformJobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.transformJobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTransformJobConfig_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.transformJobId is not None:
            oprot.writeFieldBegin('transformJobId', TType.I64, 2)
            oprot.writeI64(self.transformJobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTransformJobConfig_args)
getTransformJobConfig_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'transformJobId', None, None, ),  # 2
)


class getTransformJobConfig_result(object):
    """
    Attributes:
     - success
     - ke
     - ae

    """


    def __init__(self, success=None, ke=None, ae=None,):
        self.success = success
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TTransformJobConfig()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTransformJobConfig_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTransformJobConfig_result)
getTransformJobConfig_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TTransformJobConfig, None], None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)


class getNewSparkJobOutputPath_args(object):
    """
    Attributes:
     - auth

    """


    def __init__(self, auth=None,):
        self.auth = auth

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNewSparkJobOutputPath_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNewSparkJobOutputPath_args)
getNewSparkJobOutputPath_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
)


class getNewSparkJobOutputPath_result(object):
    """
    Attributes:
     - success
     - ke
     - ae
     - ce

    """


    def __init__(self, success=None, ke=None, ae=None, ce=None,):
        self.success = success
        self.ke = ke
        self.ae = ae
        self.ce = ce

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNewSparkJobOutputPath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNewSparkJobOutputPath_result)
getNewSparkJobOutputPath_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [koverse.thriftgen.security.ttypes.TCannotUseKoverseException, None], None, ),  # 3
)


class markTransformFailure_args(object):
    """
    Attributes:
     - auth
     - jobId
     - errorMessage

    """


    def __init__(self, auth=None, jobId=None, errorMessage=None,):
        self.auth = auth
        self.jobId = jobId
        self.errorMessage = errorMessage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
                    self.auth.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.jobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markTransformFailure_args')
        if self.auth is not None:
            oprot.writeFieldBegin('auth', TType.STRUCT, 1)
            self.auth.write(oprot)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.I64, 2)
            oprot.writeI64(self.jobId)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 3)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markTransformFailure_args)
markTransformFailure_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'auth', [koverse.thriftgen.security.ttypes.TAuthInfo, None], None, ),  # 1
    (2, TType.I64, 'jobId', None, None, ),  # 2
    (3, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 3
)


class markTransformFailure_result(object):
    """
    Attributes:
     - ke
     - ae

    """


    def __init__(self, ke=None, ae=None,):
        self.ke = ke
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ke = koverse.thriftgen.ttypes.TKoverseException()
                    self.ke.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markTransformFailure_result')
        if self.ke is not None:
            oprot.writeFieldBegin('ke', TType.STRUCT, 1)
            self.ke.write(oprot)
            oprot.writeFieldEnd()
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 2)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markTransformFailure_result)
markTransformFailure_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ke', [koverse.thriftgen.ttypes.TKoverseException, None], None, ),  # 1
    (2, TType.STRUCT, 'ae', [koverse.thriftgen.security.ttypes.TAuthorizationException, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs

