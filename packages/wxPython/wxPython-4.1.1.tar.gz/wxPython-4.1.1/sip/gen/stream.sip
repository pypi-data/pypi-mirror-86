//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

enum wxStreamError
{
    wxSTREAM_NO_ERROR,
    wxSTREAM_EOF,
    wxSTREAM_WRITE_ERROR,
    wxSTREAM_READ_ERROR
};

enum wxSeekMode
{
    wxFromStart,
    wxFromCurrent,
    wxFromEnd
};

class wxStreamBase   /Abstract/
{
    %Docstring
        StreamBase()
        
        This class is the base class of most stream related classes in
        wxWidgets.
    %End
    %TypeHeaderCode
        #include <wx/stream.h>
    %End

public:
    wxStreamBase();

    ~wxStreamBase();

    wxStreamError GetLastError() const;
    %Docstring
        GetLastError() -> StreamError
        
        This function returns the last error.
    %End

    wxFileOffset GetLength() const;
    %Docstring
        GetLength() -> FileOffset
        
        Returns the length of the stream in bytes.
    %End

    size_t GetSize() const;
    %Docstring
        GetSize() -> size_t
        
        This function returns the size of the stream.
    %End

    bool IsOk() const;
    %Docstring
        IsOk() -> bool
        
        Returns true if no error occurred on the stream.
    %End

    bool IsSeekable() const;
    %Docstring
        IsSeekable() -> bool
        
        Returns true if the stream supports seeking to arbitrary offsets.
    %End

    void Reset(
        wxStreamError error = wxSTREAM_NO_ERROR
    );
    %Docstring
        Reset(error=STREAM_NO_ERROR)
        
        Resets the stream state.
    %End

    public:


    %Property(name=LastError, get=GetLastError)
    %Property(name=Length, get=GetLength)
    %Property(name=Size, get=GetSize)
};  // end of class wxStreamBase


class wxInputStream : wxStreamBase   /Abstract/
{
    %Docstring
        InputStream()
        
        wxInputStream is an abstract base class which may not be used
        directly.
    %End
    %TypeHeaderCode
        #include <wx/stream.h>
    %End

    %TypeCode
        //--------------------------------------------------------------------------
        
        static PyObject* wxPyGetMethod(PyObject* py, char* name)
        {
            if (!PyObject_HasAttrString(py, name))
                return NULL;
            PyObject* o = PyObject_GetAttrString(py, name);
            if (!PyMethod_Check(o) && !PyCFunction_Check(o)) {
                Py_DECREF(o);
                return NULL;
            }
            return o;
        }
        
        #define wxPyBlock_t_default PyGILState_UNLOCKED
        
        
        // This class can wrap a Python file-like object and allow it to be used
        // as a wxInputStream.
        class wxPyInputStream : public wxInputStream
        {
        public:
        
            // Make sure there is at least a read method
            static bool Check(PyObject* fileObj)
            {
                PyObject* method = wxPyGetMethod(fileObj, "read");
                bool rval = method != NULL;
                Py_XDECREF(method);
                return rval;
            }
        
            wxPyInputStream(PyObject* fileObj, bool block=true)
            {
                m_block = block;
                wxPyThreadBlocker blocker(m_block);
        
                m_read = wxPyGetMethod(fileObj, "read");
                m_seek = wxPyGetMethod(fileObj, "seek");
                m_tell = wxPyGetMethod(fileObj, "tell");
            }
        
            virtual ~wxPyInputStream()
            {
                wxPyThreadBlocker blocker(m_block);
                Py_XDECREF(m_read);
                Py_XDECREF(m_seek);
                Py_XDECREF(m_tell);
            }
        
            wxPyInputStream(const wxPyInputStream& other)
            {
                wxPyThreadBlocker blocker;
                m_read  = other.m_read;
                m_seek  = other.m_seek;
                m_tell  = other.m_tell;
                m_block = other.m_block;
                Py_INCREF(m_read);
                Py_INCREF(m_seek);
                Py_INCREF(m_tell);
            }
        
        protected:
        
            // implement base class virtuals
        
            wxFileOffset GetLength() const
            {
                wxPyInputStream* self = (wxPyInputStream*)this; // cast off const
                if (m_seek && m_tell) {
                    wxFileOffset temp = self->OnSysTell();
                    wxFileOffset ret = self->OnSysSeek(0, wxFromEnd);
                    self->OnSysSeek(temp, wxFromStart);
                    return ret;
                }
                else
                    return wxInvalidOffset;
            }
        
            size_t OnSysRead(void *buffer, size_t bufsize)
            {
                if (bufsize == 0)
                    return 0;
        
                wxPyThreadBlocker blocker;
                PyObject* arglist = Py_BuildValue("(i)", bufsize);
                PyObject* result = PyEval_CallObject(m_read, arglist);
                Py_DECREF(arglist);
        
                size_t o = 0;
                if ((result != NULL) && PyBytes_Check(result)) {
                    o = PyBytes_Size(result);
                    if (o == 0)
                        m_lasterror = wxSTREAM_EOF;
                    if (o > bufsize)
                        o = bufsize;
                    memcpy((char*)buffer, PyBytes_AsString(result), o);  // strings only, not unicode...
                    Py_DECREF(result);
                }
                else
                    m_lasterror = wxSTREAM_READ_ERROR;
                return o;
            }
        
            size_t OnSysWrite(const void *buffer, size_t bufsize)
            {
                m_lasterror = wxSTREAM_WRITE_ERROR;
                return 0;
            }
        
            wxFileOffset OnSysSeek(wxFileOffset off, wxSeekMode mode)
            {
                wxPyThreadBlocker blocker;
                PyObject* arglist = PyTuple_New(2);
        
                if (sizeof(wxFileOffset) > sizeof(long))
                    // wxFileOffset is a 64-bit value...
                    PyTuple_SET_ITEM(arglist, 0, PyLong_FromLongLong(off));
                else
                    PyTuple_SET_ITEM(arglist, 0, wxPyInt_FromLong(off));
        
                PyTuple_SET_ITEM(arglist, 1, wxPyInt_FromLong(mode));
        
        
                PyObject* result = PyEval_CallObject(m_seek, arglist);
                Py_DECREF(arglist);
                Py_XDECREF(result);
                return OnSysTell();
            }
        
            wxFileOffset OnSysTell() const
            {
                wxPyThreadBlocker blocker;
                PyObject* arglist = Py_BuildValue("()");
                PyObject* result = PyEval_CallObject(m_tell, arglist);
                Py_DECREF(arglist);
                wxFileOffset o = 0;
                if (result != NULL) {
                    if (PyLong_Check(result))
                        o = PyLong_AsLongLong(result);
                    else
                        o = wxPyInt_AsLong(result);
                    Py_DECREF(result);
                };
                return o;
            }
        
            bool IsSeekable() const
            {
                return (m_seek != NULL);
            }
        
        
        private:
            PyObject* m_read;
            PyObject* m_seek;
            PyObject* m_tell;
            bool      m_block;
        };
        
        //--------------------------------------------------------------------------
        // helper used by the read and readline methods to make a PyObject
        static PyObject* _makeReadBufObj(wxInputStream* self, wxMemoryBuffer& buf) {
            PyObject* obj = NULL;
        
            wxPyThreadBlocker blocker;
            wxStreamError err = self->GetLastError();  // error check
            if (err != wxSTREAM_NO_ERROR && err != wxSTREAM_EOF) {
                PyErr_SetString(PyExc_IOError,"IOError in wxInputStream");
            }
            else {
                // Return the data as a string object.  TODO: Py3
                obj = PyBytes_FromStringAndSize(buf, buf.GetDataLen());
            }
            return obj;
        }
        PyObject* _wxInputStream_readline(wxInputStream* self);
        
        // This does the real work of the readlines methods
        static PyObject* _readlinesHelper(wxInputStream* self,
                                          bool useSizeHint=false, ulong sizehint=0) {
            PyObject* pylist;
        
            // init list
            {
                wxPyThreadBlocker blocker;
                pylist = PyList_New(0);
        
                if (!pylist) {
                    PyErr_NoMemory();
                    return NULL;
                }
            }
        
            // read sizehint bytes or until EOF
            ulong i;
            for (i=0; (self->CanRead()) && (useSizeHint || (i < sizehint));) {
                PyObject* s = _wxInputStream_readline(self);
                if (s == NULL) {
                    wxPyThreadBlocker blocker;
                    Py_DECREF(pylist);
                    return NULL;
                }
                wxPyThreadBlocker blocker;
                PyList_Append(pylist, s);
                i += PyBytes_Size(s);
            }
        
            // error check
            wxStreamError err = self->GetLastError();
            if (err != wxSTREAM_NO_ERROR && err != wxSTREAM_EOF) {
                wxPyThreadBlocker blocker;
                Py_DECREF(pylist);
                PyErr_SetString(PyExc_IOError,"IOError in wxInputStream");
                return NULL;
            }
            return pylist;
        }
    %End
public:
    wxInputStream();

    ~wxInputStream();

    bool CanRead() const;
    %Docstring
        CanRead() -> bool
        
        Returns true if some data is available in the stream right now, so
        that calling Read() wouldn't block.
    %End

    bool Eof() const;
    %Docstring
        Eof() -> bool
        
        Returns true after an attempt has been made to read past the end of
        the stream.
    %End

    int GetC();
    %Docstring
        GetC() -> int
        
        Returns the first character in the input queue and removes it,
        blocking until it appears if necessary.
    %End

    size_t LastRead() const;
    %Docstring
        LastRead() -> size_t
        
        Returns the last number of bytes read.
    %End

    char Peek();
    %Docstring
        Peek() -> char
        
        Returns the first character in the input queue without removing it.
    %End

    wxInputStream & Read(
        void * buffer,
        size_t size
    );
    %Docstring
        Read(buffer, size) -> InputStream
        Read(stream_out) -> InputStream
        
        Reads the specified amount of bytes and stores the data in buffer.
    %End

    wxInputStream & Read(
        wxOutputStream & stream_out
    );

    bool ReadAll(
        void * buffer,
        size_t size
    );
    %Docstring
        ReadAll(buffer, size) -> bool
        
        Reads exactly the specified number of bytes into the buffer.
    %End

    wxFileOffset SeekI(
        wxFileOffset pos,
        wxSeekMode mode = wxFromStart
    );
    %Docstring
        SeekI(pos, mode=FromStart) -> FileOffset
        
        Changes the stream current position.
    %End

    wxFileOffset TellI() const;
    %Docstring
        TellI() -> FileOffset
        
        Returns the current stream position or wxInvalidOffset if it's not
        available (e.g.
    %End

    size_t Ungetch(
        const void * buffer,
        size_t size
    );
    %Docstring
        Ungetch(buffer, size) -> size_t
        Ungetch(c) -> bool
        
        This function is only useful in read mode.
    %End

    bool Ungetch(
        char c
    );

    void seek(wxFileOffset offset,  int whence=0);
    %Docstring
        seek(offset, whence=0)
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxInputStream_seek(sipCpp, offset, whence);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxInputStream_seek(wxInputStream* self, wxFileOffset offset, int whence)
    {
        self->SeekI(offset, (wxSeekMode)whence);
    }
    %End

    wxFileOffset tell();
    %Docstring
        tell() -> FileOffset
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_tell(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxFileOffset _wxInputStream_tell(wxInputStream* self)
    {
        return self->TellI();
    }
    %End

    void close();
    %Docstring
        close()
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxInputStream_close(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxInputStream_close(wxInputStream* self)
    {
        // ignored for now
    }
    %End

    void flush();
    %Docstring
        flush()
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxInputStream_flush(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxInputStream_flush(wxInputStream* self)
    {
        // ignored for now
    }
    %End

    bool eof();
    %Docstring
        eof() -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_eof(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxInputStream_eof(wxInputStream* self)
    {
        return self->Eof();
    }
    %End

    PyObject* read();
    %Docstring
        read() -> PyObject
        read(size) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_read(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_read(wxInputStream* self)
    {
        wxMemoryBuffer buf;
        const ulong BUFSIZE = 1024;
        
        // read while bytes are available on the stream
        while ( self->CanRead() ) {
            self->Read(buf.GetAppendBuf(BUFSIZE), BUFSIZE);
            buf.UngetAppendBuf(self->LastRead());
        }
        return _makeReadBufObj(self, buf);
    }
    %End

    PyObject* read(ulong size);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_read(sipCpp, size);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_read(wxInputStream* self, ulong size)
    {
        wxMemoryBuffer buf;
        
        // Read only size number of characters
        self->Read(buf.GetWriteBuf(size), size);
        buf.UngetWriteBuf(self->LastRead());
        return _makeReadBufObj(self, buf);
    }
    %End

    PyObject* readline();
    %Docstring
        readline() -> PyObject
        readline(size) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_readline(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_readline(wxInputStream* self)
    {
        wxMemoryBuffer buf;
        char ch = 0;
        
        // read until \n
        while ((ch != '\n') && (self->CanRead())) {
            ch = self->GetC();
            buf.AppendByte(ch);
        }
        return _makeReadBufObj(self, buf);
    }
    %End

    PyObject* readline(ulong size);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_readline(sipCpp, size);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_readline(wxInputStream* self, ulong size)
    {
        wxMemoryBuffer buf;
        int i;
        char ch;
        
        // read until \n or byte limit reached
        for (i=ch=0; (ch != '\n') && (self->CanRead()) && (i < size); i++) {
            ch = self->GetC();
            buf.AppendByte(ch);
        }
        return _makeReadBufObj(self, buf);
    }
    %End

    PyObject* readlines();
    %Docstring
        readlines() -> PyObject
        readlines(sizehint) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_readlines(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_readlines(wxInputStream* self)
    {
        return _readlinesHelper(self);
    }
    %End

    PyObject* readlines(ulong sizehint);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxInputStream_readlines(sipCpp, sizehint);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxInputStream_readlines(wxInputStream* self, ulong sizehint)
    {
        return _readlinesHelper(self, true, sizehint);
    }
    %End

    public:


    %Property(name=C, get=GetC)
    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (wxPyInputStream::Check(sipPy))
                return 1;
            return 0;
        }
        // otherwise do the conversion
        *sipCppPtr = new wxPyInputStream(sipPy);
        return 0; //sipGetState(sipTransferObj);
    %End
};  // end of class wxInputStream


class wxOutputStream : wxStreamBase   /Abstract/
{
    %Docstring
        OutputStream()
        
        wxOutputStream is an abstract base class which may not be used
        directly.
    %End
    %TypeHeaderCode
        #include <wx/stream.h>
    %End

    %TypeCode
        //--------------------------------------------------------------------------
        
        static PyObject* wxPyGetMethod(PyObject* py, char* name)
        {
            if (!PyObject_HasAttrString(py, name))
                return NULL;
            PyObject* o = PyObject_GetAttrString(py, name);
            if (!PyMethod_Check(o) && !PyCFunction_Check(o)) {
                Py_DECREF(o);
                return NULL;
            }
            return o;
        }
        
        #define wxPyBlock_t_default PyGILState_UNLOCKED
        
        
        // This class can wrap a Python file-like object and allow it to be used
        // as a wxInputStream.
        class wxPyOutputStream : public wxOutputStream
        {
        public:
        
            // Make sure there is at least a write method
            static bool Check(PyObject* fileObj)
            {
                PyObject* method = wxPyGetMethod(fileObj, "write");
                bool rval = method != NULL;
                Py_XDECREF(method);
                return rval;
            }
        
            wxPyOutputStream(PyObject* fileObj, bool block=true)
            {
                m_block = block;
                wxPyThreadBlocker blocker(m_block);
        
                m_write = wxPyGetMethod(fileObj, "write");
                m_seek = wxPyGetMethod(fileObj, "seek");
                m_tell = wxPyGetMethod(fileObj, "tell");
            }
        
            virtual ~wxPyOutputStream()
            {
                wxPyThreadBlocker blocker(m_block);
                Py_XDECREF(m_write);
                Py_XDECREF(m_seek);
                Py_XDECREF(m_tell);
            }
        
            wxPyOutputStream(const wxPyOutputStream& other)
            {
                wxPyThreadBlocker blocker;
                m_write  = other.m_write;
                m_seek  = other.m_seek;
                m_tell  = other.m_tell;
                m_block = other.m_block;
                Py_INCREF(m_write);
                Py_INCREF(m_seek);
                Py_INCREF(m_tell);
            }
        
        protected:
        
            // implement base class virtuals
        
            wxFileOffset GetLength() const
            {
                wxPyOutputStream* self = (wxPyOutputStream*)this; // cast off const
                if (m_seek && m_tell) {
                    wxFileOffset temp = self->OnSysTell();
                    wxFileOffset ret = self->OnSysSeek(0, wxFromEnd);
                    self->OnSysSeek(temp, wxFromStart);
                    return ret;
                }
                else
                    return wxInvalidOffset;
            }
        
            size_t OnSysRead(void *buffer, size_t bufsize)
            {
                m_lasterror = wxSTREAM_READ_ERROR;
                return 0;
            }
        
            size_t OnSysWrite(const void *buffer, size_t bufsize)
            {
                if (bufsize == 0)
                    return 0;
        
                wxPyThreadBlocker blocker;
                PyObject* arglist = PyTuple_New(1);
                PyTuple_SET_ITEM(arglist, 0, PyBytes_FromStringAndSize((char*)buffer, bufsize));
        
                PyObject* result = PyEval_CallObject(m_write, arglist);
                Py_DECREF(arglist);
        
                if (result != NULL)
                    Py_DECREF(result);
                else
                    m_lasterror = wxSTREAM_WRITE_ERROR;
                return bufsize;
            }
        
            wxFileOffset OnSysSeek(wxFileOffset off, wxSeekMode mode)
            {
                wxPyThreadBlocker blocker;
                PyObject* arglist = PyTuple_New(2);
        
                if (sizeof(wxFileOffset) > sizeof(long))
                    // wxFileOffset is a 64-bit value...
                    PyTuple_SET_ITEM(arglist, 0, PyLong_FromLongLong(off));
                else
                    PyTuple_SET_ITEM(arglist, 0, wxPyInt_FromLong(off));
        
                PyTuple_SET_ITEM(arglist, 1, wxPyInt_FromLong(mode));
        
        
                PyObject* result = PyEval_CallObject(m_seek, arglist);
                Py_DECREF(arglist);
                Py_XDECREF(result);
                return OnSysTell();
            }
        
            wxFileOffset OnSysTell() const
            {
                wxPyThreadBlocker blocker;
                PyObject* arglist = Py_BuildValue("()");
                PyObject* result = PyEval_CallObject(m_tell, arglist);
                Py_DECREF(arglist);
                wxFileOffset o = 0;
                if (result != NULL) {
                    if (PyLong_Check(result))
                        o = PyLong_AsLongLong(result);
                    else
                        o = wxPyInt_AsLong(result);
                    Py_DECREF(result);
                };
                return o;
            }
        
            bool IsSeekable() const
            {
                return (m_seek != NULL);
            }
        
        private:
            PyObject* m_write;
            PyObject* m_seek;
            PyObject* m_tell;
            bool      m_block;
        };
        
        //--------------------------------------------------------------------------
    %End
public:
    wxOutputStream();

    ~wxOutputStream();

    bool Close();
    %Docstring
        Close() -> bool
        
        Closes the stream, returning false if an error occurs.
    %End

    size_t LastWrite() const;
    %Docstring
        LastWrite() -> size_t
        
        Returns the number of bytes written during the last Write().
    %End

    void PutC(
        char c
    );
    %Docstring
        PutC(c)
        
        Puts the specified character in the output queue and increments the
        stream position.
    %End

    wxFileOffset SeekO(
        wxFileOffset pos,
        wxSeekMode mode = wxFromStart
    );
    %Docstring
        SeekO(pos, mode=FromStart) -> FileOffset
        
        Changes the stream current position.
    %End

    wxFileOffset TellO() const;
    %Docstring
        TellO() -> FileOffset
        
        Returns the current stream position.
    %End

    wxOutputStream & Write(
        const void * buffer,
        size_t size
    );
    %Docstring
        Write(buffer, size) -> OutputStream
        Write(stream_in) -> OutputStream
        
        Writes up to the specified amount of bytes using the data of buffer.
    %End

    wxOutputStream & Write(
        wxInputStream & stream_in
    );

    bool WriteAll(
        const void * buffer,
        size_t size
    );
    %Docstring
        WriteAll(buffer, size) -> bool
        
        Writes exactly the specified number of bytes from the buffer.
    %End

    void seek(wxFileOffset offset,  int whence=0);
    %Docstring
        seek(offset, whence=0)
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxOutputStream_seek(sipCpp, offset, whence);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxOutputStream_seek(wxOutputStream* self, wxFileOffset offset, int whence)
    {
        self->SeekO(offset, (wxSeekMode)whence);
    }
    %End

    wxFileOffset tell();
    %Docstring
        tell() -> FileOffset
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxOutputStream_tell(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxFileOffset _wxOutputStream_tell(wxOutputStream* self)
    {
        return self->TellO();
    }
    %End

    void close();
    %Docstring
        close()
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxOutputStream_close(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxOutputStream_close(wxOutputStream* self)
    {
        self->Close();
    }
    %End

    void flush();
    %Docstring
        flush()
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxOutputStream_flush(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxOutputStream_flush(wxOutputStream* self)
    {
        self->Sync();
    }
    %End

    bool eof();
    %Docstring
        eof() -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxOutputStream_eof(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxOutputStream_eof(wxOutputStream* self)
    {
        return false; //self->Eof();
    }
    %End

    PyObject* write(PyObject* data);
    %Docstring
        write(data) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxOutputStream_write(sipCpp, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxOutputStream_write(wxOutputStream* self, PyObject* data)
    {
        // We use only bytes objects (strings in 2.7) for the streams, never unicode
        wxPyThreadBlocker blocker;
        if (!PyBytes_Check(data)) {
            PyErr_SetString(PyExc_TypeError, "Bytes object expected");
            return NULL;
        }
        self->Write(PyBytes_AS_STRING(data), PyBytes_GET_SIZE(data));
        RETURN_NONE();
    }
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            if (wxPyOutputStream::Check(sipPy))
                return 1;
            return 0;
        }
        // otherwise do the conversion
        *sipCppPtr = new wxPyOutputStream(sipPy);
        return sipGetState(sipTransferObj);
    %End
};  // end of class wxOutputStream



//---------------------------------------------------------------------------

