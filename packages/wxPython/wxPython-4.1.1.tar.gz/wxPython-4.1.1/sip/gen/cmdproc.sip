//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

%ModuleHeaderCode
#include <wx/cmdproc.h>
%End


//---------------------------------------------------------------------------

class wxCommand : wxObject
{
    %Docstring
        Command(canUndo=False, name=EmptyString)
        
        wxCommand is a base class for modelling an application command, which
        is an action usually performed by selecting a menu item, pressing a
        toolbar button or any other means provided by the application to
        change the data or view.
    %End
    %TypeHeaderCode
        #include <wx/cmdproc.h>
    %End

public:
    wxCommand(
        bool canUndo = false,
        const wxString & name = wxEmptyString
    );

    virtual
    ~wxCommand();

    virtual
    bool CanUndo() const;
    %Docstring
        CanUndo() -> bool
        
        Returns true if the command can be undone, false otherwise.
    %End

    virtual
    bool Do() = 0;
    %Docstring
        Do() -> bool
        
        Override this member function to execute the appropriate action when
        called.
    %End

    virtual
    wxString GetName() const;
    %Docstring
        GetName() -> String
        
        Returns the command name.
    %End

    virtual
    bool Undo() = 0;
    %Docstring
        Undo() -> bool
        
        Override this member function to un-execute a previous Do.
    %End

    private:
        wxCommand(const wxCommand&);


    public:


    %Property(name=Name, get=GetName)
};  // end of class wxCommand


class wxCommandProcessor : wxObject
{
    %Docstring
        CommandProcessor(maxCommands=-1)
        
        wxCommandProcessor is a class that maintains a history of wxCommands,
        with undo/redo functionality built-in.
    %End
    %TypeHeaderCode
        #include <wx/cmdproc.h>
    %End

public:
    wxCommandProcessor(
        int maxCommands = -1
    );

    virtual
    ~wxCommandProcessor();

    virtual
    bool CanUndo() const;
    %Docstring
        CanUndo() -> bool
        
        Returns true if the currently-active command can be undone, false
        otherwise.
    %End

    virtual
    bool CanRedo() const;
    %Docstring
        CanRedo() -> bool
        
        Returns true if the currently-active command can be redone, false
        otherwise.
    %End

    virtual
    void ClearCommands();
    %Docstring
        ClearCommands()
        
        Deletes all commands in the list and sets the current command pointer
        to NULL.
    %End

    wxCommandList& GetCommands()   /NoCopy/;
    %Docstring
        GetCommands() -> CommandList
        
        Returns the list of commands.
    %End

    wxCommand * GetCurrentCommand() const;
    %Docstring
        GetCurrentCommand() -> Command
        
        Returns the current command.
    %End

    wxMenu * GetEditMenu() const;
    %Docstring
        GetEditMenu() -> Menu
        
        Returns the edit menu associated with the command processor.
    %End

    int GetMaxCommands() const;
    %Docstring
        GetMaxCommands() -> int
        
        Returns the maximum number of commands that the command processor
        stores.
    %End

    const wxString & GetRedoAccelerator() const;
    %Docstring
        GetRedoAccelerator() -> String
        
        Returns the string that will be appended to the Redo menu item.
    %End

    wxString GetRedoMenuLabel() const;
    %Docstring
        GetRedoMenuLabel() -> String
        
        Returns the string that will be shown for the redo menu item.
    %End

    const wxString & GetUndoAccelerator() const;
    %Docstring
        GetUndoAccelerator() -> String
        
        Returns the string that will be appended to the Undo menu item.
    %End

    wxString GetUndoMenuLabel() const;
    %Docstring
        GetUndoMenuLabel() -> String
        
        Returns the string that will be shown for the undo menu item.
    %End

    virtual
    void Initialize();
    %Docstring
        Initialize()
        
        Initializes the command processor, setting the current command to the
        last in the list (if any), and updating the edit menu (if one has been
        specified).
    %End

    virtual
    bool IsDirty() const;
    %Docstring
        IsDirty() -> bool
        
        Returns a boolean value that indicates if changes have been made since
        the last save operation.
    %End

    void MarkAsSaved();
    %Docstring
        MarkAsSaved()
        
        You must call this method whenever the project is saved if you plan to
        use IsDirty().
    %End

    virtual
    bool Redo();
    %Docstring
        Redo() -> bool
        
        Executes (redoes) the current command (the command that has just been
        undone if any).
    %End

    void SetEditMenu(
        wxMenu * menu
    );
    %Docstring
        SetEditMenu(menu)
        
        Tells the command processor to update the Undo and Redo items on this
        menu as appropriate.
    %End

    virtual
    void SetMenuStrings();
    %Docstring
        SetMenuStrings()
        
        Sets the menu labels according to the currently set menu and the
        current command state.
    %End

    void SetRedoAccelerator(
        const wxString & accel
    );
    %Docstring
        SetRedoAccelerator(accel)
        
        Sets the string that will be appended to the Redo menu item.
    %End

    void SetUndoAccelerator(
        const wxString & accel
    );
    %Docstring
        SetUndoAccelerator(accel)
        
        Sets the string that will be appended to the Undo menu item.
    %End

    virtual
    bool Submit(
        wxCommand * command   /Transfer/,
        bool storeIt = true
    );
    %Docstring
        Submit(command, storeIt=True) -> bool
        
        Submits a new command to the command processor.
    %End

    virtual
    void Store(
        wxCommand * command   /Transfer/
    );
    %Docstring
        Store(command)
        
        Just store the command without executing it.
    %End

    virtual
    bool Undo();
    %Docstring
        Undo() -> bool
        
        Undoes the last command executed.
    %End

    private:
        wxCommandProcessor(const wxCommandProcessor&);


    public:


    %Property(name=Commands, get=GetCommands)
    %Property(name=CurrentCommand, get=GetCurrentCommand)
    %Property(name=EditMenu, get=GetEditMenu, set=SetEditMenu)
    %Property(name=MaxCommands, get=GetMaxCommands)
    %Property(name=RedoAccelerator, get=GetRedoAccelerator, set=SetRedoAccelerator)
    %Property(name=RedoMenuLabel, get=GetRedoMenuLabel)
    %Property(name=UndoAccelerator, get=GetUndoAccelerator, set=SetUndoAccelerator)
    %Property(name=UndoMenuLabel, get=GetUndoMenuLabel)
};  // end of class wxCommandProcessor


class wxCommandList_iterator /Abstract/
{
    // the C++ implementation of this class
    %TypeHeaderCode
        
        typedef wxList wxCommandList;
        class wxCommandList_iterator {
        public:
            wxCommandList_iterator(wxCommandList::compatibility_iterator start)
                : m_node(start) {}

            wxCommand* __next__() {
                wxCommand* obj = NULL;
                if (m_node) {
                    obj = (wxCommand*) m_node->GetData();
                    m_node = m_node->GetNext();
                }
                else {
                    PyErr_SetString(PyExc_StopIteration, "");
                }
                return (wxCommand*)obj;
            }
        private:
            wxCommandList::compatibility_iterator m_node;
        };
    %End
public:
    wxCommand* __next__();
    %MethodCode
        sipRes = sipCpp->__next__();
        if (PyErr_Occurred())
            return NULL;
    %End
};

class wxCommandList
{
    %TypeHeaderCode
        
        typedef wxList wxCommandList;
    %End
public:
    SIP_SSIZE_T __len__();
    %MethodCode
        sipRes = sipCpp->size();
    %End

    wxCommand* __getitem__(long index);
    %MethodCode
        if (0 > index)
            index += sipCpp->size();

        if (index < sipCpp->size() && (0 <= index)) {
            wxCommandList::compatibility_iterator node = sipCpp->Item(index);
            if (node)
                sipRes = (wxCommand*)node->GetData();
        }
        else {
            wxPyErr_SetString(PyExc_IndexError, "sequence index out of range");
            sipError = sipErrorFail;
        }
    %End

    int __contains__(const wxCommand* obj);
    %MethodCode
        wxCommandList::compatibility_iterator node;
        node = sipCpp->Find((wxCommand*)obj);
        sipRes = node != NULL;
    %End

    wxCommandList_iterator* __iter__() /Factory/;
    %MethodCode
        sipRes =  new wxCommandList_iterator(sipCpp->GetFirst());
    %End

    // TODO:  add support for index(value, [start, [stop]])
    int index(wxCommand* obj);
    %MethodCode
        int idx = sipCpp->IndexOf((wxCommand*)obj);
        if (idx == wxNOT_FOUND) {
            sipError = sipErrorFail;
            wxPyErr_SetString(PyExc_ValueError,
                              "sequence.index(x): x not in sequence");
        }
        sipRes = idx;
    %End

    
};

%Extract(id=pycode_core)
def _CommandList___repr__(self):
    return "CommandList: " + repr(list(self))
CommandList.__repr__ = _CommandList___repr__
del _CommandList___repr__
%End



//---------------------------------------------------------------------------

