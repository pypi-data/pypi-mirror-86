//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

class wxGBPosition
{
    %Docstring
        GBPosition()
        GBPosition(row, col)
        
        This class represents the position of an item in a virtual grid of
        rows and columns managed by a wxGridBagSizer.
    %End
    %TypeHeaderCode
        #include <wx/gbsizer.h>
    %End

public:
    wxGBPosition();

    wxGBPosition(
        int row,
        int col
    );

    int GetCol() const;
    %Docstring
        GetCol() -> int
        
        Get the current column value.
    %End

    int GetRow() const;
    %Docstring
        GetRow() -> int
        
        Get the current row value.
    %End

    void SetCol(
        int col
    );
    %Docstring
        SetCol(col)
        
        Set a new column value.
    %End

    void SetRow(
        int row
    );
    %Docstring
        SetRow(row)
        
        Set a new row value.
    %End

    bool operator!=(
        const wxGBPosition & p
    ) const;

    bool operator==(
        const wxGBPosition & p
    ) const;

    PyObject* Get();
    %Docstring
        Get() -> (row, col)
        
        Return the row and col properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxGBPosition_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxGBPosition_Get(wxGBPosition* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(ii)", self->GetRow(), self->GetCol());
    }
    %End

    void Set(int row=0,  int col=0);
    %Docstring
        Set(row=0, col=0)
        
        Set both the row and column properties.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxGBPosition_Set(sipCpp, row, col);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxGBPosition_Set(wxGBPosition* self, int row, int col)
    {
        self->SetRow(row);
        self->SetCol(col);
    }
    %End

    %Property(name=Row, get=GetRow, set=SetRow)
    %Property(name=Col, get=GetCol, set=SetCol)
    %Property(name=row, get=GetRow, set=SetRow)
    %Property(name=col, get=GetCol, set=SetCol)
    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxGBPosition?
            if (sipCanConvertToType(sipPy, sipType_wxGBPosition, SIP_NO_CONVERTORS))
                return 1;
        
            if (wxPyNumberSequenceCheck(sipPy, 2)) {
                return 1;
            }
            return 0;
        }
        
         // otherwise do the conversion
         if (sipCanConvertToType(sipPy, sipType_wxGBPosition, SIP_NO_CONVERTORS)) {
             // Just fetch the existing instance
             *sipCppPtr = reinterpret_cast<wxGBPosition*>(sipConvertToType(
                     sipPy, sipType_wxGBPosition, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
             return 0;  // not a new instance
         }
        
         // or create a new instance
         PyObject* o1 = PySequence_ITEM(sipPy, 0);
         PyObject* o2 = PySequence_ITEM(sipPy, 1);
         *sipCppPtr = new wxGBPosition(wxPyInt_AsLong(o1), wxPyInt_AsLong(o2));
         Py_DECREF(o1);
         Py_DECREF(o2);
         return SIP_TEMPORARY;
    %End
};  // end of class wxGBPosition


%Extract(id=pycode_core)
def _GBPosition_GetIM(self):
    """
    Returns an immutable representation of the ``wx.GBPosition`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.GBPosition``
    with a simple statement like this: ``obj = wx.GBPosition(imObj)``.
    """
    return _im_GBPosition(*self.Get())
GBPosition.GetIM = _GBPosition_GetIM
del _GBPosition_GetIM
%End

%Extract(id=pycode_core)
def _GBPosition___str__(self):
    return str(self.Get())
GBPosition.__str__ = _GBPosition___str__
del _GBPosition___str__
%End

%Extract(id=pycode_core)
def _GBPosition___repr__(self):
    return "wx.GBPosition"+str(self.Get())
GBPosition.__repr__ = _GBPosition___repr__
del _GBPosition___repr__
%End

%Extract(id=pycode_core)
def _GBPosition___len__(self):
    return len(self.Get())
GBPosition.__len__ = _GBPosition___len__
del _GBPosition___len__
%End

%Extract(id=pycode_core)
def _GBPosition___nonzero__(self):
    return self.Get() != (0,0)
GBPosition.__nonzero__ = _GBPosition___nonzero__
del _GBPosition___nonzero__
%End

%Extract(id=pycode_core)
def _GBPosition___bool__(self):
    return self.Get() != (0,0)
GBPosition.__bool__ = _GBPosition___bool__
del _GBPosition___bool__
%End

%Extract(id=pycode_core)
def _GBPosition___reduce__(self):
    return (GBPosition, self.Get())
GBPosition.__reduce__ = _GBPosition___reduce__
del _GBPosition___reduce__
%End

%Extract(id=pycode_core)
def _GBPosition___getitem__(self, idx):
    return self.Get()[idx]
GBPosition.__getitem__ = _GBPosition___getitem__
del _GBPosition___getitem__
%End

%Extract(id=pycode_core)
def _GBPosition___setitem__(self, idx, val):
    if idx == 0: self.Row = val
    elif idx == 1: self.Col = val
    else: raise IndexError
GBPosition.__setitem__ = _GBPosition___setitem__
del _GBPosition___setitem__
%End

%Extract(id=pycode_core)
GBPosition.__safe_for_unpickling__ = True

%End

class wxGBSpan
{
    %Docstring
        GBSpan()
        GBSpan(rowspan, colspan)
        
        This class is used to hold the row and column spanning attributes of
        items in a wxGridBagSizer.
    %End
    %TypeHeaderCode
        #include <wx/gbsizer.h>
    %End

public:
    wxGBSpan();

    wxGBSpan(
        int rowspan,
        int colspan
    );

    int GetColspan() const;
    %Docstring
        GetColspan() -> int
        
        Get the current colspan value.
    %End

    int GetRowspan() const;
    %Docstring
        GetRowspan() -> int
        
        Get the current rowspan value.
    %End

    void SetColspan(
        int colspan
    );
    %Docstring
        SetColspan(colspan)
        
        Set a new colspan value.
    %End

    void SetRowspan(
        int rowspan
    );
    %Docstring
        SetRowspan(rowspan)
        
        Set a new rowspan value.
    %End

    bool operator!=(
        const wxGBSpan & o
    ) const;

    bool operator==(
        const wxGBSpan & o
    ) const;

    PyObject* Get();
    %Docstring
        Get() -> (rowspan, colspan)
        
        Return the rowspan and colspan properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxGBSpan_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxGBSpan_Get(wxGBSpan* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(ii)", self->GetRowspan(), self->GetColspan());
    }
    %End

    void Set(int rowspan=0,  int colspan=0);
    %Docstring
        Set(rowspan=0, colspan=0)
        
        Set both the rowspan and colspan properties.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxGBSpan_Set(sipCpp, rowspan, colspan);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxGBSpan_Set(wxGBSpan* self, int rowspan, int colspan)
    {
        self->SetRowspan(rowspan);
        self->SetColspan(colspan);
    }
    %End

    %Property(name=Rowspan, get=GetRowspan, set=SetRowspan)
    %Property(name=Colspan, get=GetColspan, set=SetColspan)
    %Property(name=rowspan, get=GetRowspan, set=SetRowspan)
    %Property(name=colspan, get=GetColspan, set=SetColspan)
    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxGBSpan?
            if (sipCanConvertToType(sipPy, sipType_wxGBSpan, SIP_NO_CONVERTORS))
                return 1;
        
            if (wxPyNumberSequenceCheck(sipPy, 2)) {
                return 1;
            }
            return 0;
        }
        
         // otherwise do the conversion
         if (sipCanConvertToType(sipPy, sipType_wxGBSpan, SIP_NO_CONVERTORS)) {
             // Just fetch the existing instance
             *sipCppPtr = reinterpret_cast<wxGBSpan*>(sipConvertToType(
                     sipPy, sipType_wxGBSpan, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
             return 0;  // not a new instance
         }
        
         // or create a new instance
         PyObject* o1 = PySequence_ITEM(sipPy, 0);
         PyObject* o2 = PySequence_ITEM(sipPy, 1);
         *sipCppPtr = new wxGBSpan(wxPyInt_AsLong(o1), wxPyInt_AsLong(o2));
         Py_DECREF(o1);
         Py_DECREF(o2);
         return SIP_TEMPORARY;
    %End
};  // end of class wxGBSpan


%Extract(id=pycode_core)
def _GBSpan_GetIM(self):
    """
    Returns an immutable representation of the ``wx.GBSpan`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.GBSpan``
    with a simple statement like this: ``obj = wx.GBSpan(imObj)``.
    """
    return _im_GBSpan(*self.Get())
GBSpan.GetIM = _GBSpan_GetIM
del _GBSpan_GetIM
%End

%Extract(id=pycode_core)
def _GBSpan___str__(self):
    return str(self.Get())
GBSpan.__str__ = _GBSpan___str__
del _GBSpan___str__
%End

%Extract(id=pycode_core)
def _GBSpan___repr__(self):
    return "wx.GBSpan"+str(self.Get())
GBSpan.__repr__ = _GBSpan___repr__
del _GBSpan___repr__
%End

%Extract(id=pycode_core)
def _GBSpan___len__(self):
    return len(self.Get())
GBSpan.__len__ = _GBSpan___len__
del _GBSpan___len__
%End

%Extract(id=pycode_core)
def _GBSpan___nonzero__(self):
    return self.Get() != (0,0)
GBSpan.__nonzero__ = _GBSpan___nonzero__
del _GBSpan___nonzero__
%End

%Extract(id=pycode_core)
def _GBSpan___bool__(self):
    return self.Get() != (0,0)
GBSpan.__bool__ = _GBSpan___bool__
del _GBSpan___bool__
%End

%Extract(id=pycode_core)
def _GBSpan___reduce__(self):
    return (GBSpan, self.Get())
GBSpan.__reduce__ = _GBSpan___reduce__
del _GBSpan___reduce__
%End

%Extract(id=pycode_core)
def _GBSpan___getitem__(self, idx):
    return self.Get()[idx]
GBSpan.__getitem__ = _GBSpan___getitem__
del _GBSpan___getitem__
%End

%Extract(id=pycode_core)
def _GBSpan___setitem__(self, idx, val):
    if idx == 0: self.Rowspan = val
    elif idx == 1: self.Colspan = val
    else: raise IndexError
GBSpan.__setitem__ = _GBSpan___setitem__
del _GBSpan___setitem__
%End

%Extract(id=pycode_core)
GBSpan.__safe_for_unpickling__ = True

%End

class wxGBSizerItem : wxSizerItem
{
    %Docstring
        GBSizerItem(width, height, pos, span=DefaultSpan, flag=0, border=0, userData=None)
        GBSizerItem(window, pos, span=DefaultSpan, flag=0, border=0, userData=None)
        GBSizerItem(sizer, pos, span=DefaultSpan, flag=0, border=0, userData=None)
        
        The wxGBSizerItem class is used by the wxGridBagSizer for tracking the
        items in the sizer.
    %End
    %TypeHeaderCode
        #include <wx/gbsizer.h>
    %End

public:
    wxGBSizerItem(
        int width,
        int height,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );

    wxGBSizerItem(
        wxWindow * window,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );

    wxGBSizerItem(
        wxSizer * sizer   /Transfer/,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );

    wxGBPosition GetPos() const;
    %Docstring
        GetPos() -> GBPosition
        
        Get the grid position of the item.
    %End

    wxGBSpan GetSpan() const;
    %Docstring
        GetSpan() -> GBSpan
        
        Get the row and column spanning of the item.
    %End

    void GetEndPos(
        int & row   /Out/,
        int & col   /Out/
    );
    %Docstring
        GetEndPos() -> (row, col)
        
        Get the row and column of the endpoint of this item.
    %End

    bool Intersects(
        const wxGBSizerItem & other
    );
    %Docstring
        Intersects(other) -> bool
        Intersects(pos, span) -> bool
        
        Returns true if this item and the other item intersect.
    %End

    bool Intersects(
        const wxGBPosition & pos,
        const wxGBSpan & span
    );

    bool SetPos(
        const wxGBPosition & pos
    );
    %Docstring
        SetPos(pos) -> bool
        
        If the item is already a member of a sizer then first ensure that
        there is no other item that would intersect with this one at the new
        position, then set the new position.
    %End

    bool SetSpan(
        const wxGBSpan & span
    );
    %Docstring
        SetSpan(span) -> bool
        
        If the item is already a member of a sizer then first ensure that
        there is no other item that would intersect with this one with its new
        spanning size, then set the new spanning.
    %End

    wxGridBagSizer * GetGBSizer() const;
    %Docstring
        GetGBSizer() -> GridBagSizer
    %End

    void SetGBSizer(
        wxGridBagSizer * sizer
    );
    %Docstring
        SetGBSizer(sizer)
    %End

    public:


    %Property(name=GBSizer, get=GetGBSizer, set=SetGBSizer)
    %Property(name=Pos, get=GetPos, set=SetPos)
    %Property(name=Span, get=GetSpan, set=SetSpan)
};  // end of class wxGBSizerItem


class wxGridBagSizer : wxFlexGridSizer
{
    %Docstring
        GridBagSizer(vgap=0, hgap=0)
        
        A wxSizer that can lay out items in a virtual grid like a
        wxFlexGridSizer but in this case explicit positioning of the items is
        allowed using wxGBPosition, and items can optionally span more than
        one row and/or column using wxGBSpan.
    %End
    %TypeHeaderCode
        #include <wx/gbsizer.h>
    %End

public:
    wxGridBagSizer(
        int vgap = 0,
        int hgap = 0
    );

    wxSizerItem * Add(
        wxWindow * window,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );
    %Docstring
        Add(window, pos, span=DefaultSpan, flag=0, border=0, userData=None) -> SizerItem
        Add(sizer, pos, span=DefaultSpan, flag=0, border=0, userData=None) -> SizerItem
        Add(item) -> SizerItem
        Add(width, height, pos, span=DefaultSpan, flag=0, border=0, userData=None) -> SizerItem
        Add(size, pos, span=DefaultSpan, flag=0, border=0, /Transfer/=None) -> SizerItem
        
        Adds the given item to the given position.
    %End

    wxSizerItem * Add(
        wxSizer * sizer   /Transfer/,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );

    wxSizerItem * Add(
        wxGBSizerItem * item   /Transfer/
    );

    wxSizerItem * Add(
        int width,
        int height,
        const wxGBPosition & pos,
        const wxGBSpan & span = wxDefaultSpan,
        int flag = 0,
        int border = 0,
        wxPyUserData* userData   /Transfer/ = NULL
    );

    wxSizerItem* Add(const wxSize& size,  const wxGBPosition& pos,  const wxGBSpan& span = wxDefaultSpan,  int flag = 0,  int border = 0,  wxObject* userData /Transfer/ = NULL);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxGridBagSizer_Add(sipCpp, size, pos, span, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxSizerItem* _wxGridBagSizer_Add(wxGridBagSizer* self, const wxSize* size, const wxGBPosition* pos, const wxGBSpan* span, int flag, int border, wxObject* userData )
    {
        return self->Add(size->x, size->y, *pos, *span, flag, border, userData);
    }
    %End

    bool CheckForIntersection(
        wxGBSizerItem * item,
        wxGBSizerItem * excludeItem = NULL
    );
    %Docstring
        CheckForIntersection(item, excludeItem=None) -> bool
        CheckForIntersection(pos, span, excludeItem=None) -> bool
        
        Look at all items and see if any intersect (or would overlap) the
        given item.
    %End

    bool CheckForIntersection(
        const wxGBPosition & pos,
        const wxGBSpan & span,
        wxGBSizerItem * excludeItem = NULL
    );

    wxGBSizerItem * FindItem(
        wxWindow * window
    );
    %Docstring
        FindItem(window) -> GBSizerItem
        FindItem(sizer) -> GBSizerItem
        
        Find the sizer item for the given window or subsizer, returns NULL if
        not found.
    %End

    wxGBSizerItem * FindItem(
        wxSizer * sizer
    );

    wxGBPosition GetItemPosition(
        wxWindow * window
    );
    %Docstring
        GetItemPosition(window) -> GBPosition
        GetItemPosition(sizer) -> GBPosition
        GetItemPosition(index) -> GBPosition
        
        Get the grid position of the specified item.
    %End

    wxGBPosition GetItemPosition(
        wxSizer * sizer
    );

    wxGBPosition GetItemPosition(
        size_t index
    );

    wxGBSpan GetItemSpan(
        wxWindow * window
    );
    %Docstring
        GetItemSpan(window) -> GBSpan
        GetItemSpan(sizer) -> GBSpan
        GetItemSpan(index) -> GBSpan
        
        Get the row/col spanning of the specified item.
    %End

    wxGBSpan GetItemSpan(
        wxSizer * sizer
    );

    wxGBSpan GetItemSpan(
        size_t index
    );

    bool SetItemPosition(
        wxWindow * window,
        const wxGBPosition & pos
    );
    %Docstring
        SetItemPosition(window, pos) -> bool
        SetItemPosition(sizer, pos) -> bool
        SetItemPosition(index, pos) -> bool
        
        Set the grid position of the specified item.
    %End

    bool SetItemPosition(
        wxSizer * sizer,
        const wxGBPosition & pos
    );

    bool SetItemPosition(
        size_t index,
        const wxGBPosition & pos
    );

    bool SetItemSpan(
        wxWindow * window,
        const wxGBSpan & span
    );
    %Docstring
        SetItemSpan(window, span) -> bool
        SetItemSpan(sizer, span) -> bool
        SetItemSpan(index, span) -> bool
        
        Set the row/col spanning of the specified item.
    %End

    bool SetItemSpan(
        wxSizer * sizer,
        const wxGBSpan & span
    );

    bool SetItemSpan(
        size_t index,
        const wxGBSpan & span
    );

    virtual
    wxSize CalcMin();
    %Docstring
        CalcMin() -> Size
        
        Called when the managed size of the sizer is needed or when layout
        needs done.
    %End

    wxGBSizerItem * FindItemAtPoint(
        const wxPoint & pt
    );
    %Docstring
        FindItemAtPoint(pt) -> GBSizerItem
        
        Return the sizer item located at the point given in pt, or NULL if
        there is no item at that point.
    %End

    wxGBSizerItem * FindItemAtPosition(
        const wxGBPosition & pos
    );
    %Docstring
        FindItemAtPosition(pos) -> GBSizerItem
        
        Return the sizer item for the given grid cell, or NULL if there is no
        item at that position.
    %End

    wxGBSizerItem * FindItemWithData(
        const wxObject * userData
    );
    %Docstring
        FindItemWithData(userData) -> GBSizerItem
        
        Return the sizer item that has a matching user data (it only compares
        pointer values) or NULL if not found.
    %End

    wxSize GetCellSize(
        int row,
        int col
    ) const;
    %Docstring
        GetCellSize(row, col) -> Size
        
        Get the size of the specified cell, including hgap and vgap.
    %End

    wxSize GetEmptyCellSize() const;
    %Docstring
        GetEmptyCellSize() -> Size
        
        Get the size used for cells in the grid with no item.
    %End

    virtual
    void RepositionChildren(
        const wxSize & minSize
    );
    %Docstring
        RepositionChildren(minSize)
        
        Called when the managed size of the sizer is needed or when layout
        needs done.
    %End

    void SetEmptyCellSize(
        const wxSize & sz
    );
    %Docstring
        SetEmptyCellSize(sz)
        
        Set the size used for cells in the grid with no item.
    %End

    public:


    %Property(name=EmptyCellSize, get=GetEmptyCellSize, set=SetEmptyCellSize)
};  // end of class wxGridBagSizer


%Extract(id=pycode_core)
GridBagSizer.CheckForIntersectionPos = wx.deprecated(GridBagSizer.CheckForIntersection, 'Use CheckForIntersection instead.')

%End

const wxGBSpan wxDefaultSpan;

%Extract(id=pycode_core)
from collections import namedtuple
_im_GBPosition = namedtuple('_im_GBPosition', ['row', 'col'])
del namedtuple

%End

%Extract(id=pycode_core)
from collections import namedtuple
_im_GBSpan = namedtuple('_im_GBSpan', ['rowspan', 'colspan'])
del namedtuple

%End


//---------------------------------------------------------------------------

