//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _adv.sip
//
//---------------------------------------------------------------------------

%ModuleHeaderCode
#include "pseudodc.h"
%End

%ModuleCode
/////////////////////////////////////////////////////////////////////////////
// Name:        src/pseudodc.cpp
// Purpose:     Implementation of the wxPseudoDC classes
// Author:      Paul Lanier
// Modified by: Robin Dunn
//
// Created:     25-May-2006
// Copyright:   (c) 2006-2020 Total Control Software
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

// For compilers that support precompilation, includes "wx.h".
//include "wx/wxprec.h"

//#undef DEBUG

// wxList based class definitions
#include <wx/listimpl.cpp>
WX_DEFINE_LIST(pdcOpList);
WX_DEFINE_LIST(pdcObjectList);

//----------------------------------------------------------------------------
// Helper functions used for drawing greyed out versions of objects
//----------------------------------------------------------------------------
wxColour &MakeColourGrey(const wxColour &c)
{
    static wxColour rval;
    rval.Set(byte((230-c.Red())*0.7+c.Red()),
             byte((230-c.Green())*0.7+c.Green()),
             byte((230-c.Blue())*0.7+c.Blue()));
    return rval;
}
wxBrush &GetGreyBrush(wxBrush &brush)
{
    static wxBrush b;
    wxColour c;
    b = brush;
    c = MakeColourGrey(brush.GetColour());
    b.SetColour(c);
    return b;
}

wxPen &GetGreyPen(wxPen &pen)
{
    static wxPen p;
    wxColour c;
    p = pen;
    c = MakeColourGrey(pen.GetColour());
    p.SetColour(c);
    return p;
}

void GreyOutImage(wxImage &img)
{
    unsigned char *data = img.GetData();
    unsigned char r,g,b;
    unsigned char mr,mg,mb;
    int i, tst;
    int len = img.GetHeight()*img.GetWidth()*3;
    if (img.HasMask())
    {
        mr = img.GetMaskRed();
        mg = img.GetMaskGreen();
        mb = img.GetMaskBlue();
    }
    tst=0;
    for (i=0;i<len;i+=3)
    {
        r=data[i]; g=data[i+1]; b=data[i+2];
        if (!img.HasMask() ||
            r!=mr || g!=mg || b!=mb)
        {
            if (!tst)
            {
                tst=1;
            }
            r = (unsigned char)((230.0-r)*0.7+r);
            g = (unsigned char)((230.0-g)*0.7+g);
            b = (unsigned char)((230.0-b)*0.7+b);
            data[i]=r; data[i+1]=g; data[i+2]=b;
        }
    }
}

wxIcon &GetGreyIcon(wxIcon &icon)
{
    wxBitmap bmp;
    bmp.CopyFromIcon(icon);
    wxImage img = bmp.ConvertToImage();
    GreyOutImage(img);
    wxBitmap bmp2(img,32);
    static wxIcon rval;
    rval.CopyFromBitmap(bmp2);
    return rval;
}

wxBitmap &GetGreyBitmap(wxBitmap &bmp)
{
    wxImage img = bmp.ConvertToImage();
    GreyOutImage(img);
    static wxBitmap rval(img,32);
    return rval;
}

// ============================================================================
// various pdcOp class implementation methods
// ============================================================================

// ----------------------------------------------------------------------------
// pdcDrawPolyPolygonOp
// ----------------------------------------------------------------------------
pdcDrawPolyPolygonOp::pdcDrawPolyPolygonOp(int n, int count[], wxPoint points[],
                 wxCoord xoffset, wxCoord yoffset, wxPolygonFillMode fillStyle)
{
    m_n=n; m_xoffset=xoffset; m_yoffset=yoffset; m_fillStyle=fillStyle;
    int total_n=0;
    if (n)
    {
        m_count = new int[n];
        for(int i=0; i<n; i++)
        {
            total_n+=count[i];
            m_count[i]=count[i];
        }
        if (total_n)
        {
            m_points = new wxPoint[total_n];
            for(int j=0; j<total_n; j++)
                m_points[j] = points[j];
        }
        else m_points=NULL;
    }
    else
    {
        m_points=NULL;
        m_count=NULL;
    }
    m_totaln = total_n;
}


pdcDrawPolyPolygonOp::~pdcDrawPolyPolygonOp()
{
    if (m_points) delete[] m_points;
    if (m_count) delete[] m_count;
    m_points=NULL;
    m_count=NULL;
}


// ----------------------------------------------------------------------------
// pdcDrawLinesOp
// ----------------------------------------------------------------------------
pdcDrawLinesOp::pdcDrawLinesOp(const wxPointList* points,
                               wxCoord xoffset,
                               wxCoord yoffset)
{
    m_xoffset = xoffset;
    m_yoffset = yoffset;

    m_points = new wxPointList;
    wxPointList::const_iterator iter;
    for (iter = points->begin(); iter != points->end(); iter++)
    {
        // The first * gives us a wxPoint ptr, second * dereferences that ptr
        m_points->push_back(new wxPoint(**iter));
    }
}


pdcDrawLinesOp::~pdcDrawLinesOp()
{
    m_points->clear();
    delete m_points;
    m_points = NULL;
}


void pdcDrawLinesOp::Translate(wxCoord dx, wxCoord dy)
{
    wxPointList::const_iterator iter;
    for (iter = m_points->begin(); iter != m_points->end(); iter++)
    {
        (*iter)->x += dx;
        (*iter)->y += dy;
    }
}

// ----------------------------------------------------------------------------
// pdcDrawPolygonOp
// ----------------------------------------------------------------------------
pdcDrawPolygonOp::pdcDrawPolygonOp(const wxPointList* points,
                                   wxCoord xoffset,
                                   wxCoord yoffset,
                                   wxPolygonFillMode fillStyle)
{
    m_xoffset = xoffset;
    m_yoffset = yoffset;
    m_fillStyle = fillStyle;

    m_points = new wxPointList;
    wxPointList::const_iterator iter;
    for (iter = points->begin(); iter != points->end(); ++iter)
    {
        // The first * gives us a wxPoint ptr, second * dereferences that ptr
        m_points->push_back(new wxPoint(**iter));
    }
}


pdcDrawPolygonOp::~pdcDrawPolygonOp()
{
    m_points->clear();
    delete m_points;
}


void pdcDrawPolygonOp::Translate(wxCoord dx, wxCoord dy)
{
    wxPointList::const_iterator iter;
    for (iter = m_points->begin(); iter != m_points->end(); iter++)
    {
        (*iter)->x += dx;
        (*iter)->y += dy;
    }
}

#if wxUSE_SPLINES
// ----------------------------------------------------------------------------
// pdcDrawSplineOp
// ----------------------------------------------------------------------------
pdcDrawSplineOp::pdcDrawSplineOp(const wxPointList* points)
{
    m_points = new wxPointList;
    wxPointList::const_iterator iter;
    for (iter = points->begin(); iter != points->end(); iter++)
    {
        // The first * gives us a wxPoint ptr, second * dereferences that ptr
        m_points->push_back(new wxPoint(**iter));
    }
}


pdcDrawSplineOp::~pdcDrawSplineOp()
{
    m_points->clear();
    delete m_points;
}


void pdcDrawSplineOp::Translate(wxCoord dx, wxCoord dy)
{
    wxPointList::const_iterator iter;
    for (iter = m_points->begin(); iter != m_points->end(); iter++)
    {
        (*iter)->x += dx;
        (*iter)->y += dy;
    }
}

#endif // wxUSE_SPLINES

// ============================================================================
// pdcObject implementation
// ============================================================================

// ----------------------------------------------------------------------------
// DrawToDC - play back the op list to the DC
// ----------------------------------------------------------------------------
void pdcObject::DrawToDC(wxDC *dc)
{
    pdcOpList::compatibility_iterator node = m_oplist.GetFirst();
    while(node)
    {
        node->GetData()->DrawToDC(dc, m_greyedout);
        node = node->GetNext();
    }
}

// ----------------------------------------------------------------------------
// Translate - translate all the operations by some dx,dy
// ----------------------------------------------------------------------------
void pdcObject::Translate(wxCoord dx, wxCoord dy)
{
    pdcOpList::compatibility_iterator node = m_oplist.GetFirst();
    while(node)
    {
        node->GetData()->Translate(dx,dy);
        node = node->GetNext();
    }
    if (m_bounded)
    {
        m_bounds.x += dx;
        m_bounds.y += dy;
    }
}

// ----------------------------------------------------------------------------
// SetGreyedOut - set the greyout member and cache grey versions of everything
// if greyout is true
// ----------------------------------------------------------------------------
void pdcObject::SetGreyedOut(bool greyout)
{
    m_greyedout=greyout;
    if (greyout)
    {
        pdcOpList::compatibility_iterator node = m_oplist.GetFirst();
        pdcOp *obj;
        while(node)
        {
            obj = node->GetData();
            obj->CacheGrey();
            node = node->GetNext();
        }
    }
}

// ============================================================================
// wxPseudoDC implementation
// ============================================================================

// ----------------------------------------------------------------------------
// Destructor
// ----------------------------------------------------------------------------
wxPseudoDC::~wxPseudoDC()
{
    // delete all the nodes in the list
    RemoveAll();

}

// ----------------------------------------------------------------------------
// ClearAll - remove all nodes from list
// ----------------------------------------------------------------------------
void wxPseudoDC::RemoveAll(void)
{
    m_objectlist.Clear();
    m_objectIndex.clear();
    m_currId = -1;
    m_lastObject = NULL;

}

// ----------------------------------------------------------------------------
// GetLen - return the number of operations in the current op list
// ----------------------------------------------------------------------------
int wxPseudoDC::GetLen(void)
{
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    int len=0;
    while (pt)
    {
        len += pt->GetData()->GetLen();
        pt = pt->GetNext();
    }
    return len;
}

// ----------------------------------------------------------------------------
// FindObject - find and return an object node by id.  If node doesn't exist
//               and create is true then create one and return it.  Otherwise
//               return NULL.
// ----------------------------------------------------------------------------
pdcObject *wxPseudoDC::FindObject(int id, bool create)
{
    // see if last operation was for same id
    //~ if (m_lastObject && m_lastObject->GetId() == id)
        //~ return m_lastObject;
    // if not then search for it
    pdcObjectHash::iterator lookup = m_objectIndex.find(id);
    if (lookup == m_objectIndex.end()) {//not found
        if (create) {
            m_lastObject = new pdcObject(id);
            m_objectlist.Append(m_lastObject);
            pdcObjectHash::value_type insert(id, m_lastObject);
            m_objectIndex.insert(insert);
            return m_lastObject;
        } else {
            return NULL;
        }
    } else { //found
        return lookup->second;
    }
}

// ----------------------------------------------------------------------------
// AddToList - Add a node to the list at the end (preserve draw order)
// ----------------------------------------------------------------------------
void wxPseudoDC::AddToList(pdcOp *newOp)
{
    pdcObject *obj = FindObject(m_currId, true);
    obj->AddOp(newOp);
}

// ----------------------------------------------------------------------------
// ClearID - remove all the operations associated with a single ID
// ----------------------------------------------------------------------------
void wxPseudoDC::ClearId(int id)
{
    pdcObject *obj = FindObject(id);
    if (obj) obj->Clear();
}

// ----------------------------------------------------------------------------
// RemoveID - Remove the object node (and all operations) associated with an id
// ----------------------------------------------------------------------------
void wxPseudoDC::RemoveId(int id)
{
    pdcObject *obj = FindObject(id);
    if (obj)
    {
        if (m_lastObject == obj)
            m_lastObject = obj;
        m_objectlist.DeleteObject(obj);
    }
    m_objectIndex.erase(id);
}

// ----------------------------------------------------------------------------
// SetIdBounds - Set the bounding rect for a given id
// ----------------------------------------------------------------------------
void wxPseudoDC::SetIdBounds(int id, wxRect& rect)
{
    pdcObject *obj = FindObject(id, true);
    obj->SetBounds(rect);
}

// ----------------------------------------------------------------------------
// GetIdBounds - Get the bounding rect for a given id
// ----------------------------------------------------------------------------
wxRect wxPseudoDC::GetIdBounds(int id)
{
    wxRect rect;

    pdcObject *obj = FindObject(id);
    if (obj && obj->IsBounded())
        rect = obj->GetBounds();
    else
        rect.x = rect.y = rect.width = rect.height = 0;
    return rect;
}

// ----------------------------------------------------------------------------
// TranslateId - Translate all the operations of a single id
// ----------------------------------------------------------------------------
void wxPseudoDC::TranslateId(int id, wxCoord dx, wxCoord dy)
{
    pdcObject *obj = FindObject(id);
    if (obj) obj->Translate(dx,dy);
}

// ----------------------------------------------------------------------------
// DrawIdToDC - Draw a specific id to the dc passed in
// ----------------------------------------------------------------------------
void wxPseudoDC::DrawIdToDC(int id, wxDC *dc)
{
    pdcObject *obj = FindObject(id);
    if (obj) obj->DrawToDC(dc);
}

// ----------------------------------------------------------------------------
// SetIdGreyedOut - Set the greyedout member of id
// ----------------------------------------------------------------------------
void wxPseudoDC::SetIdGreyedOut(int id, bool greyout)
{
    pdcObject *obj = FindObject(id);
    if (obj) obj->SetGreyedOut(greyout);
}

// ----------------------------------------------------------------------------
// GetIdGreyedOut - Get the greyedout member of id
// ----------------------------------------------------------------------------
bool wxPseudoDC::GetIdGreyedOut(int id)
{
    pdcObject *obj = FindObject(id);
    if (obj) return obj->GetGreyedOut();
    else return false;
}

// ----------------------------------------------------------------------------
// FindObjectsByBBox - Return a list of all the ids whose bounding boxes
//                     contain (x,y)
// ----------------------------------------------------------------------------
PyObject *wxPseudoDC::FindObjectsByBBox(wxCoord x, wxCoord y)
{
    wxPyThreadBlocker blocker;
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    pdcObject *obj;
    PyObject* pyList = NULL;
    pyList = PyList_New(0);
    wxRect r;
    while (pt)
    {
        obj = pt->GetData();
        r = obj->GetBounds();
        if (obj->IsBounded() && r.Contains(x,y))
        {
            PyObject* pyObj = wxPyInt_FromLong((long)obj->GetId());
            PyList_Insert(pyList, 0, pyObj);
            Py_DECREF(pyObj);
        }
        pt = pt->GetNext();
    }
    return pyList;
}

// ----------------------------------------------------------------------------
// FindObjects - Return a list of all the ids that draw to (x,y)
// ----------------------------------------------------------------------------
PyObject *wxPseudoDC::FindObjects(wxCoord x, wxCoord y,
                                  wxCoord radius, const wxColor& bg)
{
    wxPyThreadBlocker blocker;
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    pdcObject *obj;
    PyObject* pyList = NULL;
    pyList = PyList_New(0);
    wxBrush bgbrush(bg);
    wxPen bgpen(bg);
    // special case radius = 0
    if (radius == 0)
    {
        wxBitmap bmp(4,4,24);
        wxMemoryDC memdc;
        wxColor pix;
        wxRect viewrect(x-2,y-2,4,4);
        // setup the memdc for rendering
        memdc.SelectObject(bmp);
        memdc.SetBackground(bgbrush);
        memdc.Clear();
        memdc.SetDeviceOrigin(2-x,2-y);
        while (pt)
        {
            obj = pt->GetData();
            if (obj->IsBounded() && obj->GetBounds().Contains(x,y))
            {
                // start clean
                memdc.SetBrush(bgbrush);
                memdc.SetPen(bgpen);
                memdc.DrawRectangle(viewrect);
                // draw the object
                obj->DrawToDC(&memdc);
                memdc.GetPixel(x,y,&pix);
                // clear and update rgn2
                if (pix != bg)
                {
                    PyObject* pyObj = wxPyInt_FromLong((long)obj->GetId());
                    PyList_Insert(pyList, 0, pyObj);
                    Py_DECREF(pyObj);
                }
            }
            pt = pt->GetNext();
        }
        memdc.SelectObject(wxNullBitmap);
    }
    else
    {
        wxRect viewrect(x-radius,y-radius,2*radius,2*radius);
        wxBitmap maskbmp(2*radius,2*radius,24);
        wxMemoryDC maskdc;
        // create bitmap with circle for masking
        maskdc.SelectObject(maskbmp);
        maskdc.SetBackground(*wxBLACK_BRUSH);
        maskdc.Clear();
        maskdc.SetBrush(*wxWHITE_BRUSH);
        maskdc.SetPen(*wxWHITE_PEN);
        maskdc.DrawCircle(radius,radius,radius);
        // now setup a memdc for rendering our object
        wxBitmap bmp(2*radius,2*radius,24);
        wxMemoryDC memdc;
        memdc.SelectObject(bmp);
        // set the origin so (x,y) is in the bmp center
        memdc.SetDeviceOrigin(radius-x,radius-y);
        // a region will be used to see if the result is empty
        wxRegion rgn2;
        while (pt)
        {
            obj = pt->GetData();
            if (obj->IsBounded() && viewrect.Intersects(obj->GetBounds()))
            {
                // start clean
                //memdc.Clear();
                memdc.SetBrush(bgbrush);
                memdc.SetPen(bgpen);
                memdc.DrawRectangle(viewrect);
                // draw the object
                obj->DrawToDC(&memdc);
                // remove background color
                memdc.SetLogicalFunction(wxXOR);
                memdc.SetBrush(bgbrush);
                memdc.SetPen(bgpen);
                memdc.DrawRectangle(viewrect);
                memdc.SetLogicalFunction(wxCOPY);
                memdc.Blit(x-radius,y-radius,2*radius,2*radius,&maskdc,0,0,wxCOPY);
                // clear and update rgn2
                memdc.SelectObject(wxNullBitmap);
                rgn2.Clear();
                rgn2.Union(bmp, *wxBLACK);
                //rgn2.Intersect(rgn);
                memdc.SelectObject(bmp);
                if (!rgn2.IsEmpty())
                {
                    PyObject* pyObj = wxPyInt_FromLong((long)obj->GetId());
                    PyList_Insert(pyList, 0, pyObj);
                    Py_DECREF(pyObj);
                }
            }
            pt = pt->GetNext();
        }
        maskdc.SelectObject(wxNullBitmap);
        memdc.SelectObject(wxNullBitmap);
    }
     return pyList;
}

// ----------------------------------------------------------------------------
// DrawToDCClipped - play back the op list to the DC but clip any objects
//                   known to be not in rect.  This is a coarse level of
//                   clipping to speed things up when lots of objects are off
//                   screen and doesn't affect the dc level clipping
// ----------------------------------------------------------------------------
void wxPseudoDC::DrawToDCClipped(wxDC *dc, const wxRect& rect)
{
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    pdcObject *obj;
    while (pt)
    {
        obj = pt->GetData();
        if (!obj->IsBounded() || rect.Intersects(obj->GetBounds()))
            obj->DrawToDC(dc);
        pt = pt->GetNext();
    }
}
void wxPseudoDC::DrawToDCClippedRgn(wxDC *dc, const wxRegion& region)
{
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    pdcObject *obj;
    while (pt)
    {
        obj = pt->GetData();
        if (!obj->IsBounded() ||
            (region.Contains(obj->GetBounds()) != wxOutRegion))
            obj->DrawToDC(dc);
        pt = pt->GetNext();
    }
}

// ----------------------------------------------------------------------------
// DrawToDC - play back the op list to the DC
// ----------------------------------------------------------------------------
void wxPseudoDC::DrawToDC(wxDC *dc)
{
    pdcObjectList::compatibility_iterator pt = m_objectlist.GetFirst();
    while (pt)
    {
        pt->GetData()->DrawToDC(dc);
        pt = pt->GetNext();
    }
}


%End

//---------------------------------------------------------------------------

class wxPseudoDC : wxObject
{
    %Docstring
        PseudoDC()
        
        A PseudoDC is an object that can be used much like real
        :class:`wx.DC`, however it provides some additional features for
        object recording and manipulation beyond what a ``wx.DC`` can
        provide.
        
        All commands issued to the ``PseudoDC`` are stored in a list.  You
        can then play these commands back to a real DC object as often as
        needed, using the :meth:`DrawToDC` method or one of the similar
        methods.  Commands in the command list can be tagged by an ID. You
        can use this ID to clear the operations associated with a single
        ID, redraw the objects associated with that ID, grey them, adjust
        their position, etc.
    %End
public:
    wxPseudoDC();

    ~wxPseudoDC();

    void RemoveAll();
    %Docstring
        RemoveAll()
        
        Removes all objects and operations from the recorded list.
    %End

    int GetLen();
    %Docstring
        GetLen() -> int
        
        Returns the number of operations in the recorded list.
    %End

    void SetId(
        int id
    );
    %Docstring
        SetId(id)
        
        Sets the id to be associated with subsequent operations.
    %End

    void ClearId(
        int id
    );
    %Docstring
        ClearId(id)
        
        Removes all operations associated with id so the object can be
        redrawn.
    %End

    void RemoveId(
        int id
    );
    %Docstring
        RemoveId(id)
        
        Remove the object node (and all operations) associated with an id.
    %End

    void TranslateId(
        int id,
        wxCoord dx,
        wxCoord dy
    );
    %Docstring
        TranslateId(id, dx, dy)
        
        Translate the position of the operations of tag `id` by (`dx`, `dy`).
    %End

    void SetIdGreyedOut(
        int id,
        bool greyout
    );
    %Docstring
        SetIdGreyedOut(id, greyout)
        
        Set whether the set of objects with tag `id` are drawn greyed out or
        not.
    %End

    bool GetIdGreyedOut(
        int id
    );
    %Docstring
        GetIdGreyedOut(id) -> bool
        
        Get whether the set of objects with tag `id` are drawn greyed out or
        not.
    %End

    PyObject* FindObjects(
        wxCoord x,
        wxCoord y,
        wxCoord radius = 1,
        const wxColour & bg = *wxWHITE
    );
    %Docstring
        FindObjects(x, y, radius=1, bg=wx.WHITE) -> PyObject
        
        Returns a list of all the id's that draw a pixel with
        color not equal to bg within radius of (x,y). Returns an
        empty list if nothing is found.  The list is in reverse
        drawing order so list[0] is the top id.
    %End

    PyObject* FindObjectsByBBox(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        FindObjectsByBBox(x, y) -> PyObject
        
        Returns a list of all the id's whose bounding boxes include (x,y).
        Returns an empty list if nothing is found.  The list is in
        reverse drawing order so list[0] is the top id.
    %End

    void DrawIdToDC(
        int id,
        wxDC * dc
    );
    %Docstring
        DrawIdToDC(id, dc)
        
        Draw recorded operations tagged with id to dc.
    %End

    void SetIdBounds(
        int id,
        wxRect & rect
    );
    %Docstring
        SetIdBounds(id, rect)
        
        Set the bounding rect of a given object.
        This will create an object node if one doesn't exist.
    %End

    wxRect GetIdBounds(
        int id
    );
    %Docstring
        GetIdBounds(id) -> wx.Rect
        
        Returns the bounding rectangle previously set with `SetIdBounds`.
        If no bounds have been set, it returns wx.Rect(0,0,0,0).
    %End

    void DrawToDCClipped(
        wxDC * dc,
        const wxRect & rect
    );
    %Docstring
        DrawToDCClipped(dc, rect)
        
        Draws the recorded operations to dc,
        unless the operation is known to be outside of rect.
    %End

    void DrawToDCClippedRgn(
        wxDC * dc,
        const wxRegion & region
    );
    %Docstring
        DrawToDCClippedRgn(dc, region)
        
        Draws the recorded operations to dc,
        unless the operation is known to be outside the given region.
    %End

    void DrawToDC(
        wxDC * dc
    );
    %Docstring
        DrawToDC(dc)
        
        Draws the recorded operations to dc.
    %End

    void FloodFill(
        wxCoord x,
        wxCoord y,
        const wxColour & col,
        wxFloodFillStyle style = wxFLOOD_SURFACE
    );
    %Docstring
        FloodFill(x, y, col, style=wx.FLOOD_SURFACE)
        FloodFill(pt, col, style=wx.FLOOD_SURFACE)
        
        Flood fills the device context starting from the given point,
        using the current brush colour, and using a style:
        
            - ``wx.FLOOD_SURFACE``: the flooding occurs until a colour other
        than the given colour is encountered.
        
            - ``wx.FLOOD_BORDER``: the area to be flooded is bounded by the
        given colour.
    %End

    void FloodFill(
        const wxPoint & pt,
        const wxColour & col,
        wxFloodFillStyle style = wxFLOOD_SURFACE
    );

    void DrawLine(
        wxCoord x1,
        wxCoord y1,
        wxCoord x2,
        wxCoord y2
    );
    %Docstring
        DrawLine(x1, y1, x2, y2)
        DrawLine(pt1, pt2)
        
        Draws a line from the first point to the second.
        The current pen is used for drawing the line. Note that
        the second point is *not* part of the line and is not
        drawn by this function (this is consistent with the
        behaviour of many other toolkits).
    %End

    void DrawLine(
        const wxPoint & pt1,
        const wxPoint & pt2
    );

    void CrossHair(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        CrossHair(x, y)
        CrossHair(pt)
        
        Displays a cross hair using the current pen. This is a
        vertical and horizontal line the height and width of the
        window, centred on the given point.
    %End

    void CrossHair(
        const wxPoint & pt
    );

    void DrawArc(
        wxCoord x1,
        wxCoord y1,
        wxCoord x2,
        wxCoord y2,
        wxCoord xc,
        wxCoord yc
    );
    %Docstring
        DrawArc(x1, y1, x2, y2, xc, yc)
        
        Draws an arc of a circle, centred on the *center* point
        (xc, yc), from the first point to the second. The current
        pen is used for the outline and the current brush for
        filling the shape.
        
        The arc is drawn in an anticlockwise direction from the
        start point to the end point.
    %End

    void DrawCheckMark(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawCheckMark(x, y, width, height)
        DrawCheckMark(rect)
        
        Draws a check mark inside the given rectangle
    %End

    void DrawCheckMark(
        const wxRect & rect
    );

    void DrawEllipticArc(
        wxCoord x,
        wxCoord y,
        wxCoord w,
        wxCoord h,
        double start,
        double end
    );
    %Docstring
        DrawEllipticArc(x, y, w, h, start, end)
        DrawEllipticArc(pt, sz, start, end)
        
        Draws an arc of an ellipse, with the given rectangle
        defining the bounds of the ellipse. The current pen is
        used for drawing the arc and the current brush is used for
        drawing the pie.
        
        The *start* and *end* parameters specify the start and end
        of the arc relative to the three-o'clock position from the
        center of the rectangle. Angles are specified in degrees
        (360 is a complete circle). Positive values mean
        counter-clockwise motion. If start is equal to end, a
        complete ellipse will be drawn.
    %End

    void DrawEllipticArc(
        const wxPoint & pt,
        const wxSize & sz,
        double start,
        double end
    );

    void DrawPoint(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawPoint(x, y)
        DrawPoint(pt)
        
        Draws a point using the current pen.
    %End

    void DrawPoint(
        const wxPoint & pt
    );

    void DrawRectangle(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawRectangle(x, y, width, height)
        DrawRectangle(rect)
        DrawRectangle(pt, sz)
        
        Draws a rectangle with the given top left corner, and with
        the given size. The current pen is used for the outline
        and the current brush for filling the shape.
    %End

    void DrawRectangle(
        const wxRect & rect
    );

    void DrawRectangle(
        const wxPoint & pt,
        const wxSize & sz
    );

    void DrawRoundedRectangle(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height,
        double radius
    );
    %Docstring
        DrawRoundedRectangle(x, y, width, height, radius)
        DrawRoundedRectangle(rect, radius)
        DrawRoundedRectangle(pt, sz, radius)
        
        Draws a rectangle with the given top left corner, and with
        the given size. The current pen is used for the outline
        and the current brush for filling the shape.
    %End

    void DrawRoundedRectangle(
        const wxRect & rect,
        double radius
    );

    void DrawRoundedRectangle(
        const wxPoint & pt,
        const wxSize & sz,
        double radius
    );

    void DrawCircle(
        wxCoord x,
        wxCoord y,
        wxCoord radius
    );
    %Docstring
        DrawCircle(x, y, radius)
        DrawCircle(pt, radius)
        
        Draws a circle with the given center point and radius.
        The current pen is used for the outline and the current
        brush for filling the shape.
        
        :see: `DrawEllipse`
    %End

    void DrawCircle(
        const wxPoint & pt,
        wxCoord radius
    );

    void DrawEllipse(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawEllipse(x, y, width, height)
        DrawEllipse(rect)
        DrawEllipse(pt, sz)
        
        Draws an ellipse contained in the specified rectangle. The current pen
        is used for the outline and the current brush for filling the shape.",
        "
        
        :see: `DrawCircle`
    %End

    void DrawEllipse(
        const wxRect & rect
    );

    void DrawEllipse(
        const wxPoint & pt,
        const wxSize & sz
    );

    void DrawIcon(
        const wxIcon & icon,
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawIcon(icon, x, y)
        DrawIcon(icon, pt)
        
        Draw an icon on the display at the given position.
    %End

    void DrawIcon(
        const wxIcon & icon,
        const wxPoint & pt
    );

    void DrawBitmap(
        const wxBitmap & bmp,
        wxCoord x,
        wxCoord y,
        bool useMask = false
    );
    %Docstring
        DrawBitmap(bmp, x, y, useMask=False)
        DrawBitmap(bmp, pt, useMask=False)
        
        Draw a bitmap on the device context at the specified
        point. If *useMask* is true and the bitmap has a
        transparency mask, (or alpha channel on the platforms that
        support it) then the bitmap will be drawn transparently.
        
        When drawing a mono-bitmap, the current text foreground
        colour will be used to draw the foreground of the bitmap
        (all bits set to 1), and the current text background
        colour to draw the background (all bits set to 0).
        
        :see: `SetTextForeground`, `SetTextBackground` and `wx.MemoryDC`
    %End

    void DrawBitmap(
        const wxBitmap & bmp,
        const wxPoint & pt,
        bool useMask = false
    );

    void DrawText(
        const wxString & text,
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawText(text, x, y)
        DrawText(text, pt)
        
        Draws a text string at the specified point, using the
        current text font, and the current text foreground and
        background colours.
        
        The coordinates refer to the top-left corner of the
        rectangle bounding the string. See `wx.DC.GetTextExtent`
        for how to get the dimensions of a text string, which can
        be used to position the text more precisely, (you will
        need to use a real DC with GetTextExtent as wx.PseudoDC
        does not implement it.)
        
        **NOTE**: under wxGTK the current logical function is used
        *by this function but it is ignored by wxMSW. Thus, you
        *should avoid using logical functions with this function
        *in portable programs.", "
        
        :see: `DrawRotatedText`
    %End

    void DrawText(
        const wxString & text,
        const wxPoint & pt
    );

    void DrawRotatedText(
        const wxString & text,
        wxCoord x,
        wxCoord y,
        double angle
    );
    %Docstring
        DrawRotatedText(text, x, y, angle)
        DrawRotatedText(text, pt, angle)
        
        Draws the text rotated by *angle* degrees, if supported by the
        platform.
    %End

    void DrawRotatedText(
        const wxString & text,
        const wxPoint & pt,
        double angle
    );

    void DrawLabel(
        const wxString & text,
        const wxRect & rect,
        int alignment = wxALIGN_LEFT|wxALIGN_TOP,
        int indexAccel = -1
    );
    %Docstring
        DrawLabel(text, rect, alignment=wx.ALIGN_LEFT|wx.ALIGN_TOP, indexAccel=-1)
        DrawLabel(text, image, rect, alignment=wx.ALIGN_LEFT|wx.ALIGN_TOP, indexAccel=-1)
        
        Draw *text* within the specified rectangle, abiding by the
        alignment flags.  Will additionally emphasize the
        character at *indexAccel* if it is not -1.
    %End

    void DrawLabel(
        const wxString & text,
        const wxBitmap & image,
        const wxRect & rect,
        int alignment = wxALIGN_LEFT|wxALIGN_TOP,
        int indexAccel = -1
    );

    void Clear();
    %Docstring
        Clear()
        
        Clears the device context using the current background brush.
    %End

    void SetFont(
        const wxFont & font
    );
    %Docstring
        SetFont(font)
        
        Sets the current font for the DC. It must be a valid font, in
        particular you should not pass ``wx.NullFont`` to this method.
        
        :see: `wx.Font`
    %End

    void SetPen(
        const wxPen & pen
    );
    %Docstring
        SetPen(pen)
        
        Sets the current pen for the DC.
        
        If the argument is ``wx.NullPen``, the current pen is selected out of
        the
        device context, and the original pen restored.
        
        :see: `wx.Pen`
    %End

    void SetBrush(
        const wxBrush & brush
    );
    %Docstring
        SetBrush(brush)
        
        Sets the current brush for the DC.
        
        If the argument is ``wx.NullBrush``, the current brush is selected out
        of the device context, and the original brush restored, allowing the
        current brush to be destroyed safely.
        
        :see: `wx.Brush`
    %End

    void SetBackground(
        const wxBrush & brush
    );
    %Docstring
        SetBackground(brush)
        
        Sets the current background brush for the DC.
    %End

    void SetBackgroundMode(
        int mode
    );
    %Docstring
        SetBackgroundMode(mode)
        
        The *mode* parameter may be one of ``wx.SOLID`` and
        ``wx.TRANSPARENT``. This setting determines whether text
        will be drawn with a background colour or not.
    %End

    void SetTextForeground(
        const wxColour & colour
    );
    %Docstring
        SetTextForeground(colour)
        
        Sets the current text foreground colour for the DC.
    %End

    void SetTextBackground(
        const wxColour& colour
    );
    %Docstring
        SetTextBackground(colour)
        
        Sets the current text background colour for the DC.
    %End

    void SetLogicalFunction(
        wxRasterOperationMode function
    );
    %Docstring
        SetLogicalFunction(function)
        
        Sets the current logical function for the device context. This
        determines how a source pixel (from a pen or brush colour, combines
        with a destination pixel in the current device context.
        
        The possible values and their meaning in terms of source and
        destination pixel values are defined in the
        :ref:`wx.RasterOperationMode`
        enumeration.
        
        The default is wx.COPY, which simply draws with the current
        colour. The others combine the current colour and the background using
        a logical operation. wx.INVERT is commonly used for drawing rubber
        bands or moving outlines, since drawing twice reverts to the original
        colour.
    %End

    void DrawLines(
        const wxPointList * points,
        wxCoord xoffset = 0,
        wxCoord yoffset = 0
    );
    %Docstring
        DrawLines(points, xoffset=0, yoffset=0)
        
        Draws lines using a sequence of `wx.Point` objects, adding the
        optional offset coordinate. The current pen is used for drawing the
        lines.
    %End

    void DrawPolygon(
        const wxPointList * points,
        wxCoord xoffset = 0,
        wxCoord yoffset = 0,
        wxPolygonFillMode fillStyle = wxODDEVEN_RULE
    );
    %Docstring
        DrawPolygon(points, xoffset=0, yoffset=0, fillStyle=wx.ODDEVEN_RULE)
        
        Draws a filled polygon using a sequence of `wx.Point` objects, adding
        the optional offset coordinate.  The last argument specifies the fill
        rule: ``wx.ODDEVEN_RULE`` (the default) or ``wx.WINDING_RULE``.
        
        The current pen is used for drawing the outline, and the current brush
        for filling the shape. Using a transparent brush suppresses
        filling. Note that wxWidgets automatically closes the first and last
        points.
    %End

    void DrawSpline(
        const wxPointList * points
    );
    %Docstring
        DrawSpline(points)
        
        Draws a spline between all given control points, (a list of `wx.Point`
        objects) using the current pen. The spline is drawn using a series of
        lines, using an algorithm taken from the X drawing program 'XFIG'.
    %End

    public:


    %Property(name=Len, get=GetLen)
};  // end of class wxPseudoDC


%Extract(id=pycode_adv)
PseudoDC.BeginDrawing = wx.deprecated(lambda *args: None, 'BeginDrawing has been removed.')
PseudoDC.EndDrawing = wx.deprecated(lambda *args: None, 'EndDrawing has been removed.')
PseudoDC.FloodFillPoint = wx.deprecated(PseudoDC.FloodFill, 'Use FloodFill instead.')
PseudoDC.DrawLinePoint = wx.deprecated(PseudoDC.DrawLine, 'Use DrawLine instead.')
PseudoDC.CrossHairPoint = wx.deprecated(PseudoDC.CrossHair, 'Use CrossHair instead.')
PseudoDC.DrawArcPoint = wx.deprecated(PseudoDC.DrawArc, 'Use DrawArc instead.')
PseudoDC.DrawCheckMarkRect = wx.deprecated(PseudoDC.DrawCheckMark, 'Use DrawArc instead.')
PseudoDC.DrawEllipticArcPointSize = wx.deprecated(PseudoDC.DrawEllipticArc, 'Use DrawEllipticArc instead.')
PseudoDC.DrawPointPoint = wx.deprecated(PseudoDC.DrawPoint, 'Use DrawPoint instead.')
PseudoDC.DrawRectangleRect = wx.deprecated(PseudoDC.DrawRectangle, 'Use DrawRectangle instead.')
PseudoDC.DrawRectanglePointSize = wx.deprecated(PseudoDC.DrawRectangle, 'Use DrawRectangle instead.')
PseudoDC.DrawRoundedRectangleRect = wx.deprecated(PseudoDC.DrawRoundedRectangle, 'Use DrawRectangle instead.')
PseudoDC.DrawRoundedRectanglePointSize = wx.deprecated(PseudoDC.DrawRoundedRectangle, 'Use DrawRectangle instead.')
PseudoDC.DrawCirclePoint = wx.deprecated(PseudoDC.DrawCircle, 'Use DrawCircle instead.')
PseudoDC.DrawEllipseRect = wx.deprecated(PseudoDC.DrawEllipse, 'Use DrawEllipse instead.')
PseudoDC.DrawEllipsePointSize = wx.deprecated(PseudoDC.DrawEllipse, 'Use DrawEllipse instead.')
PseudoDC.DrawIconPoint = wx.deprecated(PseudoDC.DrawIcon, 'Use DrawIcon instead.')
PseudoDC.DrawBitmapPoint = wx.deprecated(PseudoDC.DrawBitmap, 'Use DrawBitmap instead.')
PseudoDC.DrawTextPoint = wx.deprecated(PseudoDC.DrawText, 'Use DrawText instead.')
PseudoDC.DrawRotatedTextPoint = wx.deprecated(PseudoDC.DrawRotatedText, 'Use DrawRotatedText instead.')
PseudoDC.DrawImageLabel = wx.deprecated(PseudoDC.DrawLabel, 'Use DrawLabel instead.')

%End


//---------------------------------------------------------------------------

