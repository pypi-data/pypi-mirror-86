//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------
%ModuleCode
    #if !defined(__WXMAC__)
    #define wxCURSOR_COPY_ARROW wxCURSOR_ARROW
    #endif
    
%End

//---------------------------------------------------------------------------

enum wxBitmapType
{
    wxBITMAP_TYPE_INVALID,
    wxBITMAP_TYPE_BMP,
    wxBITMAP_TYPE_ICO,
    wxBITMAP_TYPE_CUR,
    wxBITMAP_TYPE_XBM,
    wxBITMAP_TYPE_XBM_DATA,
    wxBITMAP_TYPE_XPM,
    wxBITMAP_TYPE_XPM_DATA,
    wxBITMAP_TYPE_TIFF,
    wxBITMAP_TYPE_TIF,
    wxBITMAP_TYPE_GIF,
    wxBITMAP_TYPE_PNG,
    wxBITMAP_TYPE_JPEG,
    wxBITMAP_TYPE_PNM,
    wxBITMAP_TYPE_PCX,
    wxBITMAP_TYPE_PICT,
    wxBITMAP_TYPE_ICON,
    wxBITMAP_TYPE_ANI,
    wxBITMAP_TYPE_IFF,
    wxBITMAP_TYPE_TGA,
    wxBITMAP_TYPE_MACCURSOR,
    wxBITMAP_TYPE_ANY
};

enum wxPolygonFillMode
{
    wxODDEVEN_RULE,
    wxWINDING_RULE
};

enum wxStockCursor
{
    wxCURSOR_NONE,
    wxCURSOR_ARROW,
    wxCURSOR_RIGHT_ARROW,
    wxCURSOR_BULLSEYE,
    wxCURSOR_CHAR,
    wxCURSOR_CROSS,
    wxCURSOR_HAND,
    wxCURSOR_IBEAM,
    wxCURSOR_LEFT_BUTTON,
    wxCURSOR_MAGNIFIER,
    wxCURSOR_MIDDLE_BUTTON,
    wxCURSOR_NO_ENTRY,
    wxCURSOR_PAINT_BRUSH,
    wxCURSOR_PENCIL,
    wxCURSOR_POINT_LEFT,
    wxCURSOR_POINT_RIGHT,
    wxCURSOR_QUESTION_ARROW,
    wxCURSOR_RIGHT_BUTTON,
    wxCURSOR_SIZENESW,
    wxCURSOR_SIZENS,
    wxCURSOR_SIZENWSE,
    wxCURSOR_SIZEWE,
    wxCURSOR_SIZING,
    wxCURSOR_SPRAYCAN,
    wxCURSOR_WAIT,
    wxCURSOR_WATCH,
    wxCURSOR_BLANK,
    wxCURSOR_DEFAULT,
    wxCURSOR_COPY_ARROW,
    wxCURSOR_ARROWWAIT,
    wxCURSOR_MAX
};

enum wxEllipsizeFlags
{
    wxELLIPSIZE_FLAGS_NONE,
    wxELLIPSIZE_FLAGS_PROCESS_MNEMONICS,
    wxELLIPSIZE_FLAGS_EXPAND_TABS,
    wxELLIPSIZE_FLAGS_DEFAULT
};

enum wxEllipsizeMode
{
    wxELLIPSIZE_NONE,
    wxELLIPSIZE_START,
    wxELLIPSIZE_MIDDLE,
    wxELLIPSIZE_END
};

class wxPoint
{
    %Docstring
        Point()
        Point(x, y)
        Point(pt)
        
        A wxPoint is a useful data structure for graphics operations.
    %End
    %TypeHeaderCode
        #include <wx/gdicmn.h>
    %End

public:
    wxPoint();

    wxPoint(
        int x,
        int y
    );

    wxPoint(
        const wxRealPoint & pt
    );

    wxPoint & operator+=(
        const wxSize & sz
    );

    wxPoint & operator+=(
        const wxPoint & pt
    );

    wxPoint & operator-=(
        const wxSize & sz
    );

    wxPoint & operator-=(
        const wxPoint & pt
    );

    bool IsFullySpecified() const;
    %Docstring
        IsFullySpecified() -> bool
        
        Returns true if neither of the point components is equal to
        wxDefaultCoord.
    %End

    void SetDefaults(
        const wxPoint & pt
    );
    %Docstring
        SetDefaults(pt)
        
        Combine this object with another one replacing the uninitialized
        values.
    %End

    int x;

    int y;

    public:


    bool __eq__(const wxPoint& other);
    %Docstring
        __eq__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxPoint___eq__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxPoint___eq__(wxPoint* self, const wxPoint* other)
    {
        return *self == *other;
    }
    %End

    bool __ne__(const wxPoint& other);
    %Docstring
        __ne__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxPoint___ne__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxPoint___ne__(wxPoint* self, const wxPoint* other)
    {
        return *self != *other;
    }
    %End

            wxPoint operator+(const wxPoint& other);
            wxPoint operator+(const wxSize& other);
            wxPoint operator-();
            wxPoint operator-(const wxPoint& other);
            wxPoint operator-(const wxSize& other);
            wxPoint operator*(double d);
            wxPoint operator/(int i);


    PyObject* Get();
    %Docstring
        Get() -> (x,y)
        
        Return the x and y properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxPoint_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxPoint_Get(wxPoint* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(ii)", self->x, self->y);
    }
    %End

    public:


    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxPoint?
            if (sipCanConvertToType(sipPy, sipType_wxPoint, SIP_NO_CONVERTORS))
                return 1;
        
            if (wxPyNumberSequenceCheck(sipPy, 2)) {
                return 1;
            }
            return 0;
        }
        
         // otherwise do the conversion
         if (sipCanConvertToType(sipPy, sipType_wxPoint, SIP_NO_CONVERTORS)) {
             // Just fetch the existing instance
             *sipCppPtr = reinterpret_cast<wxPoint*>(sipConvertToType(
                     sipPy, sipType_wxPoint, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
             return 0;  // not a new instance
         }
        
         // or create a new instance
         PyObject* o1 = PySequence_ITEM(sipPy, 0);
         PyObject* o2 = PySequence_ITEM(sipPy, 1);
         *sipCppPtr = new wxPoint(wxPyInt_AsLong(o1), wxPyInt_AsLong(o2));
         Py_DECREF(o1);
         Py_DECREF(o2);
         return SIP_TEMPORARY;
    %End
};  // end of class wxPoint


%Extract(id=pycode_core)
def _Point_GetIM(self):
    """
    Returns an immutable representation of the ``wx.Point`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.Point``
    with a simple statement like this: ``obj = wx.Point(imObj)``.
    """
    return _im_Point(*self.Get())
Point.GetIM = _Point_GetIM
del _Point_GetIM
%End

%Extract(id=pycode_core)
def _Point___str__(self):
    return str(self.Get())
Point.__str__ = _Point___str__
del _Point___str__
%End

%Extract(id=pycode_core)
def _Point___repr__(self):
    return "wx.Point"+str(self.Get())
Point.__repr__ = _Point___repr__
del _Point___repr__
%End

%Extract(id=pycode_core)
def _Point___len__(self):
    return len(self.Get())
Point.__len__ = _Point___len__
del _Point___len__
%End

%Extract(id=pycode_core)
def _Point___reduce__(self):
    return (Point, self.Get())
Point.__reduce__ = _Point___reduce__
del _Point___reduce__
%End

%Extract(id=pycode_core)
def _Point___getitem__(self, idx):
    return self.Get()[idx]
Point.__getitem__ = _Point___getitem__
del _Point___getitem__
%End

%Extract(id=pycode_core)
def _Point___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    else: raise IndexError
Point.__setitem__ = _Point___setitem__
del _Point___setitem__
%End

%Extract(id=pycode_core)
Point.__safe_for_unpickling__ = True

%End

%Extract(id=pycode_core)
Point.IM = property(Point.GetIM)
%End

class wxSize
{
    %Docstring
        Size()
        Size(width, height)
        
        A wxSize is a useful data structure for graphics operations.
    %End
    %TypeHeaderCode
        #include <wx/gdicmn.h>
    %End

public:
    wxSize();

    wxSize(
        int width,
        int height
    );

    void DecBy(
        const wxPoint & pt
    );
    %Docstring
        DecBy(pt)
        DecBy(size)
        DecBy(dx, dy)
        DecBy(d)
        
        Decreases the size in both x and y directions.
    %End

    void DecBy(
        const wxSize & size
    );

    void DecBy(
        int dx,
        int dy
    );

    void DecBy(
        int d
    );

    void IncBy(
        const wxPoint & pt
    );
    %Docstring
        IncBy(pt)
        IncBy(size)
        IncBy(dx, dy)
        IncBy(d)
        
        Increases the size in both x and y directions.
    %End

    void IncBy(
        const wxSize & size
    );

    void IncBy(
        int dx,
        int dy
    );

    void IncBy(
        int d
    );

    wxSize & operator+=(
        const wxSize & sz
    );

    wxSize & operator-=(
        const wxSize & sz
    );

    wxSize & operator/=(
        int factor
    );

    wxSize & operator*=(
        int factor
    );

    void DecTo(
        const wxSize & size
    );
    %Docstring
        DecTo(size)
        
        Decrements this object so that both of its dimensions are not greater
        than the corresponding dimensions of the size.
    %End

    void DecToIfSpecified(
        const wxSize & size
    );
    %Docstring
        DecToIfSpecified(size)
        
        Decrements this object to be not bigger than the given size ignoring
        non-specified components.
    %End

    int GetHeight() const;
    %Docstring
        GetHeight() -> int
        
        Gets the height member.
    %End

    int GetWidth() const;
    %Docstring
        GetWidth() -> int
        
        Gets the width member.
    %End

    void IncTo(
        const wxSize & size
    );
    %Docstring
        IncTo(size)
        
        Increments this object so that both of its dimensions are not less
        than the corresponding dimensions of the size.
    %End

    bool IsFullySpecified() const;
    %Docstring
        IsFullySpecified() -> bool
        
        Returns true if neither of the size object components is equal to -1,
        which is used as default for the size values in wxWidgets (hence the
        predefined wxDefaultSize has both of its components equal to -1).
    %End

    wxSize & Scale(
        double xscale,
        double yscale
    );
    %Docstring
        Scale(xscale, yscale) -> Size
        
        Scales the dimensions of this object by the given factors.
    %End

    void Set(
        int width,
        int height
    );
    %Docstring
        Set(width, height)
        
        Sets the width and height members.
    %End

    void SetDefaults(
        const wxSize & sizeDefault
    );
    %Docstring
        SetDefaults(sizeDefault)
        
        Combine this size object with another one replacing the default (i.e.
        equal to -1) components of this object with those of the other.
    %End

    void SetHeight(
        int height
    );
    %Docstring
        SetHeight(height)
        
        Sets the height.
    %End

    void SetWidth(
        int width
    );
    %Docstring
        SetWidth(width)
        
        Sets the width.
    %End

    public:


    %Property(name=Height, get=GetHeight, set=SetHeight)
    %Property(name=Width, get=GetWidth, set=SetWidth)
    %Property(name=width, get=GetWidth, set=SetWidth)
    %Property(name=height, get=GetHeight, set=SetHeight)
    %Property(name=x, get=GetWidth, set=SetWidth)
    %Property(name=y, get=GetHeight, set=SetHeight)
    bool __eq__(const wxSize& other);
    %Docstring
        __eq__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSize___eq__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxSize___eq__(wxSize* self, const wxSize* other)
    {
        return *self == *other;
    }
    %End

    bool __ne__(const wxSize& other);
    %Docstring
        __ne__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSize___ne__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxSize___ne__(wxSize* self, const wxSize* other)
    {
        return *self != *other;
    }
    %End

            wxSize operator+(const wxSize& other);
            wxSize operator-(const wxSize& other);
            wxSize operator*(double d);
            wxSize operator/(int i);
    
            wxPoint operator+(const wxPoint& other);
            wxPoint operator-(const wxPoint& other);
            wxRealPoint operator+(const wxRealPoint& other);
            wxRealPoint operator-(const wxRealPoint& other);


    PyObject* Get();
    %Docstring
        Get() -> (width, height)
        
        Return the width and height properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSize_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxSize_Get(wxSize* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(ii)", self->GetWidth(), self->GetHeight());
    }
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxSize?
            if (sipCanConvertToType(sipPy, sipType_wxSize, SIP_NO_CONVERTORS))
                return 1;
        
            if (wxPyNumberSequenceCheck(sipPy, 2)) {
                return 1;
            }
            return 0;
        }
        
         // otherwise do the conversion
         if (sipCanConvertToType(sipPy, sipType_wxSize, SIP_NO_CONVERTORS)) {
             // Just fetch the existing instance
             *sipCppPtr = reinterpret_cast<wxSize*>(sipConvertToType(
                     sipPy, sipType_wxSize, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
             return 0;  // not a new instance
         }
        
         // or create a new instance
         PyObject* o1 = PySequence_ITEM(sipPy, 0);
         PyObject* o2 = PySequence_ITEM(sipPy, 1);
         *sipCppPtr = new wxSize(wxPyInt_AsLong(o1), wxPyInt_AsLong(o2));
         Py_DECREF(o1);
         Py_DECREF(o2);
         return SIP_TEMPORARY;
    %End
};  // end of class wxSize


%Extract(id=pycode_core)
def _Size_GetIM(self):
    """
    Returns an immutable representation of the ``wx.Size`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.Size``
    with a simple statement like this: ``obj = wx.Size(imObj)``.
    """
    return _im_Size(*self.Get())
Size.GetIM = _Size_GetIM
del _Size_GetIM
%End

%Extract(id=pycode_core)
def _Size___str__(self):
    return str(self.Get())
Size.__str__ = _Size___str__
del _Size___str__
%End

%Extract(id=pycode_core)
def _Size___repr__(self):
    return "wx.Size"+str(self.Get())
Size.__repr__ = _Size___repr__
del _Size___repr__
%End

%Extract(id=pycode_core)
def _Size___len__(self):
    return len(self.Get())
Size.__len__ = _Size___len__
del _Size___len__
%End

%Extract(id=pycode_core)
def _Size___nonzero__(self):
    return self.Get() != (0,0)
Size.__nonzero__ = _Size___nonzero__
del _Size___nonzero__
%End

%Extract(id=pycode_core)
def _Size___bool__(self):
    return self.Get() != (0,0)
Size.__bool__ = _Size___bool__
del _Size___bool__
%End

%Extract(id=pycode_core)
def _Size___reduce__(self):
    return (Size, self.Get())
Size.__reduce__ = _Size___reduce__
del _Size___reduce__
%End

%Extract(id=pycode_core)
def _Size___getitem__(self, idx):
    return self.Get()[idx]
Size.__getitem__ = _Size___getitem__
del _Size___getitem__
%End

%Extract(id=pycode_core)
def _Size___setitem__(self, idx, val):
    if idx == 0: self.width = val
    elif idx == 1: self.height = val
    else: raise IndexError
Size.__setitem__ = _Size___setitem__
del _Size___setitem__
%End

%Extract(id=pycode_core)
Size.__safe_for_unpickling__ = True

%End

class wxRect
{
    %Docstring
        Rect()
        Rect(x, y, width, height)
        Rect(pos, size)
        Rect(size)
        Rect(topLeft, bottomRight)
        
        Represents a rectangle with integer coordinates.
    %End
    %TypeHeaderCode
        #include <wx/gdicmn.h>
    %End

public:
    wxRect();

    wxRect(
        int x,
        int y,
        int width,
        int height
    );

    wxRect(
        const wxPoint & pos,
        const wxSize & size
    );

    wxRect(
        const wxSize & size
    );

    wxRect(
        const wxPoint & topLeft,
        const wxPoint & bottomRight
    );

    wxRect CentreIn(
        const wxRect & r,
        int dir = wxBOTH
    ) const;
    %Docstring
        CentreIn(r, dir=BOTH) -> Rect
        
        Returns the rectangle having the same size as this one but centered
        relatively to the given rectangle r.
    %End

    wxRect CenterIn(
        const wxRect & r,
        int dir = wxBOTH
    ) const;
    %Docstring
        CenterIn(r, dir=BOTH) -> Rect
        
        Returns the rectangle having the same size as this one but centered
        relatively to the given rectangle r.
    %End

    wxRect & Deflate(
        wxCoord dx,
        wxCoord dy
    );
    %Docstring
        Deflate(dx, dy) -> Rect
        Deflate(diff) -> Rect
        Deflate(diff) -> Rect
        
        Decrease the rectangle size.
    %End

    wxRect & Deflate(
        const wxSize & diff
    );

    wxRect & Deflate(
        wxCoord diff
    );

    wxRect & Inflate(
        wxCoord dx,
        wxCoord dy
    );
    %Docstring
        Inflate(dx, dy) -> Rect
        Inflate(diff) -> Rect
        Inflate(diff) -> Rect
        
        Increases the size of the rectangle.
    %End

    wxRect & Inflate(
        const wxSize & diff
    );

    wxRect & Inflate(
        wxCoord diff
    );

    void Offset(
        wxCoord dx,
        wxCoord dy
    );
    %Docstring
        Offset(dx, dy)
        Offset(pt)
        
        Moves the rectangle by the specified offset.
    %End

    void Offset(
        const wxPoint & pt
    );

    wxRect & Union(
        const wxRect & rect
    );
    %Docstring
        Union(rect) -> Rect
        
        Modifies the rectangle to contain the bounding box of this rectangle
        and the one passed in as parameter.
    %End

    wxRect & operator+=(
        const wxRect & r
    );

    wxRect & operator*=(
        const wxRect & r
    );

    int height;

    int width;

    int x;

    int y;

    bool Contains(
        int x,
        int y
    ) const;
    %Docstring
        Contains(x, y) -> bool
        Contains(pt) -> bool
        Contains(rect) -> bool
        
        Returns true if the given point is inside the rectangle (or on its
        boundary) and false otherwise.
    %End

    bool Contains(
        const wxPoint & pt
    ) const;

    bool Contains(
        const wxRect & rect
    ) const;

    int GetBottom() const;
    %Docstring
        GetBottom() -> int
        
        Gets the bottom point of the rectangle.
    %End

    wxPoint GetBottomLeft() const;
    %Docstring
        GetBottomLeft() -> Point
        
        Gets the position of the bottom left corner.
    %End

    wxPoint GetBottomRight() const;
    %Docstring
        GetBottomRight() -> Point
        
        Gets the position of the bottom right corner.
    %End

    int GetHeight() const;
    %Docstring
        GetHeight() -> int
        
        Gets the height member.
    %End

    int GetLeft() const;
    %Docstring
        GetLeft() -> int
        
        Gets the left point of the rectangle (the same as GetX()).
    %End

    wxPoint GetPosition() const;
    %Docstring
        GetPosition() -> Point
        
        Gets the position.
    %End

    int GetRight() const;
    %Docstring
        GetRight() -> int
        
        Gets the right point of the rectangle.
    %End

    wxSize GetSize() const;
    %Docstring
        GetSize() -> Size
        
        Gets the size.
    %End

    int GetTop() const;
    %Docstring
        GetTop() -> int
        
        Gets the top point of the rectangle (the same as GetY()).
    %End

    wxPoint GetTopLeft() const;
    %Docstring
        GetTopLeft() -> Point
        
        Gets the position of the top left corner of the rectangle, same as
        GetPosition().
    %End

    wxPoint GetTopRight() const;
    %Docstring
        GetTopRight() -> Point
        
        Gets the position of the top right corner.
    %End

    int GetWidth() const;
    %Docstring
        GetWidth() -> int
        
        Gets the width member.
    %End

    int GetX() const;
    %Docstring
        GetX() -> int
        
        Gets the x member.
    %End

    int GetY() const;
    %Docstring
        GetY() -> int
        
        Gets the y member.
    %End

    wxRect & Intersect(
        const wxRect & rect
    );
    %Docstring
        Intersect(rect) -> Rect
        
        Modifies this rectangle to contain the overlapping portion of this
        rectangle and the one passed in as parameter.
    %End

    bool Intersects(
        const wxRect & rect
    ) const;
    %Docstring
        Intersects(rect) -> bool
        
        Returns true if this rectangle has a non-empty intersection with the
        rectangle rect and false otherwise.
    %End

    bool IsEmpty() const;
    %Docstring
        IsEmpty() -> bool
        
        Returns true if this rectangle has a width or height less than or
        equal to 0 and false otherwise.
    %End

    void SetHeight(
        int height
    );
    %Docstring
        SetHeight(height)
        
        Sets the height.
    %End

    void SetPosition(
        const wxPoint & pos
    );
    %Docstring
        SetPosition(pos)
        
        Sets the position.
    %End

    void SetSize(
        const wxSize & s
    );
    %Docstring
        SetSize(s)
        
        Sets the size.
    %End

    void SetWidth(
        int width
    );
    %Docstring
        SetWidth(width)
        
        Sets the width.
    %End

    void SetX(
        int x
    );
    %Docstring
        SetX(x)
        
        Sets the x position.
    %End

    void SetY(
        int y
    );
    %Docstring
        SetY(y)
        
        Sets the y position.
    %End

    void SetLeft(
        int left
    );
    %Docstring
        SetLeft(left)
        
        Set the left side of the rectangle.
    %End

    void SetRight(
        int right
    );
    %Docstring
        SetRight(right)
        
        Set the right side of the rectangle.
    %End

    void SetTop(
        int top
    );
    %Docstring
        SetTop(top)
        
        Set the top edge of the rectangle.
    %End

    void SetBottom(
        int bottom
    );
    %Docstring
        SetBottom(bottom)
        
        Set the bottom edge of the rectangle.
    %End

    void SetTopLeft(
        const wxPoint & p
    );
    %Docstring
        SetTopLeft(p)
        
        Set the top-left point of the rectangle.
    %End

    void SetBottomRight(
        const wxPoint & p
    );
    %Docstring
        SetBottomRight(p)
        
        Set the bottom-right point of the rectangle.
    %End

    void SetTopRight(
        const wxPoint & p
    );
    %Docstring
        SetTopRight(p)
        
        Set the top-right point of the rectangle.
    %End

    void SetBottomLeft(
        const wxPoint & p
    );
    %Docstring
        SetBottomLeft(p)
        
        Set the bottom-left point of the rectangle.
    %End

    public:


    %Property(name=Bottom, get=GetBottom, set=SetBottom)
    %Property(name=BottomLeft, get=GetBottomLeft, set=SetBottomLeft)
    %Property(name=BottomRight, get=GetBottomRight, set=SetBottomRight)
    %Property(name=Height, get=GetHeight, set=SetHeight)
    %Property(name=Left, get=GetLeft, set=SetLeft)
    %Property(name=Position, get=GetPosition, set=SetPosition)
    %Property(name=Right, get=GetRight, set=SetRight)
    %Property(name=Size, get=GetSize, set=SetSize)
    %Property(name=Top, get=GetTop, set=SetTop)
    %Property(name=TopLeft, get=GetTopLeft, set=SetTopLeft)
    %Property(name=TopRight, get=GetTopRight, set=SetTopRight)
    %Property(name=Width, get=GetWidth, set=SetWidth)
    %Property(name=X, get=GetX, set=SetX)
    %Property(name=Y, get=GetY, set=SetY)
    %Property(name=left, get=GetLeft, set=SetLeft)
    %Property(name=top, get=GetTop, set=SetTop)
    %Property(name=right, get=GetRight, set=SetRight)
    %Property(name=bottom, get=GetBottom, set=SetBottom)
    %Property(name=bottomLeft, get=GetBottomLeft, set=SetBottomLeft)
    %Property(name=bottomRight, get=GetBottomRight, set=SetBottomRight)
    %Property(name=topLeft, get=GetTopLeft, set=SetTopLeft)
    %Property(name=topRight, get=GetTopRight, set=SetTopRight)
    bool __eq__(const wxRect& other);
    %Docstring
        __eq__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRect___eq__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxRect___eq__(wxRect* self, const wxRect* other)
    {
        return *self == *other;
    }
    %End

    bool __ne__(const wxRect& other);
    %Docstring
        __ne__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRect___ne__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxRect___ne__(wxRect* self, const wxRect* other)
    {
        return *self != *other;
    }
    %End

            wxRect operator+(const wxRect& other);
            wxRect operator*(const wxRect& other);


    PyObject* Get();
    %Docstring
        Get() -> (x, y, width, height)
        
        Return the rectangle's properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRect_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxRect_Get(wxRect* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(iiii)",
                              self->x, self->y, self->width, self->height);
    }
    %End

    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxRect?
            if (sipCanConvertToType(sipPy, sipType_wxRect, SIP_NO_CONVERTORS))
                return 1;
        
            if (wxPyNumberSequenceCheck(sipPy, 4)) {
                return 1;
            }
            return 0;
        }
        
        // otherwise do the conversion
        if (sipCanConvertToType(sipPy, sipType_wxRect, SIP_NO_CONVERTORS)) {
            // Just fetch the existing instance
            *sipCppPtr = reinterpret_cast<wxRect*>(sipConvertToType(
                    sipPy, sipType_wxRect, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
            return 0; // not a new instance
        }
        // or create a new instance
        PyObject* o1 = PySequence_ITEM(sipPy, 0);
        PyObject* o2 = PySequence_ITEM(sipPy, 1);
        PyObject* o3 = PySequence_ITEM(sipPy, 2);
        PyObject* o4 = PySequence_ITEM(sipPy, 3);
        *sipCppPtr = new wxRect(wxPyInt_AsLong(o1), wxPyInt_AsLong(o2),
                                 wxPyInt_AsLong(o3), wxPyInt_AsLong(o4));
        Py_DECREF(o1);
        Py_DECREF(o2);
        Py_DECREF(o3);
        Py_DECREF(o4);
        return SIP_TEMPORARY;
    %End
};  // end of class wxRect


%Extract(id=pycode_core)
def _Rect_GetIM(self):
    """
    Returns an immutable representation of the ``wx.Rect`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.Rect``
    with a simple statement like this: ``obj = wx.Rect(imObj)``.
    """
    return _im_Rect(*self.Get())
Rect.GetIM = _Rect_GetIM
del _Rect_GetIM
%End

%Extract(id=pycode_core)
def _Rect___str__(self):
    return str(self.Get())
Rect.__str__ = _Rect___str__
del _Rect___str__
%End

%Extract(id=pycode_core)
def _Rect___repr__(self):
    return "wx.Rect"+str(self.Get())
Rect.__repr__ = _Rect___repr__
del _Rect___repr__
%End

%Extract(id=pycode_core)
def _Rect___len__(self):
    return len(self.Get())
Rect.__len__ = _Rect___len__
del _Rect___len__
%End

%Extract(id=pycode_core)
def _Rect___nonzero__(self):
    return self.Get() != (0,0,0,0)
Rect.__nonzero__ = _Rect___nonzero__
del _Rect___nonzero__
%End

%Extract(id=pycode_core)
def _Rect___bool__(self):
    return self.Get() != (0,0,0,0)
Rect.__bool__ = _Rect___bool__
del _Rect___bool__
%End

%Extract(id=pycode_core)
def _Rect___reduce__(self):
    return (Rect, self.Get())
Rect.__reduce__ = _Rect___reduce__
del _Rect___reduce__
%End

%Extract(id=pycode_core)
def _Rect___getitem__(self, idx):
    return self.Get()[idx]
Rect.__getitem__ = _Rect___getitem__
del _Rect___getitem__
%End

%Extract(id=pycode_core)
def _Rect___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    elif idx == 2: self.width = val
    elif idx == 3: self.height = val
    else: raise IndexError
Rect.__setitem__ = _Rect___setitem__
del _Rect___setitem__
%End

%Extract(id=pycode_core)
Rect.__safe_for_unpickling__ = True

%End

class wxRealPoint
{
    %Docstring
        RealPoint()
        RealPoint(x, y)
        RealPoint(pt)
        
        A wxRealPoint is a useful data structure for graphics operations.
    %End
    %TypeHeaderCode
        #include <wx/gdicmn.h>
    %End

public:
    wxRealPoint();

    wxRealPoint(
        double x,
        double y
    );

    wxRealPoint(
        const wxPoint & pt
    );

    wxRealPoint & operator+=(
        const wxSize & sz
    );

    wxRealPoint & operator+=(
        const wxRealPoint & pt
    );

    wxRealPoint & operator-=(
        const wxSize & sz
    );

    wxRealPoint & operator-=(
        const wxRealPoint & pt
    );

    double x;

    double y;

    bool __eq__(const wxRealPoint& other);
    %Docstring
        __eq__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRealPoint___eq__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxRealPoint___eq__(wxRealPoint* self, const wxRealPoint* other)
    {
        return *self == *other;
    }
    %End

    bool __ne__(const wxRealPoint& other);
    %Docstring
        __ne__(other) -> bool
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRealPoint___ne__(sipCpp, other);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxRealPoint___ne__(wxRealPoint* self, const wxRealPoint* other)
    {
        return *self != *other;
    }
    %End

            wxRealPoint operator+(const wxRealPoint& other);
            wxRealPoint operator-(const wxRealPoint& other);
            wxRealPoint operator/(int i);


    wxRealPoint* __mul__(double d);
    %Docstring
        __mul__(d) -> RealPoint
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRealPoint___mul__(a0, d);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxRealPoint* _wxRealPoint___mul__(wxRealPoint* self, double d)
    {
        return new wxRealPoint(self->x * d, self->y * d);
    }
    %End

    PyObject* Get();
    %Docstring
        Get() -> (x, y)
        
        Return the point's properties as a tuple.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRealPoint_Get(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxRealPoint_Get(wxRealPoint* self)
    {
        wxPyThreadBlocker blocker;
        return sipBuildResult(0, "(dd)", self->x, self->y);
    }
    %End

    public:


    %ConvertToTypeCode
        // is it just a typecheck?
        if (!sipIsErr) {
            // is it already an instance of wxRealPoint?
            if (sipCanConvertToType(sipPy, sipType_wxRealPoint, SIP_NO_CONVERTORS))
                return 1;
        
           if (wxPyNumberSequenceCheck(sipPy, 2)) {
               return 1;
           }
            return 0;
        }
        
        // otherwise do the conversion
        if (sipCanConvertToType(sipPy, sipType_wxRealPoint, SIP_NO_CONVERTORS)) {
            // Just fetch the existing instance
            *sipCppPtr = reinterpret_cast<wxRealPoint*>(sipConvertToType(
                    sipPy, sipType_wxRealPoint, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));
            return 0; // not a new instance
        }
        
        // or create a new instance
        PyObject* o1 = PySequence_ITEM(sipPy, 0);
        PyObject* o2 = PySequence_ITEM(sipPy, 1);
        *sipCppPtr = new wxRealPoint(PyFloat_AsDouble(o1), PyFloat_AsDouble(o2));
        Py_DECREF(o1);
        Py_DECREF(o2);
        return SIP_TEMPORARY;
    %End
};  // end of class wxRealPoint


%Extract(id=pycode_core)
def _RealPoint_GetIM(self):
    """
    Returns an immutable representation of the ``wx.RealPoint`` object, based on ``namedtuple``.
    
    This new object is hashable and can be used as a dictionary key,
    be added to sets, etc.  It can be converted back into a real ``wx.RealPoint``
    with a simple statement like this: ``obj = wx.RealPoint(imObj)``.
    """
    return _im_RealPoint(*self.Get())
RealPoint.GetIM = _RealPoint_GetIM
del _RealPoint_GetIM
%End

%Extract(id=pycode_core)
def _RealPoint___str__(self):
    return str(self.Get())
RealPoint.__str__ = _RealPoint___str__
del _RealPoint___str__
%End

%Extract(id=pycode_core)
def _RealPoint___repr__(self):
    return "wx.RealPoint"+str(self.Get())
RealPoint.__repr__ = _RealPoint___repr__
del _RealPoint___repr__
%End

%Extract(id=pycode_core)
def _RealPoint___len__(self):
    return len(self.Get())
RealPoint.__len__ = _RealPoint___len__
del _RealPoint___len__
%End

%Extract(id=pycode_core)
def _RealPoint___nonzero__(self):
    return self.Get() != (0,0)
RealPoint.__nonzero__ = _RealPoint___nonzero__
del _RealPoint___nonzero__
%End

%Extract(id=pycode_core)
def _RealPoint___bool__(self):
    return self.Get() != (0,0)
RealPoint.__bool__ = _RealPoint___bool__
del _RealPoint___bool__
%End

%Extract(id=pycode_core)
def _RealPoint___reduce__(self):
    return (Rect, self.Get())
RealPoint.__reduce__ = _RealPoint___reduce__
del _RealPoint___reduce__
%End

%Extract(id=pycode_core)
def _RealPoint___getitem__(self, idx):
    return self.Get()[idx]
RealPoint.__getitem__ = _RealPoint___getitem__
del _RealPoint___getitem__
%End

%Extract(id=pycode_core)
def _RealPoint___setitem__(self, idx, val):
    if idx == 0: self.x = val
    elif idx == 1: self.y = val
    else: raise IndexError
RealPoint.__setitem__ = _RealPoint___setitem__
del _RealPoint___setitem__
%End

%Extract(id=pycode_core)
RealPoint.__safe_for_unpickling__ = True

%End

%Extract(id=pycode_core)
RealPoint.IM = property(RealPoint.GetIM)
%End

class wxColourDatabase
{
    %Docstring
        ColourDatabase()
        
        wxWidgets maintains a database of standard RGB colours for a
        predefined set of named colours.
    %End
    %TypeHeaderCode
        #include <wx/gdicmn.h>
    %End

public:
    wxColourDatabase();
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    void AddColour(
        const wxString & colourName,
        const wxColour & colour
    );
    %Docstring
        AddColour(colourName, colour)
        
        Adds a colour to the database.
    %End

    wxColour Find(
        const wxString & colourName
    ) const;
    %Docstring
        Find(colourName) -> Colour
        
        Finds a colour given the name.
    %End

    wxString FindName(
        const wxColour & colour
    ) const;
    %Docstring
        FindName(colour) -> String
        
        Finds a colour name given the colour.
    %End

};  // end of class wxColourDatabase


%Extract(id=pycode_core)
def _ColourDatabase_FindColour(self, colour):
    return self.Find(colour)
ColourDatabase.FindColour = _ColourDatabase_FindColour
del _ColourDatabase_FindColour
%End

bool wxColourDisplay();
%Docstring
    ColourDisplay() -> bool
    
    Returns true if the display is colour, false otherwise.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

int wxDisplayDepth();
%Docstring
    DisplayDepth() -> int
    
    Returns the depth of the display (a value of 1 denotes a monochrome
    display).
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

void wxSetCursor(
    const wxCursor & cursor
);
%Docstring
    SetCursor(cursor)
    
    Globally sets the cursor; only has an effect on Windows, Mac and GTK+.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

void wxClientDisplayRect(
    int * x   /Out/,
    int * y   /Out/,
    int * width   /Out/,
    int * height   /Out/
);
%Docstring
    ClientDisplayRect() -> (x, y, width, height)
    
    Returns the dimensions of the work area on the display.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

wxRect wxGetClientDisplayRect();
%Docstring
    GetClientDisplayRect() -> Rect
    
    Returns the dimensions of the work area on the display.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

wxSize wxGetDisplayPPI();
%Docstring
    GetDisplayPPI() -> Size
    
    Returns the display resolution in pixels per inch.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

void wxDisplaySize(
    int * width   /Out/,
    int * height   /Out/
);
%Docstring
    DisplaySize() -> (width, height)
    
    Returns the display size in pixels.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

wxSize wxGetDisplaySize();
%Docstring
    GetDisplaySize() -> Size
    
    Returns the display size in pixels.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

void wxDisplaySizeMM(
    int * width   /Out/,
    int * height   /Out/
);
%Docstring
    DisplaySizeMM() -> (width, height)
    
    Returns the display size in millimeters.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

wxSize wxGetDisplaySizeMM();
%Docstring
    GetDisplaySizeMM() -> Size
    
    Returns the display size in millimeters.
%End
%PreMethodCode
    if (!wxPyCheckForApp()) return NULL;
%End

const wxPoint wxDefaultPosition;

const wxSize wxDefaultSize;

%Extract(id=pycode_core)
from collections import namedtuple
_im_Point = namedtuple('_im_Point', ['x', 'y'])
del namedtuple

%End

class wxPointList_iterator /Abstract/
{
    // the C++ implementation of this class
    %TypeHeaderCode
        
        
        class wxPointList_iterator {
        public:
            wxPointList_iterator(wxPointList::compatibility_iterator start)
                : m_node(start) {}

            wxPoint* __next__() {
                wxPoint* obj = NULL;
                if (m_node) {
                    obj = (wxPoint*) m_node->GetData();
                    m_node = m_node->GetNext();
                }
                else {
                    PyErr_SetString(PyExc_StopIteration, "");
                }
                return (wxPoint*)obj;
            }
        private:
            wxPointList::compatibility_iterator m_node;
        };
    %End
public:
    wxPoint* __next__();
    %MethodCode
        sipRes = sipCpp->__next__();
        if (PyErr_Occurred())
            return NULL;
    %End
};

class wxPointList
{
    %TypeHeaderCode
        
        
    %End
public:
    SIP_SSIZE_T __len__();
    %MethodCode
        sipRes = sipCpp->size();
    %End

    wxPoint* __getitem__(long index);
    %MethodCode
        if (0 > index)
            index += sipCpp->size();

        if (index < sipCpp->size() && (0 <= index)) {
            wxPointList::compatibility_iterator node = sipCpp->Item(index);
            if (node)
                sipRes = (wxPoint*)node->GetData();
        }
        else {
            wxPyErr_SetString(PyExc_IndexError, "sequence index out of range");
            sipError = sipErrorFail;
        }
    %End

    int __contains__(const wxPoint* obj);
    %MethodCode
        wxPointList::compatibility_iterator node;
        node = sipCpp->Find((wxPoint*)obj);
        sipRes = node != NULL;
    %End

    wxPointList_iterator* __iter__() /Factory/;
    %MethodCode
        sipRes =  new wxPointList_iterator(sipCpp->GetFirst());
    %End

    // TODO:  add support for index(value, [start, [stop]])
    int index(wxPoint* obj);
    %MethodCode
        int idx = sipCpp->IndexOf((wxPoint*)obj);
        if (idx == wxNOT_FOUND) {
            sipError = sipErrorFail;
            wxPyErr_SetString(PyExc_ValueError,
                              "sequence.index(x): x not in sequence");
        }
        sipRes = idx;
    %End

    %ConvertToTypeCode
    // Code to test a PyObject for compatibility
    if (!sipIsErr) {
        int success = TRUE;
        // is it already a wxPointList?
        if (sipCanConvertToType(sipPy, sipType_wxPointList, SIP_NO_CONVERTORS))
            return success;
        // otherwise ensure that it is a sequence
        if (! PySequence_Check(sipPy))
            success = FALSE;
        // ensure it is not a string or unicode object (they are sequences too)
        else if (PyBytes_Check(sipPy) || PyUnicode_Check(sipPy))
            success = FALSE;
        // ensure each item can be converted to wxPoint
        else {
            Py_ssize_t i, len = PySequence_Length(sipPy);
            for (i=0; i<len; i++) {
                PyObject* item = PySequence_ITEM(sipPy, i);
                if (!sipCanConvertToType(item, sipType_wxPoint, SIP_NOT_NONE)) {
                    Py_DECREF(item);
                    success = FALSE;
                    break;
                }
                Py_DECREF(item);
            }
        }
        if (!success)
            PyErr_SetString(PyExc_TypeError, "Sequence of wxPoint compatible objects expected.");
        return success;
    }

    // Is it already a wxPointList? Return the exiting instance if so
    if (sipCanConvertToType(sipPy, sipType_wxPointList, SIP_NO_CONVERTORS)) {
        *sipCppPtr = reinterpret_cast<wxPointList*>(
                     sipConvertToType(sipPy, sipType_wxPointList, NULL,
                                      SIP_NO_CONVERTORS, 0, sipIsErr));
        return 0;
    }

    // Create a new wxPointList and convert compatible PyObjects from the sequence
    wxPointList *list = new wxPointList;
    list->DeleteContents(true); // tell the list to take ownership of the items
    Py_ssize_t i, len = PySequence_Length(sipPy);
    for (i=0; i<len; i++) {
        int state;
        PyObject* pyItem = PySequence_ITEM(sipPy, i);
        wxPoint* cItem = reinterpret_cast<wxPoint*>(
                             sipConvertToType(pyItem, sipType_wxPoint,
                             NULL, 0, &state, sipIsErr));
        if (!state)  // a temporary was not created for us, make one now
            cItem = new wxPoint(*cItem);
        list->Append(cItem);
        Py_DECREF(pyItem);
    }
    *sipCppPtr = list;
    return SIP_TEMPORARY;
%End

};

%Extract(id=pycode_core)
def _PointList___repr__(self):
    return "PointList: " + repr(list(self))
PointList.__repr__ = _PointList___repr__
del _PointList___repr__
%End


%Extract(id=pycode_core)
from collections import namedtuple
_im_Size = namedtuple('_im_Size', ['width', 'height'])
del namedtuple

%End

%Extract(id=pycode_core)
from collections import namedtuple
_im_Rect = namedtuple('_im_Rect', ['x', 'y', 'width', 'height'])
del namedtuple

%End

%Extract(id=pycode_core)
from collections import namedtuple
_im_RealPoint = namedtuple('_im_RealPoint', ['x', 'y'])
del namedtuple

%End

PyObject* IntersectRect(wxRect* r1,  wxRect* r2);
%Docstring
    IntersectRect(r1, r2) -> PyObject
    
    Calculate and return the intersection of r1 and r2.  Returns None if
    there
    is no intersection.
%End
%MethodCode
    PyErr_Clear();
    Py_BEGIN_ALLOW_THREADS
    sipRes = _IntersectRect_function(r1, r2);
    Py_END_ALLOW_THREADS
    if (PyErr_Occurred()) sipIsErr = 1;
%End
%ModuleCode
PyObject* _IntersectRect_function(wxRect* r1, wxRect* r2)
{
    wxRegion  reg1(*r1);
    wxRegion  reg2(*r2);
    wxRect    dest(0,0,0,0);
    PyObject* obj;
    
    reg1.Intersect(reg2);
    dest = reg1.GetBox();
    
    wxPyThreadBlocker blocker;
    if (dest != wxRect(0,0,0,0)) {
        wxRect* newRect = new wxRect(dest);
        obj = wxPyConstructObject((void*)newRect, wxT("wxRect"), true);
        return obj;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%End


//---------------------------------------------------------------------------

