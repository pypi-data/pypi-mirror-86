//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License

%Module( name=wx._core,
         keyword_arguments="All",
         use_argument_names=True,
         all_raise_py_exception=True,
         language="C++")
{
    %AutoPyName(remove_leading="wx")
};

%Copying
    Copyright: (c) 2020 by Total Control Software
    License:   wxWindows License
%End

%DefaultDocstringFormat(name="deindented")

%Extract(id=pycode_core, order=5)
# This file is generated by wxPython's SIP generator.  Do not edit by hand.
#
# Copyright: (c) 2020 by Total Control Software
# License:   wxWindows License

"""
The classes in this module are the most commonly used classes for wxPython,
which is why they have been made visible in the core `wx` namespace.
Everything you need for building typical GUI applications is here.
"""

from ._core import *

%End

//---------------------------------------------------------------------------

%ModuleHeaderCode
#include <wxPython/wxpy_api.h>
%End

%Include wacky_ints.sip
%Include defs.sip
%Include debug.sip
%Include object.sip
%Include wxpy_api.sip
%Include arrayholder.sip
%Include string.sip
%Include filename.sip
%Include arrays.sip
%Include clntdata.sip
%Include clntdatactnr.sip
%Include userdata.sip
%Include wxpybuffer.sip
%Include msgdlg_btnlabel.sip
%Include stockgdi.sip
%Include longlong.sip
%Include wxdatetime.sip
%Include stopwatch.sip
%Include windowid.sip
%Include platinfo.sip
%Include vidmode.sip
%Include display.sip
%Include intl.sip
%Include translation.sip
%Include cmndata.sip
%Include gdicmn.sip
%Include geometry.sip
%Include affinematrix2d.sip
%Include position.sip
%Include colour.sip
%Include stream.sip
%Include filesys.sip
%Include image.sip
%Include gdiobj.sip
%Include bitmap.sip
%Include icon.sip
%Include iconloc.sip
%Include iconbndl.sip
%Include font.sip
%Include fontutil.sip
%Include pen.sip
%Include brush.sip
%Include cursor.sip
%Include region.sip
%Include dc.sip
%Include dcclient.sip
%Include dcmemory.sip
%Include dcbuffer.sip
%Include dcscreen.sip
%Include dcgraph.sip
%Include dcmirror.sip
%Include dcprint.sip
%Include dcps.sip
%Include dcsvg.sip
%Include metafile.sip
%Include graphics.sip
%Include imaglist.sip
%Include overlay.sip
%Include palette.sip
%Include renderer.sip
%Include rawbmp.sip
%Include access.sip
%Include accel.sip
%Include log.sip
%Include dataobj.sip
%Include dnd.sip
%Include clipbrd.sip
%Include config.sip
%Include variant.sip
%Include tracker.sip
%Include kbdstate.sip
%Include mousestate.sip
%Include tooltip.sip
%Include layout.sip
%Include event.sip
%Include pyevent.sip
%Include sizer.sip
%Include gbsizer.sip
%Include wrapsizer.sip
%Include stdpaths.sip
%Include eventfilter.sip
%Include evtloop.sip
%Include apptrait.sip
%Include app.sip
%Include timer.sip
%Include window.sip
%Include validate.sip
%Include panel.sip
%Include menuitem.sip
%Include menu.sip
%Include scrolwin.sip
%Include vscroll.sip
%Include control.sip
%Include ctrlsub.sip
%Include statbmp.sip
%Include stattext.sip
%Include statbox.sip
%Include statusbar.sip
%Include choice.sip
%Include anybutton.sip
%Include button.sip
%Include bmpbuttn.sip
%Include withimage.sip
%Include bookctrl.sip
%Include notebook.sip
%Include splitter.sip
%Include collpane.sip
%Include statline.sip
%Include textcompleter.sip
%Include textentry.sip
%Include textctrl.sip
%Include combobox.sip
%Include checkbox.sip
%Include listbox.sip
%Include checklst.sip
%Include gauge.sip
%Include headercol.sip
%Include headerctrl.sip
%Include srchctrl.sip
%Include radiobox.sip
%Include radiobut.sip
%Include slider.sip
%Include spinbutt.sip
%Include spinctrl.sip
%Include tglbtn.sip
%Include scrolbar.sip
%Include toolbar.sip
%Include infobar.sip
%Include listctrl.sip
%Include treeitemdata.sip
%Include treectrl.sip
%Include pickers.sip
%Include filectrl.sip
%Include combo.sip
%Include choicebk.sip
%Include listbook.sip
%Include toolbook.sip
%Include treebook.sip
%Include simplebook.sip
%Include vlbox.sip
%Include activityindicator.sip
%Include collheaderctrl.sip
%Include nonownedwnd.sip
%Include toplevel.sip
%Include dialog.sip
%Include dirdlg.sip
%Include dirctrl.sip
%Include filedlg.sip
%Include frame.sip
%Include msgdlg.sip
%Include richmsgdlg.sip
%Include progdlg.sip
%Include popupwin.sip
%Include tipwin.sip
%Include colordlg.sip
%Include choicdlg.sip
%Include fdrepdlg.sip
%Include mdi.sip
%Include fontdlg.sip
%Include rearrangectrl.sip
%Include minifram.sip
%Include textdlg.sip
%Include numdlg.sip
%Include power.sip
%Include utils.sip
%Include process.sip
%Include uiaction.sip
%Include snglinst.sip
%Include help.sip
%Include cshelp.sip
%Include settings.sip
%Include sysopt.sip
%Include artprov.sip
%Include dragimag.sip
%Include printfw.sip
%Include printdlg.sip
%Include mimetype.sip
%Include busyinfo.sip
%Include caret.sip
%Include fontenum.sip
%Include fontmap.sip
%Include mousemanager.sip
%Include filehistory.sip
%Include cmdproc.sip
%Include fswatcher.sip
%Include preferences.sip
%Include modalhook.sip
%Include unichar.sip
%Include stockitem.sip

%ModuleCode

#ifdef __WXMSW__             // If building for Windows...

#include <wx/msw/private.h>
#include <wx/msw/winundef.h>
#include <wx/msw/msvcrt.h>

//----------------------------------------------------------------------
// Use an ActivationContext to ensure that the new (themed) version of
// the comctl32 DLL is loaded.
//----------------------------------------------------------------------

// Note that the use of the ISOLATION_AWARE_ENABLED define replaces the
// activation context APIs with wrappers that dynamically load the API
// pointers from the kernel32 DLL so we don't have to do that ourselves.
// Using ISOLATION_AWARE_ENABLED also causes the manifest resource to be put
// in slot #2 as expected for DLLs. (See wx/msw/wx.rc)

#ifdef ISOLATION_AWARE_ENABLED

static ULONG_PTR wxPySetActivationContext()
{

    OSVERSIONINFO info;
    wxZeroMemory(info);
    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&info);
    if (info.dwMajorVersion < 5)
        return 0;

    ULONG_PTR cookie = 0;
    HANDLE h;
    ACTCTX actctx;
    TCHAR modulename[MAX_PATH];

    GetModuleFileName(wxGetInstance(), modulename, MAX_PATH);
    wxZeroMemory(actctx);
    actctx.cbSize = sizeof(actctx);
    actctx.lpSource = modulename;
    actctx.lpResourceName = MAKEINTRESOURCE(2);
    actctx.hModule = wxGetInstance();
    actctx.dwFlags = ACTCTX_FLAG_HMODULE_VALID | ACTCTX_FLAG_RESOURCE_NAME_VALID;

    h = CreateActCtx(&actctx);
    if (h == INVALID_HANDLE_VALUE) {
        wxLogLastError(wxT("CreateActCtx"));
        return 0;
    }

    if (! ActivateActCtx(h, &cookie))
        wxLogLastError(wxT("ActivateActCtx"));

    return cookie;
}

static void wxPyClearActivationContext(ULONG_PTR cookie)
{
    if (! DeactivateActCtx(0, cookie))
        wxLogLastError(wxT("DeactivateActCtx"));
}

#endif  // ISOLATION_AWARE_ENABLED

#endif // __WXMSW__

void wxPyPreInit(PyObject* moduleDict)
{
#ifdef ISOLATION_AWARE_ENABLED
    wxPySetActivationContext();
#endif
//#ifdef __WXMSW__
////     wxCrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF
////                     | _CRTDBG_CHECK_ALWAYS_DF
////                     | _CRTDBG_DELAY_FREE_MEM_DF
////         );
//#endif
//
//#ifdef WXP_WITH_THREAD
//#if wxPyUSE_GIL_STATE
//    PyEval_InitThreads();
//#else
//    PyEval_InitThreads();
//    wxPyTStates = new wxPyThreadStateArray;
//    wxPyTMutex = new wxMutex;
//
//    // Save the current (main) thread state in our array
//    PyThreadState* tstate = wxPyBeginAllowThreads();
//    wxPyEndAllowThreads(tstate);
//#endif
//#endif

    // Ensure that the build options in the DLL (or whatever) match this build
    wxApp::CheckBuildOptions(WX_BUILD_OPTIONS_SIGNATURE, "wxPython");
}

void _wxPyCleanup()
{
    wxEntryCleanup();
}

PyObject* wxAssertionError = NULL;      // Exception object raised for wxASSERT failures

void wxPyCoreModuleInject(PyObject* moduleDict)
{
    // Create an exception object to use for wxASSERTions
    wxAssertionError = PyErr_NewException("wx._core.wxAssertionError",
                                            PyExc_AssertionError, NULL);
    PyDict_SetItemString(moduleDict, "wxAssertionError", wxAssertionError);

    // An alias that should be deprecated sometime
    PyDict_SetItemString(moduleDict, "PyAssertionError", wxAssertionError);


    // Create an exception object to use when the app object hasn't been created yet
    wxPyNoAppError = PyErr_NewException("wx._core.PyNoAppError",
                                        PyExc_RuntimeError, NULL);
    PyDict_SetItemString(moduleDict, "PyNoAppError", wxPyNoAppError);

#ifdef __WXGTK__
#define wxPort "__WXGTK__"
#define wxPortName "wxGTK"
#endif
#ifdef __WXMSW__
#define wxPort "__WXMSW__"
#define wxPortName "wxMSW"
#endif
#ifdef __WXMAC__
#define wxPort "__WXMAC__"
#define wxPortName "wxMac"
#endif

    wxInitAllImageHandlers();

    // TODO: Find some magic way to deprecate wx.Platform such that it raises
    // a warning when used...  Maybe a class that returns wx.Port for any __getattr__?
    PyDict_SetItemString(moduleDict, "Port", PyUnicode_FromString(wxPort));
    PyDict_SetItemString(moduleDict, "Platform", PyUnicode_FromString(wxPort));

    PyDict_SetItemString(moduleDict, "wxWidgets_version", wx2PyString(wxVERSION_STRING));

    PyDict_SetItemString(moduleDict, "_sizeof_int", PyLong_FromLong(sizeof(int)));
    PyDict_SetItemString(moduleDict, "_sizeof_long", PyLong_FromLong(sizeof(long)));
    PyDict_SetItemString(moduleDict, "_sizeof_longlong", PyLong_FromLong(sizeof(long long)));
    PyDict_SetItemString(moduleDict, "_sizeof_double", PyLong_FromLong(sizeof(double)));
    PyDict_SetItemString(moduleDict, "_sizeof_size_t", PyLong_FromLong(sizeof(size_t)));
    PyDict_SetItemString(moduleDict, "_LONG_MIN", PyLong_FromLong(LONG_MIN));
    PyDict_SetItemString(moduleDict, "_LONG_MAX", PyLong_FromLong(LONG_MAX));
    PyDict_SetItemString(moduleDict, "_LLONG_MIN", PyLong_FromLongLong(PY_LLONG_MIN));
    PyDict_SetItemString(moduleDict, "_LLONG_MAX", PyLong_FromLongLong(PY_LLONG_MAX));

    // Make a tuple of strings that gives more info about the platform and build.
    PyObject* PlatformInfo = PyList_New(0);
    PyObject* obj;

#define _AddInfoString(st) \
    obj = PyUnicode_FromString(st); \
    PyList_Append(PlatformInfo, obj); \
    Py_DECREF(obj)

    _AddInfoString(wxPort);
    _AddInfoString(wxPortName);
#if wxUSE_UNICODE
    _AddInfoString("unicode");
#if wxUSE_UNICODE_WCHAR
    _AddInfoString("unicode-wchar");
#else
    _AddInfoString("unicode-utf8");
#endif
#else
    _AddInfoString("ansi");
#endif

#ifdef __WXOSX__
    _AddInfoString("wxOSX");
#endif
#ifdef __WXOSX_CARBON__
    _AddInfoString("wxOSX-carbon");
#endif
#ifdef __WXOSX_COCOA__
    _AddInfoString("wxOSX-cocoa");
#endif
#ifdef __WXGTK__
#ifdef __WXGTK3__
    _AddInfoString("gtk3");
#elif __WXGTK20__
    _AddInfoString("gtk2");
#else
    _AddInfoString("gtk1");
#endif
#endif
#ifdef __WXDEBUG__
    _AddInfoString("wx-assertions-on");
#else
    _AddInfoString("wx-assertions-off");
#endif
    _AddInfoString("phoenix");

    obj = wx2PyString(wxVERSION_STRING);
    PyList_Append(PlatformInfo, obj);
    Py_DECREF(obj);

#if wxUSE_AUTOID_MANAGEMENT
    _AddInfoString("autoidman");
#endif

    wxString sip_version = wxString("sip-") + wxString(SIP_VERSION_STR);
    obj = wx2PyString(sip_version);
    PyList_Append(PlatformInfo, obj);
    Py_DECREF(obj);

#undef _AddInfoString

    PyObject* PlatformInfoTuple = PyList_AsTuple(PlatformInfo);
    Py_DECREF(PlatformInfo);
    PyDict_SetItemString(moduleDict, "PlatformInfo", PlatformInfoTuple);

}

%End

//---------------------------------------------------------------------------

%Extract(id=pycode_core, order=10)
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This code block was included from src/core_ex.py
import sys as _sys

# Load version numbers from __version__ and some other initialization tasks...
if 'wxEVT_NULL' in dir():
    from wx.__version__ import *
    import wx._core
    __version__ = VERSION_STRING

    # Add the build type to PlatformInfo
    PlatformInfo = PlatformInfo + ('build-type: ' + BUILD_TYPE, )

    # Register a function to be called when Python terminates that will clean
    # up and release all system resources that wxWidgets allocated.
    import atexit
    atexit.register(wx._core._wxPyCleanup)
    del atexit

else:
    Port = ''
    Platform = ''
    PlatformInfo = []

# A little trick to make 'wx' be a reference to this module so wx.Names can
# be used in the python code here.
wx = _sys.modules[__name__]


import warnings
class wxPyDeprecationWarning(DeprecationWarning):
    pass

warnings.simplefilter('default', wxPyDeprecationWarning)
del warnings


def deprecated(item, msg='', useName=False):
    """
    Create a delegating wrapper that raises a deprecation warning.  Can be
    used with callable objects (functions, methods, classes) or with
    properties.
    """
    import warnings

    name = ''
    if useName:
        try:
            name = ' ' + item.__name__
        except AttributeError:
            pass

    if isinstance(item, type):
        # It is a class.  Make a subclass that raises a warning.
        class DeprecatedClassProxy(item):
            def __init__(*args, **kw):
                warnings.warn("Using deprecated class%s. %s" % (name, msg),
                          wxPyDeprecationWarning, stacklevel=2)
                item.__init__(*args, **kw)
        DeprecatedClassProxy.__name__ = item.__name__
        return DeprecatedClassProxy

    elif callable(item):
        # wrap a new function around the callable
        def deprecated_func(*args, **kw):
            warnings.warn("Call to deprecated item%s. %s" % (name, msg),
                          wxPyDeprecationWarning, stacklevel=2)
            if not kw:
                return item(*args)
            return item(*args, **kw)
        deprecated_func.__name__ = item.__name__
        deprecated_func.__doc__ = item.__doc__
        if hasattr(item, '__dict__'):
            deprecated_func.__dict__.update(item.__dict__)
        return deprecated_func

    elif hasattr(item, '__get__'):
        # it should be a property if there is a getter
        class DepGetProp(object):
            def __init__(self, item, msg):
                self.item = item
                self.msg = msg
            def __get__(self, inst, klass):
                warnings.warn("Accessing deprecated property. %s" % msg,
                              wxPyDeprecationWarning, stacklevel=2)
                return self.item.__get__(inst, klass)
        class DepGetSetProp(DepGetProp):
            def __set__(self, inst, val):
                warnings.warn("Accessing deprecated property. %s" % msg,
                              wxPyDeprecationWarning, stacklevel=2)
                return self.item.__set__(inst, val)
        class DepGetSetDelProp(DepGetSetProp):
            def __delete__(self, inst):
                warnings.warn("Accessing deprecated property. %s" % msg,
                              wxPyDeprecationWarning, stacklevel=2)
                return self.item.__delete__(inst)

        if hasattr(item, '__set__') and hasattr(item, '__delete__'):
            return DepGetSetDelProp(item, msg)
        elif hasattr(item, '__set__'):
            return DepGetSetProp(item, msg)
        else:
            return DepGetProp(item, msg)
    else:
        raise TypeError("unsupported type %s" % type(item))


def deprecatedMsg(msg):
    """
    A wrapper for the deprecated decorator that makes it easier to attach a
    custom message to the warning that is raised if the item is used. This
    can also be used in the @decorator role since it returns the real
    decorator when called.
    """
    import functools
    return functools.partial(deprecated, msg=msg, useName=True)

#----------------------------------------------------------------------------

EmptyString = ""

#----------------------------------------------------------------------------

# End of included code block
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%End

%Extract(id=pycode_core)
def version():
    """
    Returns a string containing version and port info
    """
    if wx.Port == '__WXMSW__':
        port = 'msw'
    elif wx.Port == '__WXMAC__':
        if 'wxOSX-carbon' in wx.PlatformInfo:
            port = 'osx-carbon'
        else:
            port = 'osx-cocoa'
    elif wx.Port == '__WXGTK__':
        port = 'gtk'
        if 'gtk2' in wx.PlatformInfo:
            port = 'gtk2'
        elif 'gtk3' in wx.PlatformInfo:
            port = 'gtk3'
    else:
        port = '???'
    return "%s %s (phoenix) %s" % (wx.VERSION_STRING, port, wx.wxWidgets_version)

%End

%Extract(id=pycode_core)
def CallAfter(callableObj, *args, **kw):
    """
    Call the specified function after the current and pending event
    handlers have been completed.  This is also good for making GUI
    method calls from non-GUI threads.  Any extra positional or
    keyword args are passed on to the callable when it is called.
    
    :param PyObject callableObj: the callable object
    :param args: arguments to be passed to the callable object
    :param kw: keywords to be passed to the callable object
    
    .. seealso::
        :ref:`wx.CallLater`
    """
    assert callable(callableObj), "callableObj is not callable"
    app = wx.GetApp()
    assert app is not None, 'No wx.App created yet'
    
    if not hasattr(app, "_CallAfterId"):
        app._CallAfterId = wx.NewEventType()
        app.Connect(-1, -1, app._CallAfterId,
                    lambda event: event.callable(*event.args, **event.kw) )
    evt = wx.PyEvent()
    evt.SetEventType(app._CallAfterId)
    evt.callable = callableObj
    evt.args = args
    evt.kw = kw
    wx.PostEvent(app, evt)

%End

%Extract(id=pycode_core)
class CallLater(object):
    """
    A convenience class for :class:`wx.Timer`, that calls the given callable
    object once after the given amount of milliseconds, passing any
    positional or keyword args.  The return value of the callable is
    available after it has been run with the :meth:`~wx.CallLater.GetResult`
    method.
    
    If you don't need to get the return value or restart the timer
    then there is no need to hold a reference to this object. CallLater
    maintains references to its instances while they are running. When they
    finish, the internal reference is deleted and the GC is free to collect
    naturally.
    
    .. seealso::
        :func:`wx.CallAfter`
    """
    __instances = {}
    def __init__(self, millis, callableObj, *args, **kwargs):
        """
        Constructs a new :class:`wx.CallLater` object.
        
        :param int millis: number of milliseconds to delay until calling the callable object
        :param PyObject callableObj: the callable object
        :param args: arguments to be passed to the callable object
        :param kw: keywords to be passed to the callable object
        """
        assert callable(callableObj), "callableObj is not callable"
        self.millis = millis
        self.callable = callableObj
        self.SetArgs(*args, **kwargs)
        self.runCount = 0
        self.running = False
        self.hasRun = False
        self.result = None
        self.timer = None
        self.Start()

    def __del__(self):
        self.Stop()

    def Start(self, millis=None, *args, **kwargs):
        """
        (Re)start the timer
        
        :param int millis: number of milli seconds
        :param args: arguments to be passed to the callable object
        :param kw: keywords to be passed to the callable object
        """
        self.hasRun = False
        if millis is not None:
            self.millis = millis
        if args or kwargs:
            self.SetArgs(*args, **kwargs)
        self.Stop()
        CallLater.__instances[self] = "value irrelevant"  # Maintain a reference to avoid GC
        self.timer = wx.PyTimer(self.Notify)
        self.timer.Start(self.millis, wx.TIMER_ONE_SHOT)
        self.running = True

    Restart = Start
    def Stop(self):
        """
        Stop and destroy the timer.
        """
        if self in CallLater.__instances:
            del CallLater.__instances[self]
        if self.timer is not None:
            self.timer.Stop()
            self.timer = None

    def GetInterval(self):
        if self.timer is not None:
            return self.timer.GetInterval()
        else:
            return 0

    def IsRunning(self):
        return self.timer is not None and self.timer.IsRunning()

    def SetArgs(self, *args, **kwargs):
        """
        (Re)set the args passed to the callable object.  This is
        useful in conjunction with :meth:`Start` if
        you want to schedule a new call to the same callable
        object but with different parameters.
        
        :param args: arguments to be passed to the callable object
        :param kw: keywords to be passed to the callable object
        """
        self.args = args
        self.kwargs = kwargs

    def HasRun(self):
        """
        Returns whether or not the callable has run.
        
        :rtype: bool
        """
        return self.hasRun

    def GetResult(self):
        """
        Returns the value of the callable.
        
        :rtype: a Python object
        :return: result from callable
        """
        return self.result

    def Notify(self):
        """
        The timer has expired so call the callable.
        """
        if self.callable and getattr(self.callable, 'im_self', True):
            self.runCount += 1
            self.running = False
            self.result = self.callable(*self.args, **self.kwargs)
        self.hasRun = True
        if not self.running:
            # if it wasn't restarted, then cleanup
            wx.CallAfter(self.Stop)

    Interval = property(GetInterval)
    Result = property(GetResult)

%End

%Extract(id=pycode_core)
FutureCall = deprecated(CallLater, 'Use CallLater instead.')

%End

%Extract(id=pycode_core)
def GetDefaultPyEncoding():
    return "utf-8"
GetDefaultPyEncoding = deprecated(GetDefaultPyEncoding, msg="wxPython now always uses utf-8")

%End

bool IsMainThread();
%Docstring
    IsMainThread() -> bool
    
    Returns ``True`` if the current thread is what wx considers the GUI
    thread.
%End
%MethodCode
    PyErr_Clear();
    Py_BEGIN_ALLOW_THREADS
    sipRes = _IsMainThread_function();
    Py_END_ALLOW_THREADS
    if (PyErr_Occurred()) sipIsErr = 1;
%End
%ModuleCode
bool _IsMainThread_function()
{
    return wxThread::IsMain();
}
%End

void _wxPyCleanup();



//---------------------------------------------------------------------------


%InitialisationCode
        wxPyPreInit(sipModuleDict);
        
%End

//---------------------------------------------------------------------------


%PostInitialisationCode
        wxPyCoreModuleInject(sipModuleDict);
        
%End

//---------------------------------------------------------------------------

