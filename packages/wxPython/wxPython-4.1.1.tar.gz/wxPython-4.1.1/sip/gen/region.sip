//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

enum wxRegionContain
{
    wxOutRegion,
    wxPartRegion,
    wxInRegion
};

class wxRegionIterator : wxObject
{
    %Docstring
        RegionIterator()
        RegionIterator(region)
        
        This class is used to iterate through the rectangles in a region,
        typically when examining the damaged regions of a window within an
        OnPaint call.
    %End
    %TypeHeaderCode
        #include <wx/region.h>
    %End

public:
    wxRegionIterator();
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegionIterator(
        const wxRegion & region
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxCoord GetH() const;
    %Docstring
        GetH() -> Coord
        
        An alias for GetHeight().
    %End

    wxCoord GetHeight() const;
    %Docstring
        GetHeight() -> Coord
        
        Returns the height value for the current region.
    %End

    wxRect GetRect() const;
    %Docstring
        GetRect() -> Rect
        
        Returns the current rectangle.
    %End

    wxCoord GetW() const;
    %Docstring
        GetW() -> Coord
        
        An alias for GetWidth().
    %End

    wxCoord GetWidth() const;
    %Docstring
        GetWidth() -> Coord
        
        Returns the width value for the current region.
    %End

    wxCoord GetX() const;
    %Docstring
        GetX() -> Coord
        
        Returns the x value for the current region.
    %End

    wxCoord GetY() const;
    %Docstring
        GetY() -> Coord
        
        Returns the y value for the current region.
    %End

    bool HaveRects() const;
    %Docstring
        HaveRects() -> bool
        
        Returns true if there are still some rectangles; otherwise returns
        false.
    %End

    void Reset();
    %Docstring
        Reset()
        Reset(region)
        
        Resets the iterator to the beginning of the rectangles.
    %End

    void Reset(
        const wxRegion & region
    );

    int __nonzero__();
    %Docstring
        __nonzero__() -> int
        
        Returns true while there are still rectangles available in the
        iteration.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRegionIterator___nonzero__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxRegionIterator___nonzero__(wxRegionIterator* self)
    {
        return (int)self->operator bool();
    }
    %End

    int __bool__();
    %Docstring
        __bool__() -> int
        
        Returns true while there are still rectangles available in the
        iteration.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxRegionIterator___bool__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxRegionIterator___bool__(wxRegionIterator* self)
    {
        return (int)self->operator bool();
    }
    %End

    void Next();
    %Docstring
        Next()
        
        Move the iterator to the next rectangle in the region.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxRegionIterator_Next(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxRegionIterator_Next(wxRegionIterator* self)
    {
        self->operator++();
    }
    %End

    public:


    %Property(name=H, get=GetH)
    %Property(name=Height, get=GetHeight)
    %Property(name=Rect, get=GetRect)
    %Property(name=W, get=GetW)
    %Property(name=Width, get=GetWidth)
    %Property(name=X, get=GetX)
    %Property(name=Y, get=GetY)
};  // end of class wxRegionIterator


class wxRegion : wxGDIObject
{
    %Docstring
        Region()
        Region(x, y, width, height)
        Region(topLeft, bottomRight)
        Region(rect)
        Region(region)
        Region(bmp)
        Region(bmp, transColour, tolerance=0)
        Region(points, fillStyle=ODDEVEN_RULE)
        
        A wxRegion represents a simple or complex region on a device context
        or window.
    %End
    %TypeHeaderCode
        #include <wx/region.h>
    %End

    %TypeCode
        // Convert a Python sequence of wxPoint objects, or items that can be converted
        // to wxPoint into a C array of wxPoint instances.
        static
        wxPoint* wxPoint_array_helper(PyObject* source, size_t *count)
        {
            wxPoint* array;
            Py_ssize_t idx, len;
            wxPyThreadBlocker blocker;
        
            // ensure that it is a sequence
            if (! PySequence_Check(source))
                goto error0;
            // ensure it is not a string or unicode object (they are sequences too)
            else if (PyBytes_Check(source) || PyUnicode_Check(source))
                goto error0;
            // ensure each item can be converted to wxPoint
            else {
                len = PySequence_Length(source);
                for (idx=0; idx<len; idx++) {
                    PyObject* item = PySequence_ITEM(source, idx);
                    if (!sipCanConvertToType(item, sipType_wxPoint, SIP_NOT_NONE)) {
                        Py_DECREF(item);
                        goto error0;
                    }
                    Py_DECREF(item);
                }
            }
        
            // The length of the sequence is returned in count.
            *count = len;
            array = new wxPoint[*count];
            if (!array) {
                PyErr_SetString(PyExc_MemoryError, "Unable to allocate temporary array");
                return NULL;
            }
            for (idx=0; idx<len; idx++) {
                PyObject* obj = PySequence_ITEM(source, idx);
                int state = 0;
                int err = 0;
                wxPoint* item = reinterpret_cast<wxPoint*>(
                                sipConvertToType(obj, sipType_wxPoint, NULL, 0, &state, &err));
                array[idx] = *item;
                sipReleaseType((void*)item, sipType_wxPoint, state); // delete temporary instances
                Py_DECREF(obj);
            }
            return array;
        
        error0:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of length-2 sequences or wx.Point objects.");
            return NULL;
        }
    %End
public:
    wxRegion();
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        const wxPoint & topLeft,
        const wxPoint & bottomRight
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        const wxRect & rect
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        const wxRegion & region
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        const wxBitmap & bmp
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(
        const wxBitmap & bmp,
        const wxColour & transColour,
        int tolerance = 0
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxRegion(PyObject* points, wxPolygonFillMode fillStyle = wxODDEVEN_RULE)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        size_t count;
        wxPoint* array = wxPoint_array_helper(points, &count);
        if ( array != NULL ) {
            sipCpp = new wxRegion(count, array, fillStyle);
            delete [] array;
        }
        if (PyErr_Occurred()) sipIsErr = 1;
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End

    ~wxRegion();

    wxRect GetBox() const;
    %Docstring
        GetBox() -> Rect
        
        Returns the outer bounds of the region.
    %End

    bool Offset(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        Offset(x, y) -> bool
        Offset(pt) -> bool
        
        Moves the region by the specified offsets in horizontal and vertical
        directions.
    %End

    bool Offset(
        const wxPoint & pt
    );

    void Clear();
    %Docstring
        Clear()
        
        Clears the current region.
    %End

    wxRegionContain Contains(
        wxCoord x,
        wxCoord y
    ) const;
    %Docstring
        Contains(x, y) -> RegionContain
        Contains(pt) -> RegionContain
        Contains(x, y, width, height) -> RegionContain
        Contains(rect) -> RegionContain
        
        Returns a value indicating whether the given point is contained within
        the region.
    %End

    wxRegionContain Contains(
        const wxPoint & pt
    ) const;

    wxRegionContain Contains(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    ) const;

    wxRegionContain Contains(
        const wxRect & rect
    ) const;

    wxBitmap ConvertToBitmap() const;
    %Docstring
        ConvertToBitmap() -> Bitmap
        
        Convert the region to a black and white bitmap with the white pixels
        being inside the region.
    %End

    bool Intersect(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        Intersect(x, y, width, height) -> bool
        Intersect(rect) -> bool
        Intersect(region) -> bool
        
        Finds the intersection of this region and another, rectangular region,
        specified using position and size.
    %End

    bool Intersect(
        const wxRect & rect
    );

    bool Intersect(
        const wxRegion & region
    );

    bool IsEmpty() const;
    %Docstring
        IsEmpty() -> bool
        
        Returns true if the region is empty, false otherwise.
    %End

    bool IsEqual(
        const wxRegion & region
    ) const;
    %Docstring
        IsEqual(region) -> bool
        
        Returns true if the region is equal to, i.e. covers the same area as,
        another one.
    %End

    bool Subtract(
        const wxRect & rect
    );
    %Docstring
        Subtract(rect) -> bool
        Subtract(region) -> bool
        
        Subtracts a rectangular region from this region.
    %End

    bool Subtract(
        const wxRegion & region
    );

    bool Union(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        Union(x, y, width, height) -> bool
        Union(rect) -> bool
        Union(region) -> bool
        Union(bmp) -> bool
        Union(bmp, transColour, tolerance=0) -> bool
        
        Finds the union of this region and another, rectangular region,
        specified using position and size.
    %End

    bool Union(
        const wxRect & rect
    );

    bool Union(
        const wxRegion & region
    );

    bool Union(
        const wxBitmap & bmp
    );

    bool Union(
        const wxBitmap & bmp,
        const wxColour & transColour,
        int tolerance = 0
    );

    bool Xor(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        Xor(x, y, width, height) -> bool
        Xor(rect) -> bool
        Xor(region) -> bool
        
        Finds the Xor of this region and another, rectangular region,
        specified using position and size.
    %End

    bool Xor(
        const wxRect & rect
    );

    bool Xor(
        const wxRegion & region
    );

    public:


    %Property(name=Box, get=GetBox)
};  // end of class wxRegion


%Extract(id=pycode_core)
def _Region___iter__(self):
    """
    Returns a rectangle iterator conforming to the Python iterator
    protocol.
    """
    return PyRegionIterator(self)
Region.__iter__ = _Region___iter__
del _Region___iter__
%End

%Extract(id=pycode_core)
class PyRegionIterator(object):
    "A Python iterator for wx.Region objects"
    def __init__(self, region):
        self._region = region
        self._iterator = wx.RegionIterator(region)
    def next(self):
        if not self._iterator:
            raise StopIteration
        rect = self._iterator.GetRect()
        if self._iterator.HaveRects():
            self._iterator.Next()
        return rect
    __next__ = next  # for Python 3

%End


//---------------------------------------------------------------------------

