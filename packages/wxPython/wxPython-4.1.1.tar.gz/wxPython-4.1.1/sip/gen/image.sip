//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

%ModuleHeaderCode
        #include <wx/imaggif.h>
        #include <wx/imagiff.h>
        #include <wx/imagjpeg.h>
        #include <wx/imagpcx.h>
        #include <wx/imagpng.h>
        #include <wx/imagpnm.h>
        #include <wx/imagtga.h>
        #include <wx/imagtiff.h>
        #include <wx/imagxpm.h>
        
#include <wx/anidecod.h>
%End


//---------------------------------------------------------------------------

enum wxImageResolution
{
    wxIMAGE_RESOLUTION_NONE,
    wxIMAGE_RESOLUTION_INCHES,
    wxIMAGE_RESOLUTION_CM
};

enum wxImageResizeQuality
{
    wxIMAGE_QUALITY_NEAREST,
    wxIMAGE_QUALITY_BILINEAR,
    wxIMAGE_QUALITY_BICUBIC,
    wxIMAGE_QUALITY_BOX_AVERAGE,
    wxIMAGE_QUALITY_NORMAL,
    wxIMAGE_QUALITY_HIGH
};

enum wxImageAlphaBlendMode
{
    wxIMAGE_ALPHA_BLEND_OVER,
    wxIMAGE_ALPHA_BLEND_COMPOSE
};

enum wxImagePNGType
{
    wxPNG_TYPE_COLOUR,
    wxPNG_TYPE_GREY,
    wxPNG_TYPE_GREY_RED,
    wxPNG_TYPE_PALETTE
};

enum 
{
    wxBMP_24BPP,
    wxBMP_8BPP,
    wxBMP_8BPP_GREY,
    wxBMP_8BPP_GRAY,
    wxBMP_8BPP_RED,
    wxBMP_8BPP_PALETTE,
    wxBMP_4BPP,
    wxBMP_1BPP,
    wxBMP_1BPP_BW
};

const unsigned char wxIMAGE_ALPHA_TRANSPARENT   /PyInt/;

const unsigned char wxIMAGE_ALPHA_OPAQUE   /PyInt/;

const unsigned char wxIMAGE_ALPHA_THRESHOLD   /PyInt/;

class wxImage : wxObject
{
    %Docstring
        Image()
        Image(width, height, clear=True)
        Image(sz, clear=True)
        Image(name, type=BITMAP_TYPE_ANY, index=-1)
        Image(name, mimetype, index=-1)
        Image(stream, type=BITMAP_TYPE_ANY, index=-1)
        Image(stream, mimetype, index=-1)
        Image(width, height, data)
        Image(width, height, data, alpha)
        Image(size, data)
        Image(size, data, alpha)
        
        This class encapsulates a platform-independent image.
    %End
    %TypeHeaderCode
        #include <wx/image.h>
    %End

public:
public:
    class HSVValue
    {
        %Docstring
            HSVValue(h=0.0, s=0.0, v=0.0)
            
            A simple class which stores hue, saturation and value as doubles in
            the range 0.0-1.0.
        %End
        %TypeHeaderCode
            #include <wx/image.h>
        %End

    public:
        HSVValue(
            double h = 0.0,
            double s = 0.0,
            double v = 0.0
        );

        double hue;

        double saturation;

        double value;

    };  // end of class HSVValue


public:
    class RGBValue
    {
        %Docstring
            RGBValue(r=0, g=0, b=0)
            
            A simple class which stores red, green and blue values as 8 bit
            unsigned integers in the range of 0-255.
        %End
        %TypeHeaderCode
            #include <wx/image.h>
        %End

    public:
        RGBValue(
            unsigned char r   /PyInt/ = 0,
            unsigned char g   /PyInt/ = 0,
            unsigned char b   /PyInt/ = 0
        );

        unsigned char red   /PyInt/;

        unsigned char green   /PyInt/;

        unsigned char blue   /PyInt/;

    };  // end of class RGBValue


    wxImage();

    wxImage(
        int width,
        int height,
        bool clear = true
    );

    wxImage(
        const wxSize & sz,
        bool clear = true
    );

    wxImage(
        const wxString & name,
        wxBitmapType type = wxBITMAP_TYPE_ANY,
        int index = -1
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxImage(
        const wxString & name,
        const wxString & mimetype,
        int index = -1
    );

    wxImage(
        wxInputStream & stream,
        wxBitmapType type = wxBITMAP_TYPE_ANY,
        int index = -1
    );

    wxImage(
        wxInputStream & stream,
        const wxString & mimetype,
        int index = -1
    );

    wxImage(int width, int height, wxPyBuffer* data)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        if (! data->checkSize(width*height*3))
            return NULL;
        void* copy = data->copy();
        if (! copy)
            return NULL;
        sipCpp = new sipwxImage;
        sipCpp->Create(width, height, (byte*)copy);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End

    wxImage(int width, int height, wxPyBuffer* data, wxPyBuffer* alpha)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        void* dcopy; void* acopy;
        if (!data->checkSize(width*height*3) || !alpha->checkSize(width*height))
            return NULL;
        if ((dcopy = data->copy()) == NULL || (acopy = alpha->copy()) == NULL)
            return NULL;
        sipCpp = new sipwxImage;
        sipCpp->Create(width, height, (byte*)dcopy, (byte*)acopy, false);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End

    wxImage(const wxSize& size, wxPyBuffer* data)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        if (! data->checkSize(size->x*size->y*3))
            return NULL;
        void* copy = data->copy();
        if (! copy)
            return NULL;
        sipCpp = new sipwxImage;
        sipCpp->Create(size->x, size->y, (byte*)copy, false);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End

    wxImage(const wxSize& size, wxPyBuffer* data, wxPyBuffer* alpha)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        void* dcopy; void* acopy;
        if (!data->checkSize(size->x*size->y*3) || !alpha->checkSize(size->x*size->y))
            return NULL;
        if ((dcopy = data->copy()) == NULL || (acopy = alpha->copy()) == NULL)
            return NULL;
        sipCpp = new sipwxImage;
        sipCpp->Create(size->x, size->y, (byte*)dcopy, (byte*)acopy, false);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End

    virtual
    ~wxImage();

    wxImage Copy() const;
    %Docstring
        Copy() -> Image
        
        Returns an identical copy of this image.
    %End

    bool Create(
        int width,
        int height,
        bool clear = true
    );
    %Docstring
        Create(width, height, clear=True) -> bool
        Create(sz, clear=True) -> bool
        Create(width, height, data) -> bool
        Create(width, height, data, alpha) -> bool
        Create(size, data) -> bool
        Create(size, data, alpha) -> bool
        
        Creates a fresh image.
    %End

    bool Create(
        const wxSize & sz,
        bool clear = true
    );

    bool Create(int width,  int height,  wxPyBuffer* data);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_Create(sipCpp, width, height, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxImage_Create(wxImage* self, int width, int height, wxPyBuffer* data)
    {
        if (! data->checkSize(width*height*3))
            return false;
        void* copy = data->copy();
        if (! copy)
            return false;
        return self->Create(width, height, (byte*)copy);
    }
    %End

    bool Create(int width,  int height,  wxPyBuffer* data,  wxPyBuffer* alpha);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_Create(sipCpp, width, height, data, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxImage_Create(wxImage* self, int width, int height, wxPyBuffer* data, wxPyBuffer* alpha)
    {
        void* dcopy; void* acopy;
        if (!data->checkSize(width*height*3) || !alpha->checkSize(width*height))
            return false;
        if ((dcopy = data->copy()) == NULL || (acopy = alpha->copy()) == NULL)
            return false;
        return self->Create(width, height, (byte*)dcopy, (byte*)acopy);
    }
    %End

    bool Create(const wxSize& size,  wxPyBuffer* data);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_Create(sipCpp, size, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxImage_Create(wxImage* self, const wxSize* size, wxPyBuffer* data)
    {
        if (! data->checkSize(size->x*size->y*3))
            return false;
        void* copy = data->copy();
        if (! copy)
            return false;
        return self->Create(size->x, size->y, (byte*)copy);
    }
    %End

    bool Create(const wxSize& size,  wxPyBuffer* data,  wxPyBuffer* alpha);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_Create(sipCpp, size, data, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    bool _wxImage_Create(wxImage* self, const wxSize* size, wxPyBuffer* data, wxPyBuffer* alpha)
    {
        void* dcopy; void* acopy;
        if (!data->checkSize(size->x*size->y*3) || !alpha->checkSize(size->x*size->y))
            return false;
        if ((dcopy = data->copy()) == NULL || (acopy = alpha->copy()) == NULL)
            return false;
        return self->Create(size->x, size->y, (byte*)dcopy, (byte*)acopy);
    }
    %End

    void Clear(
        unsigned char value = 0
    );
    %Docstring
        Clear(value=0)
        
        Initialize the image data with zeroes (the default) or with the byte
        value given as value.
    %End

    void Destroy();
    %Docstring
        Destroy()
        
        Destroys the image data.
    %End

    void InitAlpha();
    %Docstring
        InitAlpha()
        
        Initializes the image alpha channel data.
    %End

    wxImage Blur(
        int blurRadius
    ) const;
    %Docstring
        Blur(blurRadius) -> Image
        
        Blurs the image in both horizontal and vertical directions by the
        specified pixel blurRadius.
    %End

    wxImage BlurHorizontal(
        int blurRadius
    ) const;
    %Docstring
        BlurHorizontal(blurRadius) -> Image
        
        Blurs the image in the horizontal direction only.
    %End

    wxImage BlurVertical(
        int blurRadius
    ) const;
    %Docstring
        BlurVertical(blurRadius) -> Image
        
        Blurs the image in the vertical direction only.
    %End

    wxImage Mirror(
        bool horizontally = true
    ) const;
    %Docstring
        Mirror(horizontally=True) -> Image
        
        Returns a mirrored copy of the image.
    %End

    void Paste(
        const wxImage & image,
        int x,
        int y,
        wxImageAlphaBlendMode alphaBlend = wxIMAGE_ALPHA_BLEND_OVER
    );
    %Docstring
        Paste(image, x, y, alphaBlend=IMAGE_ALPHA_BLEND_OVER)
        
        Copy the data of the given image to the specified position in this
        image.
    %End

    void Replace(
        unsigned char r1   /PyInt/,
        unsigned char g1   /PyInt/,
        unsigned char b1   /PyInt/,
        unsigned char r2   /PyInt/,
        unsigned char g2   /PyInt/,
        unsigned char b2   /PyInt/
    );
    %Docstring
        Replace(r1, g1, b1, r2, g2, b2)
        
        Replaces the colour specified by r1,g1,b1 by the colour r2,g2,b2.
    %End

    wxImage & Rescale(
        int width,
        int height,
        wxImageResizeQuality quality = wxIMAGE_QUALITY_NORMAL
    );
    %Docstring
        Rescale(width, height, quality=IMAGE_QUALITY_NORMAL) -> Image
        
        Changes the size of the image in-place by scaling it: after a call to
        this function,the image will have the given width and height.
    %End

    wxImage & Resize(
        const wxSize & size,
        const wxPoint & pos,
        int red = -1,
        int green = -1,
        int blue = -1
    );
    %Docstring
        Resize(size, pos, red=-1, green=-1, blue=-1) -> Image
        
        Changes the size of the image in-place without scaling it by adding
        either a border with the given colour or cropping as necessary.
    %End

    wxImage Rotate(
        double angle,
        const wxPoint & rotationCentre,
        bool interpolating = true,
        wxPoint * offsetAfterRotation = NULL
    ) const;
    %Docstring
        Rotate(angle, rotationCentre, interpolating=True, offsetAfterRotation=None) -> Image
        
        Rotates the image about the given point, by angle radians.
    %End

    wxImage Rotate90(
        bool clockwise = true
    ) const;
    %Docstring
        Rotate90(clockwise=True) -> Image
        
        Returns a copy of the image rotated 90 degrees in the direction
        indicated by clockwise.
    %End

    wxImage Rotate180() const;
    %Docstring
        Rotate180() -> Image
        
        Returns a copy of the image rotated by 180 degrees.
    %End

    void RotateHue(
        double angle
    );
    %Docstring
        RotateHue(angle)
        
        Rotates the hue of each pixel in the image by angle, which is a double
        in the range of -1.0 to +1.0, where -1.0 corresponds to -360 degrees
        and +1.0 corresponds to +360 degrees.
    %End

    wxImage Scale(
        int width,
        int height,
        wxImageResizeQuality quality = wxIMAGE_QUALITY_NORMAL
    ) const;
    %Docstring
        Scale(width, height, quality=IMAGE_QUALITY_NORMAL) -> Image
        
        Returns a scaled version of the image.
    %End

    wxImage Size(
        const wxSize & size,
        const wxPoint & pos,
        int red = -1,
        int green = -1,
        int blue = -1
    ) const;
    %Docstring
        Size(size, pos, red=-1, green=-1, blue=-1) -> Image
        
        Returns a resized version of this image without scaling it by adding
        either a border with the given colour or cropping as necessary.
    %End

    bool ConvertAlphaToMask(
        unsigned char threshold   /PyInt/ = wxIMAGE_ALPHA_THRESHOLD
    );
    %Docstring
        ConvertAlphaToMask(threshold=IMAGE_ALPHA_THRESHOLD) -> bool
        ConvertAlphaToMask(mr, mg, mb, threshold=IMAGE_ALPHA_THRESHOLD) -> bool
        
        If the image has alpha channel, this method converts it to mask.
    %End

    bool ConvertAlphaToMask(
        unsigned char mr   /PyInt/,
        unsigned char mg   /PyInt/,
        unsigned char mb   /PyInt/,
        unsigned char threshold   /PyInt/ = wxIMAGE_ALPHA_THRESHOLD
    );

    wxImage ConvertToGreyscale(
        double weight_r,
        double weight_g,
        double weight_b
    ) const;
    %Docstring
        ConvertToGreyscale(weight_r, weight_g, weight_b) -> Image
        ConvertToGreyscale() -> Image
        
        Returns a greyscale version of the image.
    %End

    wxImage ConvertToGreyscale() const;

    wxImage ConvertToMono(
        unsigned char r   /PyInt/,
        unsigned char g   /PyInt/,
        unsigned char b   /PyInt/
    ) const;
    %Docstring
        ConvertToMono(r, g, b) -> Image
        
        Returns monochromatic version of the image.
    %End

    wxImage ConvertToDisabled(
        unsigned char brightness   /PyInt/ = 255
    ) const;
    %Docstring
        ConvertToDisabled(brightness=255) -> Image
        
        Returns disabled (dimmed) version of the image.
    %End

    unsigned long ComputeHistogram(
        wxImageHistogram & histogram
    ) const;
    %Docstring
        ComputeHistogram(histogram) -> unsignedlong
        
        Computes the histogram of the image.
    %End

    void FindFirstUnusedColour(
        unsigned char * r   /Out, PyInt/,
        unsigned char * g   /Out, PyInt/,
        unsigned char * b   /Out, PyInt/,
        unsigned char startR   /PyInt/ = 1,
        unsigned char startG   /PyInt/ = 0,
        unsigned char startB   /PyInt/ = 0
    ) const;
    %Docstring
        FindFirstUnusedColour(startR=1, startG=0, startB=0) -> (r, g, b)
        
        Finds the first colour that is never used in the image.
    %End

    unsigned char GetAlpha(
        int x,
        int y
    ) const   /PyInt/;
    %Docstring
        GetAlpha(x, y) -> unsignedchar
        GetAlpha() -> PyObject
        
        Return alpha value at given pixel location.
    %End

    PyObject* GetAlpha();
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_GetAlpha(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxImage_GetAlpha(wxImage* self)
    {
        byte* data = self->GetAlpha();
        Py_ssize_t len = self->GetWidth() * self->GetHeight();
        PyObject* rv = NULL;
        wxPyBLOCK_THREADS( rv = PyByteArray_FromStringAndSize((const char*)data, len));
        return rv;
    }
    %End

    PyObject* GetData();
    %Docstring
        GetData() -> PyObject
        
        Returns a copy of the RGB bytes of the image.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_GetData(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxImage_GetData(wxImage* self)
    {
        byte* data = self->GetData();
        Py_ssize_t len = self->GetWidth() * self->GetHeight() * 3;
        PyObject* rv = NULL;
        wxPyBLOCK_THREADS( rv = PyByteArray_FromStringAndSize((const char*)data, len));
        return rv;
    }
    %End

    unsigned char GetRed(
        int x,
        int y
    ) const   /PyInt/;
    %Docstring
        GetRed(x, y) -> unsignedchar
        
        Returns the red intensity at the given coordinate.
    %End

    unsigned char GetGreen(
        int x,
        int y
    ) const   /PyInt/;
    %Docstring
        GetGreen(x, y) -> unsignedchar
        
        Returns the green intensity at the given coordinate.
    %End

    unsigned char GetBlue(
        int x,
        int y
    ) const   /PyInt/;
    %Docstring
        GetBlue(x, y) -> unsignedchar
        
        Returns the blue intensity at the given coordinate.
    %End

    unsigned char GetMaskRed() const   /PyInt/;
    %Docstring
        GetMaskRed() -> unsignedchar
        
        Gets the red value of the mask colour.
    %End

    unsigned char GetMaskGreen() const   /PyInt/;
    %Docstring
        GetMaskGreen() -> unsignedchar
        
        Gets the green value of the mask colour.
    %End

    unsigned char GetMaskBlue() const   /PyInt/;
    %Docstring
        GetMaskBlue() -> unsignedchar
        
        Gets the blue value of the mask colour.
    %End

    int GetWidth() const;
    %Docstring
        GetWidth() -> int
        
        Gets the width of the image in pixels.
    %End

    int GetHeight() const;
    %Docstring
        GetHeight() -> int
        
        Gets the height of the image in pixels.
    %End

    wxSize GetSize() const;
    %Docstring
        GetSize() -> Size
        
        Returns the size of the image in pixels.
    %End

    wxString GetOption(
        const wxString & name
    ) const;
    %Docstring
        GetOption(name) -> String
        
        Gets a user-defined string-valued option.
    %End

    int GetOptionInt(
        const wxString & name
    ) const;
    %Docstring
        GetOptionInt(name) -> int
        
        Gets a user-defined integer-valued option.
    %End

    void GetOrFindMaskColour(
        unsigned char * r   /Out, PyInt/,
        unsigned char * g   /Out, PyInt/,
        unsigned char * b   /Out, PyInt/
    ) const;
    %Docstring
        GetOrFindMaskColour() -> (r, g, b)
        
        Get the current mask colour or find a suitable unused colour that
        could be used as a mask colour.
    %End

    const wxPalette & GetPalette() const;
    %Docstring
        GetPalette() -> Palette
        
        Returns the palette associated with the image.
    %End

    wxImage GetSubImage(
        const wxRect & rect
    ) const;
    %Docstring
        GetSubImage(rect) -> Image
        
        Returns a sub image of the current one as long as the rect belongs
        entirely to the image.
    %End

    wxBitmapType GetType() const;
    %Docstring
        GetType() -> BitmapType
        
        Gets the type of image found by LoadFile() or specified with
        SaveFile().
    %End

    bool HasAlpha() const;
    %Docstring
        HasAlpha() -> bool
        
        Returns true if this image has alpha channel, false otherwise.
    %End

    bool HasMask() const;
    %Docstring
        HasMask() -> bool
        
        Returns true if there is a mask active, false otherwise.
    %End

    bool HasOption(
        const wxString & name
    ) const;
    %Docstring
        HasOption(name) -> bool
        
        Returns true if the given option is present.
    %End

    bool IsOk() const;
    %Docstring
        IsOk() -> bool
        
        Returns true if image data is present.
    %End

    bool IsTransparent(
        int x,
        int y,
        unsigned char threshold   /PyInt/ = wxIMAGE_ALPHA_THRESHOLD
    ) const;
    %Docstring
        IsTransparent(x, y, threshold=IMAGE_ALPHA_THRESHOLD) -> bool
        
        Returns true if the given pixel is transparent, i.e. either has the
        mask colour if this image has a mask or if this image has alpha
        channel and alpha value of this pixel is strictly less than threshold.
    %End

    virtual
    bool LoadFile(
        wxInputStream & stream,
        wxBitmapType type = wxBITMAP_TYPE_ANY,
        int index = -1
    );
    %Docstring
        LoadFile(stream, type=BITMAP_TYPE_ANY, index=-1) -> bool
        LoadFile(name, type=BITMAP_TYPE_ANY, index=-1) -> bool
        LoadFile(name, mimetype, index=-1) -> bool
        LoadFile(stream, mimetype, index=-1) -> bool
        
        Loads an image from an input stream.
    %End

    virtual
    bool LoadFile(
        const wxString & name,
        wxBitmapType type = wxBITMAP_TYPE_ANY,
        int index = -1
    );

    virtual
    bool LoadFile(
        const wxString & name,
        const wxString & mimetype,
        int index = -1
    );

    virtual
    bool LoadFile(
        wxInputStream & stream,
        const wxString & mimetype,
        int index = -1
    );

    virtual
    bool SaveFile(
        wxOutputStream & stream,
        const wxString & mimetype
    ) const;
    %Docstring
        SaveFile(stream, mimetype) -> bool
        SaveFile(name, type) -> bool
        SaveFile(name, mimetype) -> bool
        SaveFile(name) -> bool
        SaveFile(stream, type) -> bool
        
        Saves an image in the given stream.
    %End

    virtual
    bool SaveFile(
        const wxString & name,
        wxBitmapType type
    ) const;

    virtual
    bool SaveFile(
        const wxString & name,
        const wxString & mimetype
    ) const;

    virtual
    bool SaveFile(
        const wxString & name
    ) const;

    virtual
    bool SaveFile(
        wxOutputStream & stream,
        wxBitmapType type
    ) const;

    void SetAlpha(
        int x,
        int y,
        unsigned char alpha   /PyInt/
    );
    %Docstring
        SetAlpha(x, y, alpha)
        SetAlpha(alpha)
        
        Sets the alpha value for the given pixel.
    %End

    void SetAlpha(wxPyBuffer* alpha);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetAlpha(sipCpp, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetAlpha(wxImage* self, wxPyBuffer* alpha)
    {
        if (!alpha->checkSize(self->GetWidth()*self->GetHeight()))
            return;
        void* copy = alpha->copy();
        if (!copy)
            return;
        self->SetAlpha((byte*)copy, false);
    }
    %End

    void ClearAlpha();
    %Docstring
        ClearAlpha()
        
        Removes the alpha channel from the image.
    %End

    void SetData(wxPyBuffer* data);
    %Docstring
        SetData(data)
        SetData(data, new_width, new_height)
        
        Sets the image data without performing checks.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetData(sipCpp, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetData(wxImage* self, wxPyBuffer* data)
    {
        if (!data->checkSize(self->GetWidth()*self->GetHeight()*3))
            return;
        void* copy = data->copy();
        if (!copy)
            return;
        self->SetData((byte*)copy, false);
    }
    %End

    void SetData(wxPyBuffer* data,  int new_width,  int new_height);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetData(sipCpp, data, new_width, new_height);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetData(wxImage* self, wxPyBuffer* data, int new_width, int new_height)
    {
        if (!data->checkSize(new_width*new_height*3))
            return;
        void* copy = data->copy();
        if (!copy)
            return;
        self->SetData((byte*)copy, new_width, new_height, false);
    }
    %End

    void SetLoadFlags(
        int flags
    );
    %Docstring
        SetLoadFlags(flags)
        
        Sets the flags used for loading image files by this object.
    %End

    void SetMask(
        bool hasMask = true
    );
    %Docstring
        SetMask(hasMask=True)
        
        Specifies whether there is a mask or not.
    %End

    void SetMaskColour(
        unsigned char red   /PyInt/,
        unsigned char green   /PyInt/,
        unsigned char blue   /PyInt/
    );
    %Docstring
        SetMaskColour(red, green, blue)
        
        Sets the mask colour for this image (and tells the image to use the
        mask).
    %End

    bool SetMaskFromImage(
        const wxImage & mask,
        unsigned char mr   /PyInt/,
        unsigned char mg   /PyInt/,
        unsigned char mb   /PyInt/
    );
    %Docstring
        SetMaskFromImage(mask, mr, mg, mb) -> bool
        
        Sets image's mask so that the pixels that have RGB value of mr,mg,mb
        in mask will be masked in the image.
    %End

    void SetOption(
        const wxString & name,
        const wxString & value
    );
    %Docstring
        SetOption(name, value)
        SetOption(name, value)
        
        Sets a user-defined option.
    %End

    void SetOption(
        const wxString & name,
        int value
    );

    void SetPalette(
        const wxPalette & palette
    );
    %Docstring
        SetPalette(palette)
        
        Associates a palette with the image.
    %End

    void SetRGB(
        int x,
        int y,
        unsigned char r   /PyInt/,
        unsigned char g   /PyInt/,
        unsigned char b   /PyInt/
    );
    %Docstring
        SetRGB(x, y, r, g, b)
        SetRGB(rect, red, green, blue)
        
        Set the color of the pixel at the given x and y coordinate.
    %End

    void SetRGB(
        const wxRect & rect,
        unsigned char red   /PyInt/,
        unsigned char green   /PyInt/,
        unsigned char blue   /PyInt/
    );

    void SetType(
        wxBitmapType type
    );
    %Docstring
        SetType(type)
        
        Set the type of image returned by GetType().
    %End

    static
    void SetDefaultLoadFlags(
        int flags
    );
    %Docstring
        SetDefaultLoadFlags(flags)
        
        Sets the default value for the flags used for loading image files.
    %End

    static
    void AddHandler(
        wxImageHandler * handler
    );
    %Docstring
        AddHandler(handler)
        
        Register an image handler.
    %End

    static
    void CleanUpHandlers();
    %Docstring
        CleanUpHandlers()
        
        Deletes all image handlers.
    %End

    static
    wxImageHandler * FindHandler(
        const wxString & name
    );
    %Docstring
        FindHandler(name) -> ImageHandler
        FindHandler(extension, imageType) -> ImageHandler
        FindHandler(imageType) -> ImageHandler
        
        Finds the handler with the given name.
    %End

    static
    wxImageHandler * FindHandler(
        const wxString & extension,
        wxBitmapType imageType
    );

    static
    wxImageHandler * FindHandler(
        wxBitmapType imageType
    );

    static
    wxImageHandler * FindHandlerMime(
        const wxString & mimetype
    );
    %Docstring
        FindHandlerMime(mimetype) -> ImageHandler
        
        Finds the handler associated with the given MIME type.
    %End

    static
    void InitStandardHandlers();
    %Docstring
        InitStandardHandlers()
        
        Internal use only.
    %End

    static
    void InsertHandler(
        wxImageHandler * handler
    );
    %Docstring
        InsertHandler(handler)
        
        Adds a handler at the start of the static list of format handlers.
    %End

    static
    bool RemoveHandler(
        const wxString & name
    );
    %Docstring
        RemoveHandler(name) -> bool
        
        Finds the handler with the given name, and removes it.
    %End

    static
    int GetImageCount(
        const wxString & filename,
        wxBitmapType type = wxBITMAP_TYPE_ANY
    );
    %Docstring
        GetImageCount(filename, type=BITMAP_TYPE_ANY) -> int
        GetImageCount(stream, type=BITMAP_TYPE_ANY) -> int
        
        If the image file contains more than one image and the image handler
        is capable of retrieving these individually, this function will return
        the number of available images.
    %End

    static
    int GetImageCount(
        wxInputStream & stream,
        wxBitmapType type = wxBITMAP_TYPE_ANY
    );

    int GetLoadFlags() const;
    %Docstring
        GetLoadFlags() -> int
        
        Returns the file load flags used for this object.
    %End

    static
    bool CanRead(
        const wxString & filename
    );
    %Docstring
        CanRead(filename) -> bool
        CanRead(stream) -> bool
        
        Returns true if at least one of the available image handlers can read
        the file with the given name.
    %End

    static
    bool CanRead(
        wxInputStream & stream
    );

    static
    int GetDefaultLoadFlags();
    %Docstring
        GetDefaultLoadFlags() -> int
        
        Returns the currently used default file load flags.
    %End

    static
    wxString GetImageExtWildcard();
    %Docstring
        GetImageExtWildcard() -> String
        
        Iterates all registered wxImageHandler objects, and returns a string
        containing file extension masks suitable for passing to file open/save
        dialog boxes.
    %End

    static
    wxImage::HSVValue RGBtoHSV(
        const wxImage::RGBValue & rgb
    );
    %Docstring
        RGBtoHSV(rgb) -> Image.HSVValue
        
        Converts a color in RGB color space to HSV color space.
    %End

    static
    wxImage::RGBValue HSVtoRGB(
        const wxImage::HSVValue & hsv
    );
    %Docstring
        HSVtoRGB(hsv) -> Image.RGBValue
        
        Converts a color in HSV color space to RGB color space.
    %End

    PyObject* GetDataBuffer();
    %Docstring
        GetDataBuffer() -> PyObject
        
        Returns a writable Python buffer object that is pointing at the RGB
        image data buffer inside the :class:`Image`. You need to ensure that
        you do
        not use this buffer object after the image has been destroyed.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_GetDataBuffer(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxImage_GetDataBuffer(wxImage* self)
    {
        byte* data = self->GetData();
        Py_ssize_t len = self->GetWidth() * self->GetHeight() * 3;
        PyObject* rv;
        wxPyThreadBlocker blocker;
        rv = wxPyMakeBuffer(data, len);
        return rv;
    }
    %End

    PyObject* GetAlphaBuffer();
    %Docstring
        GetAlphaBuffer() -> PyObject
        
        Returns a writable Python buffer object that is pointing at the Alpha
        data buffer inside the :class:`Image`. You need to ensure that you do
        not use this buffer object after the image has been destroyed.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_GetAlphaBuffer(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxImage_GetAlphaBuffer(wxImage* self)
    {
        byte* data = self->GetAlpha();
        Py_ssize_t len = self->GetWidth() * self->GetHeight();
        PyObject* rv;
        wxPyThreadBlocker blocker;
        rv = wxPyMakeBuffer(data, len);
        return rv;
    }
    %End

    void SetDataBuffer(wxPyBuffer* data);
    %Docstring
        SetDataBuffer(data)
        SetDataBuffer(data, new_width, new_height)
        
        Sets the internal image data pointer to point at a Python buffer
        object.  This can save making an extra copy of the data but you must
        ensure that the buffer object lives lives at least as long as the
        :class:`Image` does.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetDataBuffer(sipCpp, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetDataBuffer(wxImage* self, wxPyBuffer* data)
    {
        if (!data->checkSize(self->GetWidth() * self->GetHeight() * 3))
            return;
        // True means don't free() the pointer
        self->SetData((byte*)data->m_ptr, true);
    }
    %End

    void SetDataBuffer(wxPyBuffer* data,  int new_width,  int new_height);
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetDataBuffer(sipCpp, data, new_width, new_height);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetDataBuffer(wxImage* self, wxPyBuffer* data, int new_width, int new_height)
    {
        if (!data->checkSize(new_width * new_height * 3))
            return;
        // True means don't free() the pointer
        self->SetData((byte*)data->m_ptr, new_width, new_height, true);
    }
    %End

    void SetAlphaBuffer(wxPyBuffer* alpha);
    %Docstring
        SetAlphaBuffer(alpha)
        
        Sets the internal image alpha pointer to point at a Python buffer
        object.  This can save making an extra copy of the data but you must
        ensure that the buffer object lives lives at least as long as the
        :class:`Image` does.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxImage_SetAlphaBuffer(sipCpp, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxImage_SetAlphaBuffer(wxImage* self, wxPyBuffer* alpha)
    {
        if (!alpha->checkSize(self->GetWidth() * self->GetHeight()))
            return;
        // True means don't free() the pointer
        self->SetAlpha((byte*)alpha->m_ptr, true);
    }
    %End

    int __nonzero__();
    %Docstring
        __nonzero__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage___nonzero__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxImage___nonzero__(wxImage* self)
    {
        return self->IsOk();
    }
    %End

    int __bool__();
    %Docstring
        __bool__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage___bool__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxImage___bool__(wxImage* self)
    {
        return self->IsOk();
    }
    %End

    wxImage* AdjustChannels(double factor_red,  double factor_green,  double factor_blue,  double factor_alpha=1.0)   /Factory/;
    %Docstring
        AdjustChannels(factor_red, factor_green, factor_blue, factor_alpha=1.0) -> Image
        
        This function muliplies all 4 channels (red, green, blue, alpha) with
        a factor (around 1.0). Useful for gamma correction, colour correction
        and to add a certain amount of transparency to a image (fade in fade
        out effects). If factor_alpha is given but the original image has no
        alpha channel then a alpha channel will be added.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_AdjustChannels(sipCpp, factor_red, factor_green, factor_blue, factor_alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxImage* _wxImage_AdjustChannels(wxImage* self, double factor_red, double factor_green, double factor_blue, double factor_alpha)
    {
        wxCHECK_MSG( self->Ok(), NULL, wxT("invalid image") );
        
        wxImage* dest = new wxImage( self->GetWidth(), self->GetHeight(), false );
        wxCHECK_MSG( dest && dest->IsOk(), NULL, wxT("unable to create image") );
        
        unsigned rgblen =   3 * self->GetWidth() * self->GetHeight();
        unsigned alphalen = self->GetWidth() * self->GetHeight();
        byte* src_data =  self->GetData();
        byte* src_alpha = self->GetAlpha();
        byte* dst_data =  dest->GetData();
        byte* dst_alpha = NULL;
        
        // adjust rgb
        if ( factor_red == 1.0 && factor_green == 1.0 && factor_blue == 1.0)
        {
            // nothing to do for RGB
            memcpy(dst_data, src_data, rgblen);
        }
        else
        {
            // rgb pixel for pixel
            for ( unsigned i = 0; i < rgblen; i= i + 3 )
            {
                dst_data[i] =     (byte) wxMin( 255, (int) (factor_red * src_data[i]) );
                dst_data[i + 1] = (byte) wxMin( 255, (int) (factor_green * src_data[i + 1]) );
                dst_data[i + 2] = (byte) wxMin( 255, (int) (factor_blue * src_data[i + 2]) );
            }
        }
        
        // adjust the mask colour
        if ( self->HasMask() )
        {
            dest->SetMaskColour((byte) wxMin( 255, (int) (factor_red * self->GetMaskRed() ) ),
                                (byte) wxMin( 255, (int) (factor_green * self->GetMaskGreen() ) ),
                                (byte) wxMin( 255, (int) (factor_blue * self->GetMaskBlue() ) ) );
        }
        
        // adjust the alpha channel
        if ( src_alpha )
        {
            // source image already has alpha information
            dest->SetAlpha(); // create an empty alpha channel (not initialized)
            dst_alpha = dest->GetAlpha();
        
            wxCHECK_MSG( dst_alpha, NULL, wxT("unable to create alpha data") );
        
            if ( factor_alpha == 1.0)
            {
                // no need to adjust
                memcpy(dst_alpha, src_alpha, alphalen);
            }
            else
            {
                // alpha value for alpha value
                for ( unsigned i = 0; i < alphalen; ++i )
                {
                    dst_alpha[i] = (byte) wxMin( 255, (int) (factor_alpha * src_alpha[i]) );
                }
            }
        }
        else if ( factor_alpha != 1.0 )
        {
            // no alpha yet but we want to adjust -> create
            dest->SetAlpha(); // create an empty alpha channel (not initialized)
            dst_alpha = dest->GetAlpha();
        
            wxCHECK_MSG( dst_alpha, NULL, wxT("unable to create alpha data") );
        
            for ( unsigned i = 0; i < alphalen; ++i )
            {
                dst_alpha[i] = (byte) wxMin( 255, (int) (factor_alpha * 255) );
            }
        }
        
        // do we have an alpha channel and a mask in the new image?
        if ( dst_alpha && dest->HasMask() )
        {
            // make the mask transparent honoring the alpha channel
            const byte mr = dest->GetMaskRed();
            const byte mg = dest->GetMaskGreen();
            const byte mb = dest->GetMaskBlue();
        
            for ( unsigned i = 0; i < alphalen; ++i )
            {
                int n = i * 3;
                dst_alpha[i] = ( dst_data[n] == mr && dst_data[n + 1] == mg && dst_data[n + 2] == mb )
                    ? wxIMAGE_ALPHA_TRANSPARENT
                    : dst_alpha[i];
            }
        
            // remove the mask now
            dest->SetMask(false);
        }
        
        return dest;
    }
    %End

    %Property(name=Width, get=GetWidth)
    %Property(name=Height, get=GetHeight)
    %Property(name=MaskBlue, get=GetMaskBlue)
    %Property(name=MaskGreen, get=GetMaskGreen)
    %Property(name=MaskRed, get=GetMaskRed)
    %Property(name=Type, get=GetType, set=SetType)
    wxRegion* ConvertToRegion(int R=-1,  int G=-1,  int B=-1,  int tolerance=0);
    %Docstring
        ConvertToRegion(R=-1, G=-1, B=-1, tolerance=0) -> Region
        
        Create a :class:`wx.Region` where the transparent areas match the
        given RGB values.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxImage_ConvertToRegion(sipCpp, R, G, B, tolerance);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxRegion* _wxImage_ConvertToRegion(wxImage* self, int R, int G, int B, int tolerance)
    {
        wxRegion* region = new wxRegion();
        unsigned char hiR, hiG, hiB;
        
        if (R == -1) { R = self->GetMaskRed(); }
        if (G == -1) { G = self->GetMaskGreen(); }
        if (B == -1) { B = self->GetMaskBlue(); }
        
        // Make sure nothing out of range was passed
        R &= 0xFF;
        G &= 0xFF;
        B &= 0xFF;
        
        hiR = (unsigned char)wxMin(0xFF, R + tolerance);
        hiG = (unsigned char)wxMin(0xFF, G + tolerance);
        hiB = (unsigned char)wxMin(0xFF, B + tolerance);
        
        // Loop through the image row by row, pixel by pixel, building up
        // rectangles to add to the region.
        int width = self->GetWidth();
        int height = self->GetHeight();
        
        for (int y=0; y < height; y++)
        {
            wxRect rect;
            rect.y = y;
            rect.height = 1;
        
            for (int x=0; x < width; x++)
            {
                // search for a continuous range of non-transparent pixels
                int x0 = x;
                while ( x < width)
                {
                    unsigned char red = self->GetRed(x,y);
                    unsigned char grn = self->GetGreen(x,y);
                    unsigned char blu = self->GetBlue(x,y);
                    if (( red >= R && red <= hiR) &&
                        ( grn >= G && grn <= hiG) &&
                        ( blu >= B && blu <= hiB))  // It's transparent
                        break;
                    x++;
                }
        
                // Add the run of non-transparent pixels (if any) to the region
                if (x > x0) {
                    rect.x = x0;
                    rect.width = x - x0;
                    region->Union(rect);
                }
            }
        }
        if (region->IsEmpty())
            region->Union(0, 0, width, height);
        return region;
    }
    %End

};  // end of class wxImage


%Extract(id=pycode_core)
def _Image_ConvertToBitmap(self, depth=-1):
    """
    ConvertToBitmap(depth=-1) -> Bitmap
    
    Convert the image to a :class:`wx.Bitmap`.
    """
    bmp = wx.Bitmap(self, depth)
    return bmp
Image.ConvertToBitmap = _Image_ConvertToBitmap
del _Image_ConvertToBitmap
%End

%Extract(id=pycode_core)
def _Image_ConvertToMonoBitmap(self, red, green, blue):
    """
    ConvertToMonoBitmap(red, green, blue) -> Bitmap
    
    Creates a monochrome version of the image and returns it as a :class:`wx.Bitmap`.
    """
    mono = self.ConvertToMono( red, green, blue )
    bmp = wx.Bitmap( mono, 1 )
    return bmp
Image.ConvertToMonoBitmap = _Image_ConvertToMonoBitmap
del _Image_ConvertToMonoBitmap
%End

class wxImageHistogram
{
    %Docstring
        ImageHistogram()
    %End
    %TypeHeaderCode
        #include <wx/image.h>
    %End

public:
    wxImageHistogram();

    void FindFirstUnusedColour(
        unsigned char * r   /Out, PyInt/,
        unsigned char * g   /Out, PyInt/,
        unsigned char * b   /Out, PyInt/,
        unsigned char startR   /PyInt/ = 1,
        unsigned char startG   /PyInt/ = 0,
        unsigned char startB   /PyInt/ = 0
    ) const;
    %Docstring
        FindFirstUnusedColour(startR=1, startG=0, startB=0) -> (r, g, b)
    %End

    static
    unsigned long MakeKey(
        unsigned char r   /PyInt/,
        unsigned char g   /PyInt/,
        unsigned char b   /PyInt/
    );
    %Docstring
        MakeKey(r, g, b) -> unsignedlong
    %End

};  // end of class wxImageHistogram


class wxImageHandler : wxObject
{
    %Docstring
        ImageHandler()
        
        This is the base class for implementing image file loading/saving, and
        image creation from data.
    %End
    %TypeHeaderCode
        #include <wx/image.h>
    %End

public:
    wxImageHandler();

    virtual
    ~wxImageHandler();

    bool CanRead(
        wxInputStream & stream
    );
    %Docstring
        CanRead(stream) -> bool
        CanRead(filename) -> bool
        
        Returns true if this handler supports the image format contained in
        the given stream.
    %End

    bool CanRead(
        const wxString & filename
    );

    const wxString & GetExtension() const;
    %Docstring
        GetExtension() -> String
        
        Gets the preferred file extension associated with this handler.
    %End

    const wxArrayString & GetAltExtensions() const;
    %Docstring
        GetAltExtensions() -> ArrayString
        
        Returns the other file extensions associated with this handler.
    %End

    int GetImageCount(
        wxInputStream & stream
    );
    %Docstring
        GetImageCount(stream) -> int
        
        If the image file contains more than one image and the image handler
        is capable of retrieving these individually, this function will return
        the number of available images.
    %End

    const wxString & GetMimeType() const;
    %Docstring
        GetMimeType() -> String
        
        Gets the MIME type associated with this handler.
    %End

    const wxString & GetName() const;
    %Docstring
        GetName() -> String
        
        Gets the name of this handler.
    %End

    wxBitmapType GetType() const;
    %Docstring
        GetType() -> BitmapType
        
        Gets the image type associated with this handler.
    %End

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End

    void SetExtension(
        const wxString & extension
    );
    %Docstring
        SetExtension(extension)
        
        Sets the preferred file extension associated with this handler.
    %End

    void SetAltExtensions(
        const wxArrayString & extensions
    );
    %Docstring
        SetAltExtensions(extensions)
        
        Sets the alternative file extensions associated with this handler.
    %End

    void SetMimeType(
        const wxString & mimetype
    );
    %Docstring
        SetMimeType(mimetype)
        
        Sets the handler MIME type.
    %End

    void SetName(
        const wxString & name
    );
    %Docstring
        SetName(name)
        
        Sets the handler name.
    %End

    void SetType(
        wxBitmapType type
    );
    %Docstring
        SetType(type)
        
        Sets the bitmap type for the handler.
    %End

    private:
        wxImageHandler(const wxImageHandler&);


    public:


    %Property(name=AltExtensions, get=GetAltExtensions, set=SetAltExtensions)
    %Property(name=Extension, get=GetExtension, set=SetExtension)
    %Property(name=MimeType, get=GetMimeType, set=SetMimeType)
    %Property(name=Name, get=GetName, set=SetName)
    %Property(name=Type, get=GetType, set=SetType)

protected:
    virtual
    int DoGetImageCount(
        wxInputStream & stream
    );
    %Docstring
        DoGetImageCount(stream) -> int
        
        Called to get the number of images available in a multi-image file
        type, if supported.
    %End

    virtual
    bool DoCanRead(
        wxInputStream & stream
    ) = 0;
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxImageHandler


class wxTIFFHandler : wxImageHandler
{
    %Docstring
        TIFFHandler()
        
        This is the image handler for the TIFF format.
    %End
    %TypeHeaderCode
        #include <wx/imagtiff.h>
    %End

public:
    wxTIFFHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxTIFFHandler


class wxGIFHandler : wxImageHandler
{
    %Docstring
        GIFHandler()
        
        This is the image handler for the GIF format.
    %End
    %TypeHeaderCode
        #include <wx/imaggif.h>
    %End

public:
    wxGIFHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End

    bool SaveAnimation(
        const wxImageArray & images,
        wxOutputStream * stream,
        bool verbose = true,
        int delayMilliSecs = 1000
    );
    %Docstring
        SaveAnimation(images, stream, verbose=True, delayMilliSecs=1000) -> bool
        
        Save the animated gif.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxGIFHandler


class wxIFFHandler : wxImageHandler
{
    %Docstring
        IFFHandler()
        
        This is the image handler for the IFF format.
    %End
    %TypeHeaderCode
        #include <wx/imagiff.h>
    %End

public:
    wxIFFHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxIFFHandler


class wxJPEGHandler : wxImageHandler
{
    %Docstring
        JPEGHandler()
        
        This is the image handler for the JPEG format.
    %End
    %TypeHeaderCode
        #include <wx/imagjpeg.h>
    %End

public:
    wxJPEGHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End

    static
    wxVersionInfo GetLibraryVersionInfo();
    %Docstring
        GetLibraryVersionInfo() -> VersionInfo
        
        Retrieve the version information about the JPEG library used by this
        handler.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxJPEGHandler


class wxPCXHandler : wxImageHandler
{
    %Docstring
        PCXHandler()
        
        This is the image handler for the PCX format.
    %End
    %TypeHeaderCode
        #include <wx/imagpcx.h>
    %End

public:
    wxPCXHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxPCXHandler


class wxPNGHandler : wxImageHandler
{
    %Docstring
        PNGHandler()
        
        This is the image handler for the PNG format.
    %End
    %TypeHeaderCode
        #include <wx/imagpng.h>
    %End

public:
    wxPNGHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxPNGHandler


class wxPNMHandler : wxImageHandler
{
    %Docstring
        PNMHandler()
        
        This is the image handler for the PNM format.
    %End
    %TypeHeaderCode
        #include <wx/imagpnm.h>
    %End

public:
    wxPNMHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxPNMHandler


class wxTGAHandler : wxImageHandler
{
    %Docstring
        TGAHandler()
        
        This is the image handler for the TGA format.
    %End
    %TypeHeaderCode
        #include <wx/imagtga.h>
    %End

public:
    wxTGAHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxTGAHandler


class wxXPMHandler : wxImageHandler
{
    %Docstring
        XPMHandler()
        
        This is the image handler for the XPM format.
    %End
    %TypeHeaderCode
        #include <wx/imagxpm.h>
    %End

public:
    wxXPMHandler();

    virtual
    bool LoadFile(
        wxImage * image,
        wxInputStream & stream,
        bool verbose = true,
        int index = -1
    );
    %Docstring
        LoadFile(image, stream, verbose=True, index=-1) -> bool
        
        Loads an image from a stream, putting the resulting data into image.
    %End

    virtual
    bool SaveFile(
        wxImage * image,
        wxOutputStream & stream,
        bool verbose = true
    );
    %Docstring
        SaveFile(image, stream, verbose=True) -> bool
        
        Saves an image in the output stream.
    %End


protected:
    virtual
    bool DoCanRead(
        wxInputStream & stream
    );
    %Docstring
        DoCanRead(stream) -> bool
        
        Called to test if this handler can read an image from the given
        stream.
    %End

};  // end of class wxXPMHandler


void wxInitAllImageHandlers();
%Docstring
    InitAllImageHandlers()
    
    Initializes all available image handlers.
%End

wxImage wxNullImage;

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`Image` instead.")
def EmptyImage(width=0, height=0, clear=True):
    """
    A compatibility wrapper for the wx.Image(width, height) constructor
    """
    return Image(width, height, clear)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use bitmap.ConvertToImage instead.")
def ImageFromBitmap(bitmap):
    """
    Create a :class:`Image` from a :class:`wx.Bitmap`
    """
    return bitmap.ConvertToImage()

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`Image` instead.")
def ImageFromStream(stream, type=BITMAP_TYPE_ANY, index=-1):
    """
    Load an image from a stream (file-like object)
    """
    return wx.Image(stream, type, index)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`Image` instead.")
def ImageFromData(width, height, data):
    """
    Compatibility wrapper for creating an image from RGB data
    """
    return Image(width, height, data)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`Image` instead.")
def ImageFromDataWithAlpha(width, height, data, alpha):
    """
    Compatibility wrapper for creating an image from RGB and Alpha data
    """
    return Image(width, height, data, alpha)

%End

%Extract(id=pycode_core)
def ImageFromBuffer(width, height, dataBuffer, alphaBuffer=None):
    """
    Creates a :class:`Image` from the data in `dataBuffer`.  The `dataBuffer`
    parameter must be a Python object that implements the buffer interface,
    such as a string, array, etc.  The `dataBuffer` object is expected to
    contain a series of RGB bytes and be width*height*3 bytes long.  A buffer
    object can optionally be supplied for the image's alpha channel data, and
    it is expected to be width*height bytes long.
    
    The :class:`Image` will be created with its data and alpha pointers initialized
    to the memory address pointed to by the buffer objects, thus saving the
    time needed to copy the image data from the buffer object to the :class:`Image`.
    While this has advantages, it also has the shoot-yourself-in-the-foot
    risks associated with sharing a C pointer between two objects.
    
    To help alleviate the risk a reference to the data and alpha buffer
    objects are kept with the :class:`Image`, so that they won't get deleted until
    after the wx.Image is deleted.  However please be aware that it is not
    guaranteed that an object won't move its memory buffer to a new location
    when it needs to resize its contents.  If that happens then the :class:`Image`
    will end up referring to an invalid memory location and could cause the
    application to crash.  Therefore care should be taken to not manipulate
    the objects used for the data and alpha buffers in a way that would cause
    them to change size.
    """
    img = Image(width, height)
    img.SetDataBuffer(dataBuffer)
    if alphaBuffer:
        img.SetAlphaBuffer(alphaBuffer)
    img._buffer = dataBuffer
    img._alpha = alphaBuffer
    return img

%End

class wxImageArray
{
public:
    SIP_SSIZE_T __len__();
    %MethodCode
        sipRes = sipCpp->GetCount();
    %End

            wxImage& __getitem__(long index);
        %MethodCode
            if (0 > index)
                index += sipCpp->GetCount();

            if ((index < sipCpp->GetCount()) && (0 <= index)) {
                sipRes = &sipCpp->Item(index);
            }
            else {
                wxPyErr_SetString(PyExc_IndexError, "sequence index out of range");
                sipError = sipErrorFail;
            }
        %End
        

    int __contains__(wxImage& obj);
    %MethodCode
        int idx = sipCpp->Index(*obj, false);
        sipRes = idx != wxNOT_FOUND;
    %End

    void append(wxImage& obj);
    %MethodCode
        sipCpp->Add(*obj);
    %End

    // TODO:  add support for index(value, [start, [stop]])
    int index(wxImage& obj);
    %MethodCode
        int idx = sipCpp->Index(*obj, false);
        if (idx == wxNOT_FOUND) {
            sipError = sipErrorFail;
            wxPyErr_SetString(PyExc_ValueError,
                              "sequence.index(x): x not in sequence");
            }
        sipRes = idx;
    %End
};

%Extract(id=pycode_core)
def _ImageArray___repr__(self):
    return "ImageArray: " + repr(list(self))
ImageArray.__repr__ = _ImageArray___repr__
del _ImageArray___repr__
%End


%Extract(id=pycode_core)
IMAGE_OPTION_QUALITY = "quality"
IMAGE_OPTION_FILENAME = "FileName"
IMAGE_OPTION_RESOLUTION = "Resolution"
IMAGE_OPTION_RESOLUTIONX = "ResolutionX"
IMAGE_OPTION_RESOLUTIONY = "ResolutionY"
IMAGE_OPTION_RESOLUTIONUNIT = "ResolutionUnit"
IMAGE_OPTION_MAX_WIDTH = "MaxWidth"
IMAGE_OPTION_MAX_HEIGHT = "MaxHeight"
IMAGE_OPTION_ORIGINAL_WIDTH = "OriginalWidth"
IMAGE_OPTION_ORIGINAL_HEIGHT = "OriginalHeight"
IMAGE_OPTION_BMP_FORMAT = "wxBMP_FORMAT"
IMAGE_OPTION_CUR_HOTSPOT_X = "HotSpotX"
IMAGE_OPTION_CUR_HOTSPOT_Y = "HotSpotY"
IMAGE_OPTION_GIF_COMMENT = "GifComment"
IMAGE_OPTION_GIF_TRANSPARENCY = "Transparency"
IMAGE_OPTION_GIF_TRANSPARENCY_HIGHLIGHT = "Highlight"
IMAGE_OPTION_GIF_TRANSPARENCY_UNCHANGED = "Unchanged"
IMAGE_OPTION_PNG_FORMAT = "PngFormat"
IMAGE_OPTION_PNG_BITDEPTH = "PngBitDepth"
IMAGE_OPTION_PNG_FILTER = "PngF"
IMAGE_OPTION_PNG_COMPRESSION_LEVEL = "PngZL"
IMAGE_OPTION_PNG_COMPRESSION_MEM_LEVEL = "PngZM"
IMAGE_OPTION_PNG_COMPRESSION_STRATEGY = "PngZS"
IMAGE_OPTION_PNG_COMPRESSION_BUFFER_SIZE = "PngZB"
IMAGE_OPTION_TIFF_BITSPERSAMPLE = "BitsPerSample"
IMAGE_OPTION_TIFF_SAMPLESPERPIXEL = "SamplesPerPixel"
IMAGE_OPTION_TIFF_COMPRESSION = "Compression"
IMAGE_OPTION_TIFF_PHOTOMETRIC = "Photometric"
IMAGE_OPTION_TIFF_IMAGEDESCRIPTOR = "ImageDescriptor"
IMAGE_OPTION_TIFF_BITSPERSAMPLE = "BitsPerSample"
IMAGE_OPTION_TIFF_SAMPLESPERPIXEL = "SamplesPerPixel"
IMAGE_OPTION_TIFF_COMPRESSION = "Compression"
IMAGE_OPTION_TIFF_PHOTOMETRIC = "Photometric"
IMAGE_OPTION_TIFF_IMAGEDESCRIPTOR = "ImageDescriptor"
IMAGE_OPTION_GIF_COMMENT = "GifComment"
IMAGE_OPTION_PNG_FORMAT = "PngFormat"
IMAGE_OPTION_PNG_BITDEPTH = "PngBitDepth"
IMAGE_OPTION_PNG_FILTER = "PngF"
IMAGE_OPTION_PNG_COMPRESSION_LEVEL = "PngZL"
IMAGE_OPTION_PNG_COMPRESSION_MEM_LEVEL = "PngZM"
IMAGE_OPTION_PNG_COMPRESSION_STRATEGY = "PngZS"
IMAGE_OPTION_PNG_COMPRESSION_BUFFER_SIZE = "PngZB"

%End


//---------------------------------------------------------------------------

