//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

enum wxRasterOperationMode
{
    wxCLEAR,
    wxXOR,
    wxINVERT,
    wxOR_REVERSE,
    wxAND_REVERSE,
    wxCOPY,
    wxAND,
    wxAND_INVERT,
    wxNO_OP,
    wxNOR,
    wxEQUIV,
    wxSRC_INVERT,
    wxOR_INVERT,
    wxNAND,
    wxOR,
    wxSET
};

enum wxFloodFillStyle
{
    wxFLOOD_SURFACE,
    wxFLOOD_BORDER
};

enum wxMappingMode
{
    wxMM_TEXT,
    wxMM_METRIC,
    wxMM_LOMETRIC,
    wxMM_TWIPS,
    wxMM_POINTS
};

struct wxFontMetrics
{
    %Docstring
        FontMetrics()
        
        Simple collection of various font metrics.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

    wxFontMetrics();

    int height;

    int ascent;

    int descent;

    int internalLeading;

    int externalLeading;

    int averageWidth;

};  // end of class wxFontMetrics


class wxDC : wxObject
{
    %Docstring
        A wxDC is a "device context" onto which graphics and text can be
        drawn.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

    %TypeCode
        //--------------------------------------------------------------------------
        // Name:        src/dc_ex.h
        // Purpose:     Functions that can quickly draw lists of items on a DC
        //
        // Author:      Robin Dunn
        //
        // Created:     18-Aug-2012
        // Copyright:   (c) 2012-2020 by Total Control Software
        // Licence:     wxWindows license
        //--------------------------------------------------------------------------
        
        
        typedef bool (*wxPyDrawListOp_t)(wxDC& dc, PyObject* coords);
        
        PyObject* wxPyDrawXXXList(wxDC& dc, wxPyDrawListOp_t doDraw,
                                  PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes);
        
        bool wxPyDrawXXXPoint(wxDC& dc, PyObject* coords);
        bool wxPyDrawXXXLine(wxDC& dc, PyObject* coords);
        bool wxPyDrawXXXRectangle(wxDC& dc, PyObject* coords);
        bool wxPyDrawXXXEllipse(wxDC& dc, PyObject* coords);
        bool wxPyDrawXXXPolygon(wxDC& dc, PyObject* coords);
        
        PyObject* wxPyDrawTextList(wxDC& dc, PyObject* textList, PyObject* pyPoints,
                                   PyObject* foregroundList, PyObject* backgroundList);
        
        //--------------------------------------------------------------------------
        
        
        PyObject* wxPyDrawXXXList(wxDC& dc, wxPyDrawListOp_t doDraw,
                                  PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
        {
            wxPyBlock_t blocked = wxPyBeginBlockThreads();
        
            bool      isFastSeq  = PyList_Check(pyCoords) || PyTuple_Check(pyCoords);
            bool      isFastPens = PyList_Check(pyPens) || PyTuple_Check(pyPens);
            bool      isFastBrushes = PyList_Check(pyBrushes) || PyTuple_Check(pyBrushes);
            int       numObjs = 0;
            int       numPens = 0;
            int       numBrushes = 0;
            wxPen*    pen;
            wxBrush*  brush;
            PyObject* obj;
            PyObject* coords;
            int       i = 0;
            PyObject* retval;
        
            if (!PySequence_Check(pyCoords)) {
                goto err0;
            }
            if (!PySequence_Check(pyPens)) {
                goto err1;
            }
            if (!PySequence_Check(pyBrushes)) {
                goto err2;
            }
            numObjs = PySequence_Length(pyCoords);
            numPens = PySequence_Length(pyPens);
            numBrushes = PySequence_Length(pyBrushes);
            for (i = 0; i < numObjs; i++) {
                // Use a new pen?
                if (i < numPens) {
                    if (isFastPens) {
                        obj = PySequence_Fast_GET_ITEM(pyPens, i);
                    }
                    else {
                        obj = PySequence_GetItem(pyPens, i);
                    }
                    if (! wxPyConvertWrappedPtr(obj, (void **) &pen, "wxPen")) {
                        if (!isFastPens)
                            Py_DECREF(obj);
                        goto err1;
                    }
        
                    dc.SetPen(*pen);
                    if (!isFastPens)
                        Py_DECREF(obj);
                }
                // Use a new brush?
                if (i < numBrushes) {
                    if (isFastBrushes) {
                        obj = PySequence_Fast_GET_ITEM(pyBrushes, i);
                    }
                    else {
                        obj = PySequence_GetItem(pyBrushes, i);
                    }
                    if (!wxPyConvertWrappedPtr(obj, (void **) &brush, "wxBrush")) {
                        if (!isFastBrushes)
                            Py_DECREF(obj);
                        goto err2;
                    }
        
                    dc.SetBrush(*brush);
                    if (!isFastBrushes)
                        Py_DECREF(obj);
                }
        
                // Get the Coordinates
                if (isFastSeq) {
                    coords = PySequence_Fast_GET_ITEM(pyCoords, i);
                }
                else {
                    coords = PySequence_GetItem(pyCoords, i);
                }
        
        
                // call the drawOp
                bool success = doDraw(dc, coords);
                if (!isFastSeq)
                    Py_DECREF(coords);
        
                if (! success) {
                    retval = NULL;
                    goto exit;
                }
        
            } // end of main for loop
        
            Py_INCREF(Py_None);
            retval = Py_None;
            goto exit;
        
        
         err0:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of coordinates");
            retval = NULL;
            goto exit;
        
         err1:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of wxPens");
            retval = NULL;
            goto exit;
        
         err2:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of wxBrushes");
            retval = NULL;
            goto exit;
        
        
         exit:
            wxPyEndBlockThreads(blocked);
            return retval;
        }
        
        
        
        bool wxPyDrawXXXPoint(wxDC& dc, PyObject* coords)
        {
            int x, y;
        
            if (! wxPy2int_seq_helper(coords, &x, &y)) {
                PyErr_SetString(PyExc_TypeError, "Expected a sequence of (x,y) sequences.");
                return false;
            }
            dc.DrawPoint(x, y);
            return true;
        }
        
        bool wxPyDrawXXXLine(wxDC& dc, PyObject* coords)
        {
            int x1, y1, x2, y2;
        
            if (! wxPy4int_seq_helper(coords, &x1, &y1, &x2, &y2)) {
                PyErr_SetString(PyExc_TypeError, "Expected a sequence of (x1,y1, x1,y2) sequences.");
                return false;
            }
            dc.DrawLine(x1,y1, x2,y2);
            return true;
        }
        
        bool wxPyDrawXXXRectangle(wxDC& dc, PyObject* coords)
        {
            int x, y, w, h;
        
            if (! wxPy4int_seq_helper(coords, &x, &y, &w, &h)) {
                PyErr_SetString(PyExc_TypeError, "Expected a sequence of (x,y, w,h) sequences.");
                return false;
            }
            dc.DrawRectangle(x, y, w, h);
            return true;
        }
        
        bool wxPyDrawXXXEllipse(wxDC& dc, PyObject* coords)
        {
            int x, y, w, h;
        
            if (! wxPy4int_seq_helper(coords, &x, &y, &w, &h)) {
                PyErr_SetString(PyExc_TypeError, "Expected a sequence of (x,y, w,h) sequences.");
                return false;
            }
            dc.DrawEllipse(x, y, w, h);
            return true;
        }
        
        
        wxPoint* wxPoint_LIST_helper(PyObject* source, int *count);
        
        bool wxPyDrawXXXPolygon(wxDC& dc, PyObject* coords)
        {
            wxPoint* points;
            int numPoints;
        
            points = wxPoint_LIST_helper(coords, &numPoints);
            if (! points) {
                PyErr_SetString(PyExc_TypeError, "Expected a sequence of sequences of (x,y) sequences.");
                return false;
            }
            dc.DrawPolygon(numPoints, points);
            delete [] points;
            return true;
        }
        
        
        //---------------------------------------------------------------------------
        
        
        
        PyObject* wxPyDrawTextList(wxDC& dc, PyObject* textList, PyObject* pyPoints, PyObject* foregroundList, PyObject* backgroundList)
        {
            wxPyBlock_t blocked = wxPyBeginBlockThreads();
        
            bool      isFastSeq  = PyList_Check(pyPoints) || PyTuple_Check(pyPoints);
            bool      isFastText = PyList_Check(textList) || PyTuple_Check(textList);
            bool      isFastForeground = PyList_Check(foregroundList) || PyTuple_Check(foregroundList);
            bool      isFastBackground = PyList_Check(backgroundList) || PyTuple_Check(backgroundList);
            int       numText = 0;
            int       numPoints = 0;
            int       numForeground = 0;
            int       numBackground = 0;
            PyObject* obj;
            int       x1, y1;
            int       i = 0;
            wxColor*    color;
            PyObject* retval;
            wxString  string;
        
            if (!PySequence_Check(pyPoints)) {
                goto err0;
            }
            if (!PySequence_Check(textList)) {
                goto err1;
            }
            if (!PySequence_Check(foregroundList)) {
                goto err2;
            }
            if (!PySequence_Check(backgroundList)) {
                goto err3;
            }
            numPoints = PySequence_Length(pyPoints);
            numText = PySequence_Length(textList);
            numForeground = PySequence_Length(foregroundList);
            numBackground = PySequence_Length(backgroundList);
        
            for (i = 0; i < numPoints; i++) {
                // Use a new string ?
                if (i < numText) {
                    if ( isFastText ) {
                        obj = PySequence_Fast_GET_ITEM(textList, i);
                    }
                    else {
                        obj = PySequence_GetItem(textList, i);
                    }
                    if (! PyBytes_Check(obj) && !PyUnicode_Check(obj) ) {
                        Py_DECREF(obj);
                        goto err1;
                    }
                    string = Py2wxString(obj);
                    if ( !isFastText )
                        Py_DECREF(obj);
                }
        
                if (i < numForeground) {
                    // Use a new foreground ?
                    if ( isFastForeground ) {
                        obj = PySequence_Fast_GET_ITEM(foregroundList, i);
                    }
                    else {
                        obj = PySequence_GetItem(foregroundList, i);
                    }
                    if (! wxPyConvertWrappedPtr(obj, (void **) &color, "wxColour")) {
                        if (!isFastForeground)
                            Py_DECREF(obj);
                        goto err2;
                    }
                    dc.SetTextForeground(*color);
                    if ( !isFastForeground )
                        Py_DECREF(obj);
                }
        
                if (i < numBackground) {
                    // Use a new background ?
                    if ( isFastBackground ) {
                        obj = PySequence_Fast_GET_ITEM(backgroundList, i);
                    }
                    else {
                        obj = PySequence_GetItem(backgroundList, i);
                    }
                    if (! wxPyConvertWrappedPtr(obj, (void **) &color, "wxColour")) {
                        if (!isFastBackground)
                            Py_DECREF(obj);
                        goto err3;
                    }
                    dc.SetTextBackground(*color);
                    if ( !isFastBackground )
                        Py_DECREF(obj);
                }
        
                // Get the point coordinates
                if (isFastSeq) {
                    obj = PySequence_Fast_GET_ITEM(pyPoints, i);
                }
                else {
                    obj = PySequence_GetItem(pyPoints, i);
                }
                if (! wxPy2int_seq_helper(obj, &x1, &y1)) {
                    if (! isFastSeq)
                        Py_DECREF(obj);
                    goto err0;
                }
                if (!isFastText)
                    Py_DECREF(obj);
        
                if (PyErr_Occurred()) {
                    retval = NULL;
                    goto exit;
                }
        
                // Now draw the text
                dc.DrawText(string, x1, y1);
            }
        
            Py_INCREF(Py_None);
            retval = Py_None;
            goto exit;
        
         err0:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of (x,y) sequences.");
            retval = NULL;
            goto exit;
         err1:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of strings");
            retval = NULL;
            goto exit;
        
         err2:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of wxColours for foregrounds");
            retval = NULL;
            goto exit;
        
         err3:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of wxColours for backgrounds");
            retval = NULL;
            goto exit;
        
         exit:
            wxPyEndBlockThreads(blocked);
            return retval;
        }
        
        //---------------------------------------------------------------------------
        
        
        bool wxPointFromObjects(PyObject* o1, PyObject* o2, wxPoint* point)
        {
            // get the x value
            if (wxPyInt_Check(o1))
                point->x = (int)wxPyInt_AS_LONG(o1);
            else if (PyFloat_Check(o1))
                point->x = (int)PyFloat_AS_DOUBLE(o1);
            else if (PyNumber_Check(o1))
                point->x = (int)wxPyInt_AsLong(o1);
            else
                return false;
        
            // get the y value
            if (wxPyInt_Check(o2))
                point->y = (int)wxPyInt_AS_LONG(o2);
            else if (PyFloat_Check(o2))
                point->y = (int)PyFloat_AS_DOUBLE(o2);
            else if (PyNumber_Check(o2))
                point->y = (int)wxPyInt_AsLong(o2);
            else
                return false;
        
            return true;
        }
        
        
        wxPoint* wxPoint_LIST_helper(PyObject* source, int *count)
        {
            int idx;
            wxPoint* temp;
            PyObject *o, *o1, *o2;
            bool isFast = PyList_Check(source) || PyTuple_Check(source);
        
            if (!PySequence_Check(source)) {
                goto error0;
            }
        
            // The length of the sequence is returned in count.
            *count = PySequence_Length(source);
            if (*count < 0) {
                goto error0;
            }
        
            temp = new wxPoint[*count];
            if (!temp) {
                PyErr_SetString(PyExc_MemoryError, "Unable to allocate temporary array");
                return NULL;
            }
            for (idx=0; idx<*count; idx++) {
                // Get an item: try fast way first.
                if (isFast) {
                    o = PySequence_Fast_GET_ITEM(source, idx);
                }
                else {
                    o = PySequence_GetItem(source, idx);
                    if (o == NULL) {
                        goto error1;
                    }
                }
        
                // Convert o to wxPoint.
                if ((PyTuple_Check(o) && PyTuple_GET_SIZE(o) == 2) ||
                    (PyList_Check(o) && PyList_GET_SIZE(o) == 2)) {
                    o1 = PySequence_Fast_GET_ITEM(o, 0);
                    o2 = PySequence_Fast_GET_ITEM(o, 1);
                    if (!wxPointFromObjects(o1, o2, &temp[idx])) {
                        goto error2;
                    }
                }
                else if (wxPyWrappedPtr_Check(o)) {
                    wxPoint* pt;
                    if (! wxPyConvertWrappedPtr(o, (void **)&pt, "wxPoint")) {
                        goto error2;
                    }
                    temp[idx] = *pt;
                }
                else if (PySequence_Check(o) && PySequence_Length(o) == 2) {
                    o1 = PySequence_GetItem(o, 0);
                    o2 = PySequence_GetItem(o, 1);
                    if (!wxPointFromObjects(o1, o2, &temp[idx])) {
                        goto error3;
                    }
                    Py_DECREF(o1);
                    Py_DECREF(o2);
                }
                else {
                    goto error2;
                }
                // Clean up.
                if (!isFast)
                    Py_DECREF(o);
            }
            return temp;
        
        error3:
            Py_DECREF(o1);
            Py_DECREF(o2);
        error2:
            if (!isFast)
                Py_DECREF(o);
        error1:
            delete [] temp;
        error0:
            PyErr_SetString(PyExc_TypeError, "Expected a sequence of length-2 sequences or wx.Points.");
            return NULL;
        }
    %End
public:
    wxCoord DeviceToLogicalX(
        wxCoord x
    ) const;
    %Docstring
        DeviceToLogicalX(x) -> Coord
        
        Convert device X coordinate to logical coordinate, using the current
        mapping mode, user scale factor, device origin and axis orientation.
    %End

    wxCoord DeviceToLogicalXRel(
        wxCoord x
    ) const;
    %Docstring
        DeviceToLogicalXRel(x) -> Coord
        
        Convert device X coordinate to relative logical coordinate, using the
        current mapping mode and user scale factor but ignoring the axis
        orientation.
    %End

    wxCoord DeviceToLogicalY(
        wxCoord y
    ) const;
    %Docstring
        DeviceToLogicalY(y) -> Coord
        
        Converts device Y coordinate to logical coordinate, using the current
        mapping mode, user scale factor, device origin and axis orientation.
    %End

    wxCoord DeviceToLogicalYRel(
        wxCoord y
    ) const;
    %Docstring
        DeviceToLogicalYRel(y) -> Coord
        
        Convert device Y coordinate to relative logical coordinate, using the
        current mapping mode and user scale factor but ignoring the axis
        orientation.
    %End

    wxCoord LogicalToDeviceX(
        wxCoord x
    ) const;
    %Docstring
        LogicalToDeviceX(x) -> Coord
        
        Converts logical X coordinate to device coordinate, using the current
        mapping mode, user scale factor, device origin and axis orientation.
    %End

    wxCoord LogicalToDeviceXRel(
        wxCoord x
    ) const;
    %Docstring
        LogicalToDeviceXRel(x) -> Coord
        
        Converts logical X coordinate to relative device coordinate, using the
        current mapping mode and user scale factor but ignoring the axis
        orientation.
    %End

    wxCoord LogicalToDeviceY(
        wxCoord y
    ) const;
    %Docstring
        LogicalToDeviceY(y) -> Coord
        
        Converts logical Y coordinate to device coordinate, using the current
        mapping mode, user scale factor, device origin and axis orientation.
    %End

    wxCoord LogicalToDeviceYRel(
        wxCoord y
    ) const;
    %Docstring
        LogicalToDeviceYRel(y) -> Coord
        
        Converts logical Y coordinate to relative device coordinate, using the
        current mapping mode and user scale factor but ignoring the axis
        orientation.
    %End

    wxPoint DeviceToLogical(
        wxCoord x,
        wxCoord y
    ) const;
    %Docstring
        DeviceToLogical(x, y) -> Point
        DeviceToLogical(pt) -> Point
        
        Converts device (x, y) coordinates to logical coordinates taking into
        account all applied transformations like the current mapping mode,
        scale factors, device origin, axes orientation, affine transformation.
    %End

    wxPoint DeviceToLogical(
        const wxPoint & pt
    ) const;

    wxSize DeviceToLogicalRel(
        int x,
        int y
    ) const;
    %Docstring
        DeviceToLogicalRel(x, y) -> Size
        DeviceToLogicalRel(dim) -> Size
        
        Converts device x, y coordinates to relative logical coordinates
        taking into account all applied transformations like the current
        mapping mode, scale factors, affine transformation.
    %End

    wxSize DeviceToLogicalRel(
        const wxSize & dim
    ) const;

    wxPoint LogicalToDevice(
        wxCoord x,
        wxCoord y
    ) const;
    %Docstring
        LogicalToDevice(x, y) -> Point
        LogicalToDevice(pt) -> Point
        
        Converts logical (x, y) coordinates to device coordinates taking into
        account all applied transformations like the current mapping mode,
        scale factors, device origin, axes orientation, affine transformation.
    %End

    wxPoint LogicalToDevice(
        const wxPoint & pt
    ) const;

    wxSize LogicalToDeviceRel(
        int x,
        int y
    ) const;
    %Docstring
        LogicalToDeviceRel(x, y) -> Size
        LogicalToDeviceRel(dim) -> Size
        
        Converts logical x, y coordinates to relative device coordinates
        taking into account all applied transformations like the current
        mapping mode, scale factors, affine transformation.
    %End

    wxSize LogicalToDeviceRel(
        const wxSize & dim
    ) const;

    void Clear();
    %Docstring
        Clear()
        
        Clears the device context using the current background brush.
    %End

    void DrawArc(
        wxCoord xStart,
        wxCoord yStart,
        wxCoord xEnd,
        wxCoord yEnd,
        wxCoord xc,
        wxCoord yc
    );
    %Docstring
        DrawArc(xStart, yStart, xEnd, yEnd, xc, yc)
        DrawArc(ptStart, ptEnd, centre)
        
        Draws an arc from the given start to the given end point.
    %End

    void DrawArc(
        const wxPoint & ptStart,
        const wxPoint & ptEnd,
        const wxPoint & centre
    );

    void DrawBitmap(
        const wxBitmap & bitmap,
        wxCoord x,
        wxCoord y,
        bool useMask = false
    );
    %Docstring
        DrawBitmap(bitmap, x, y, useMask=False)
        DrawBitmap(bmp, pt, useMask=False)
        
        Draw a bitmap on the device context at the specified point.
    %End

    void DrawBitmap(
        const wxBitmap & bmp,
        const wxPoint & pt,
        bool useMask = false
    );

    void DrawCheckMark(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawCheckMark(x, y, width, height)
        DrawCheckMark(rect)
        
        Draws a check mark inside the given rectangle.
    %End

    void DrawCheckMark(
        const wxRect & rect
    );

    void DrawCircle(
        wxCoord x,
        wxCoord y,
        wxCoord radius
    );
    %Docstring
        DrawCircle(x, y, radius)
        DrawCircle(pt, radius)
        
        Draws a circle with the given centre and radius.
    %End

    void DrawCircle(
        const wxPoint & pt,
        wxCoord radius
    );

    void DrawEllipse(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawEllipse(x, y, width, height)
        DrawEllipse(pt, size)
        DrawEllipse(rect)
        
        Draws an ellipse contained in the rectangle specified either with the
        given top left corner and the given size or directly.
    %End

    void DrawEllipse(
        const wxPoint & pt,
        const wxSize & size
    );

    void DrawEllipse(
        const wxRect & rect
    );

    void DrawEllipticArc(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height,
        double start,
        double end
    );
    %Docstring
        DrawEllipticArc(x, y, width, height, start, end)
        DrawEllipticArc(pt, sz, sa, ea)
        
        Draws an arc of an ellipse.
    %End

    void DrawEllipticArc(
        const wxPoint & pt,
        const wxSize & sz,
        double sa,
        double ea
    );

    void DrawIcon(
        const wxIcon & icon,
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawIcon(icon, x, y)
        DrawIcon(icon, pt)
        
        Draw an icon on the display (does nothing if the device context is
        PostScript).
    %End

    void DrawIcon(
        const wxIcon & icon,
        const wxPoint & pt
    );

    wxRect* DrawLabel(
        const wxString & text,
        const wxBitmap & bitmap,
        const wxRect & rect,
        int alignment = wxALIGN_LEFT|wxALIGN_TOP,
        int indexAccel = -1
    )   /Factory/;
    %Docstring
        DrawLabel(text, bitmap, rect, alignment=ALIGN_LEFT|ALIGN_TOP, indexAccel=-1) -> Rect
        DrawLabel(text, rect, alignment=ALIGN_LEFT|ALIGN_TOP, indexAccel=-1)
        
        Draw optional bitmap and the text into the given rectangle and aligns
        it as specified by alignment parameter; it also will emphasize the
        character with the given index if it is != -1 and return the bounding
        rectangle if required.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_DrawLabel(sipCpp, text, bitmap, rect, alignment, indexAccel);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxRect* _wxDC_DrawLabel(wxDC* self, const wxString *text, const wxBitmap *bitmap, const wxRect *rect, int alignment, int indexAccel)
    {
        wxRect rv;
        self->DrawLabel(*text, *bitmap, *rect, alignment, indexAccel, &rv);
        return new wxRect(rv);
    }
    %End

    void DrawLabel(
        const wxString & text,
        const wxRect & rect,
        int alignment = wxALIGN_LEFT|wxALIGN_TOP,
        int indexAccel = -1
    );
    %Docstring
        DrawLabel(text, rect, alignment=ALIGN_LEFT|ALIGN_TOP, indexAccel=-1)
        
        This is an overloaded member function, provided for convenience. It
        differs from the above function only in what argument(s) it accepts.
    %End

    void DrawLine(
        wxCoord x1,
        wxCoord y1,
        wxCoord x2,
        wxCoord y2
    );
    %Docstring
        DrawLine(x1, y1, x2, y2)
        DrawLine(pt1, pt2)
        
        Draws a line from the first point to the second.
    %End

    void DrawLine(
        const wxPoint & pt1,
        const wxPoint & pt2
    );

    void DrawLines(
        const wxPointList * points,
        wxCoord xoffset = 0,
        wxCoord yoffset = 0
    );
    %Docstring
        DrawLines(points, xoffset=0, yoffset=0)
        
        This method uses a list of wxPoints, adding the optional offset
        coordinate.
    %End

    void DrawPoint(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawPoint(x, y)
        DrawPoint(pt)
        
        Draws a point using the color of the current pen.
    %End

    void DrawPoint(
        const wxPoint & pt
    );

    void DrawPolygon(
        const wxPointList * points,
        wxCoord xoffset = 0,
        wxCoord yoffset = 0,
        wxPolygonFillMode fill_style = wxODDEVEN_RULE
    );
    %Docstring
        DrawPolygon(points, xoffset=0, yoffset=0, fill_style=ODDEVEN_RULE)
        
        This method draws a filled polygon using a list of wxPoints, adding
        the optional offset coordinate.
    %End

    void DrawRectangle(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        DrawRectangle(x, y, width, height)
        DrawRectangle(pt, sz)
        DrawRectangle(rect)
        
        Draws a rectangle with the given corner coordinate and size.
    %End

    void DrawRectangle(
        const wxPoint & pt,
        const wxSize & sz
    );

    void DrawRectangle(
        const wxRect & rect
    );

    void DrawRotatedText(
        const wxString & text,
        wxCoord x,
        wxCoord y,
        double angle
    );
    %Docstring
        DrawRotatedText(text, x, y, angle)
        DrawRotatedText(text, point, angle)
        
        Draws the text rotated by angle degrees (positive angles are
        counterclockwise; the full angle is 360 degrees).
    %End

    void DrawRotatedText(
        const wxString & text,
        const wxPoint & point,
        double angle
    );

    void DrawRoundedRectangle(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height,
        double radius
    );
    %Docstring
        DrawRoundedRectangle(x, y, width, height, radius)
        DrawRoundedRectangle(pt, sz, radius)
        DrawRoundedRectangle(rect, radius)
        
        Draws a rectangle with the given top left corner, and with the given
        size.
    %End

    void DrawRoundedRectangle(
        const wxPoint & pt,
        const wxSize & sz,
        double radius
    );

    void DrawRoundedRectangle(
        const wxRect & rect,
        double radius
    );

    void DrawSpline(
        const wxPointList * points
    );
    %Docstring
        DrawSpline(points)
        DrawSpline(x1, y1, x2, y2, x3, y3)
        
        This is an overloaded member function, provided for convenience. It
        differs from the above function only in what argument(s) it accepts.
    %End

    void DrawSpline(
        wxCoord x1,
        wxCoord y1,
        wxCoord x2,
        wxCoord y2,
        wxCoord x3,
        wxCoord y3
    );

    void DrawText(
        const wxString & text,
        wxCoord x,
        wxCoord y
    );
    %Docstring
        DrawText(text, x, y)
        DrawText(text, pt)
        
        Draws a text string at the specified point, using the current text
        font, and the current text foreground and background colours.
    %End

    void DrawText(
        const wxString & text,
        const wxPoint & pt
    );

    void GradientFillConcentric(
        const wxRect & rect,
        const wxColour & initialColour,
        const wxColour & destColour
    );
    %Docstring
        GradientFillConcentric(rect, initialColour, destColour)
        GradientFillConcentric(rect, initialColour, destColour, circleCenter)
        
        Fill the area specified by rect with a radial gradient, starting from
        initialColour at the centre of the circle and fading to destColour on
        the circle outside.
    %End

    void GradientFillConcentric(
        const wxRect & rect,
        const wxColour & initialColour,
        const wxColour & destColour,
        const wxPoint & circleCenter
    );

    void GradientFillLinear(
        const wxRect & rect,
        const wxColour & initialColour,
        const wxColour & destColour,
        wxDirection nDirection = wxRIGHT
    );
    %Docstring
        GradientFillLinear(rect, initialColour, destColour, nDirection=RIGHT)
        
        Fill the area specified by rect with a linear gradient, starting from
        initialColour and eventually fading to destColour.
    %End

    bool FloodFill(
        wxCoord x,
        wxCoord y,
        const wxColour & colour,
        wxFloodFillStyle style = wxFLOOD_SURFACE
    );
    %Docstring
        FloodFill(x, y, colour, style=FLOOD_SURFACE) -> bool
        FloodFill(pt, col, style=FLOOD_SURFACE) -> bool
        
        Flood fills the device context starting from the given point, using
        the current brush colour, and using a style:
    %End

    bool FloodFill(
        const wxPoint & pt,
        const wxColour & col,
        wxFloodFillStyle style = wxFLOOD_SURFACE
    );

    void CrossHair(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        CrossHair(x, y)
        CrossHair(pt)
        
        Displays a cross hair using the current pen.
    %End

    void CrossHair(
        const wxPoint & pt
    );

    void DestroyClippingRegion();
    %Docstring
        DestroyClippingRegion()
        
        Destroys the current clipping region so that none of the DC is
        clipped.
    %End

    bool GetClippingBox(
        wxCoord * x   /Out/,
        wxCoord * y   /Out/,
        wxCoord * width   /Out/,
        wxCoord * height   /Out/
    ) const;
    %Docstring
        GetClippingBox() -> (bool, x, y, width, height)
        
        Gets the rectangle surrounding the current clipping region.
    %End

    void SetClippingRegion(
        wxCoord x,
        wxCoord y,
        wxCoord width,
        wxCoord height
    );
    %Docstring
        SetClippingRegion(x, y, width, height)
        SetClippingRegion(pt, sz)
        SetClippingRegion(rect)
        
        Sets the clipping region for this device context to the intersection
        of the given region described by the parameters of this method and the
        previously set clipping region.
    %End

    void SetClippingRegion(
        const wxPoint & pt,
        const wxSize & sz
    );

    void SetClippingRegion(
        const wxRect & rect
    );

    void SetDeviceClippingRegion(
        const wxRegion & region
    );
    %Docstring
        SetDeviceClippingRegion(region)
        
        Sets the clipping region for this device context.
    %End

    wxCoord GetCharHeight() const;
    %Docstring
        GetCharHeight() -> Coord
        
        Gets the character height of the currently set font.
    %End

    wxCoord GetCharWidth() const;
    %Docstring
        GetCharWidth() -> Coord
        
        Gets the average character width of the currently set font.
    %End

    wxFontMetrics GetFontMetrics() const;
    %Docstring
        GetFontMetrics() -> FontMetrics
        
        Returns the various font characteristics.
    %End

    void GetMultiLineTextExtent(
        const wxString & string,
        wxCoord * w   /Out/,
        wxCoord * h   /Out/,
        wxCoord * heightLine   /Out/ = NULL,
        const wxFont * font = NULL
    ) const   /PyName=GetFullMultiLineTextExtent/;
    %Docstring
        GetFullMultiLineTextExtent(string, font=None) -> (w, h, heightLine)
        
        Gets the dimensions of the string as it would be drawn.
    %End

    wxArrayInt* GetPartialTextExtents(
        const wxString & text
    ) const   /Factory/;
    %Docstring
        GetPartialTextExtents(text) -> ArrayInt
        
        Fills the widths array with the widths from the beginning of text to
        the corresponding character of text.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetPartialTextExtents(sipCpp, text);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxArrayInt* _wxDC_GetPartialTextExtents(const wxDC* self, const wxString *text)
    {
        wxArrayInt rval;
        self->GetPartialTextExtents(*text, rval);
        return new wxArrayInt(rval);
    }
    %End

    void GetTextExtent(
        const wxString & string,
        wxCoord * w   /Out/,
        wxCoord * h   /Out/,
        wxCoord * descent   /Out/ = NULL,
        wxCoord * externalLeading   /Out/ = NULL,
        const wxFont * font = NULL
    ) const   /PyName=GetFullTextExtent/;
    %Docstring
        GetFullTextExtent(string, font=None) -> (w, h, descent, externalLeading)
        
        Gets the dimensions of the string as it would be drawn.
    %End

    int GetBackgroundMode() const;
    %Docstring
        GetBackgroundMode() -> int
        
        Returns the current background mode: wxBRUSHSTYLE_SOLID or
        wxBRUSHSTYLE_TRANSPARENT.
    %End

    const wxFont & GetFont() const;
    %Docstring
        GetFont() -> Font
        
        Gets the current font.
    %End

    wxLayoutDirection GetLayoutDirection() const;
    %Docstring
        GetLayoutDirection() -> LayoutDirection
        
        Gets the current layout direction of the device context.
    %End

    const wxColour & GetTextBackground() const;
    %Docstring
        GetTextBackground() -> Colour
        
        Gets the current text background colour.
    %End

    const wxColour & GetTextForeground() const;
    %Docstring
        GetTextForeground() -> Colour
        
        Gets the current text foreground colour.
    %End

    void SetBackgroundMode(
        int mode
    );
    %Docstring
        SetBackgroundMode(mode)
        
        Change the current background mode.
    %End

    void SetFont(
        const wxFont & font
    );
    %Docstring
        SetFont(font)
        
        Sets the current font for the DC.
    %End

    void SetTextBackground(
        const wxColour & colour
    );
    %Docstring
        SetTextBackground(colour)
        
        Sets the current text background colour for the DC.
    %End

    void SetTextForeground(
        const wxColour & colour
    );
    %Docstring
        SetTextForeground(colour)
        
        Sets the current text foreground colour for the DC.
    %End

    void SetLayoutDirection(
        wxLayoutDirection dir
    );
    %Docstring
        SetLayoutDirection(dir)
        
        Sets the current layout direction for the device context.
    %End

    void CalcBoundingBox(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        CalcBoundingBox(x, y)
        
        Adds the specified point to the bounding box which can be retrieved
        with MinX(), MaxX() and MinY(), MaxY() functions.
    %End

    wxCoord MaxX() const;
    %Docstring
        MaxX() -> Coord
        
        Gets the maximum horizontal extent used in drawing commands so far.
    %End

    wxCoord MaxY() const;
    %Docstring
        MaxY() -> Coord
        
        Gets the maximum vertical extent used in drawing commands so far.
    %End

    wxCoord MinX() const;
    %Docstring
        MinX() -> Coord
        
        Gets the minimum horizontal extent used in drawing commands so far.
    %End

    wxCoord MinY() const;
    %Docstring
        MinY() -> Coord
        
        Gets the minimum vertical extent used in drawing commands so far.
    %End

    void ResetBoundingBox();
    %Docstring
        ResetBoundingBox()
        
        Resets the bounding box: after a call to this function, the bounding
        box doesn't contain anything.
    %End

    bool StartDoc(
        const wxString & message
    );
    %Docstring
        StartDoc(message) -> bool
        
        Starts a document (only relevant when outputting to a printer).
    %End

    void StartPage();
    %Docstring
        StartPage()
        
        Starts a document page (only relevant when outputting to a printer).
    %End

    void EndDoc();
    %Docstring
        EndDoc()
        
        Ends a document (only relevant when outputting to a printer).
    %End

    void EndPage();
    %Docstring
        EndPage()
        
        Ends a document page (only relevant when outputting to a printer).
    %End

    bool Blit(
        wxCoord xdest,
        wxCoord ydest,
        wxCoord width,
        wxCoord height,
        wxDC * source,
        wxCoord xsrc,
        wxCoord ysrc,
        wxRasterOperationMode logicalFunc = wxCOPY,
        bool useMask = false,
        wxCoord xsrcMask = wxDefaultCoord,
        wxCoord ysrcMask = wxDefaultCoord
    );
    %Docstring
        Blit(xdest, ydest, width, height, source, xsrc, ysrc, logicalFunc=COPY, useMask=False, xsrcMask=DefaultCoord, ysrcMask=DefaultCoord) -> bool
        
        Copy from a source DC to this DC.
    %End

    bool StretchBlit(
        wxCoord xdest,
        wxCoord ydest,
        wxCoord dstWidth,
        wxCoord dstHeight,
        wxDC * source,
        wxCoord xsrc,
        wxCoord ysrc,
        wxCoord srcWidth,
        wxCoord srcHeight,
        wxRasterOperationMode logicalFunc = wxCOPY,
        bool useMask = false,
        wxCoord xsrcMask = wxDefaultCoord,
        wxCoord ysrcMask = wxDefaultCoord
    );
    %Docstring
        StretchBlit(xdest, ydest, dstWidth, dstHeight, source, xsrc, ysrc, srcWidth, srcHeight, logicalFunc=COPY, useMask=False, xsrcMask=DefaultCoord, ysrcMask=DefaultCoord) -> bool
        
        Copy from a source DC to this DC possibly changing the scale.
    %End

    const wxBrush & GetBackground() const;
    %Docstring
        GetBackground() -> Brush
        
        Gets the brush used for painting the background.
    %End

    const wxBrush & GetBrush() const;
    %Docstring
        GetBrush() -> Brush
        
        Gets the current brush.
    %End

    const wxPen & GetPen() const;
    %Docstring
        GetPen() -> Pen
        
        Gets the current pen.
    %End

    void SetBackground(
        const wxBrush & brush
    );
    %Docstring
        SetBackground(brush)
        
        Sets the current background brush for the DC.
    %End

    void SetBrush(
        const wxBrush & brush
    );
    %Docstring
        SetBrush(brush)
        
        Sets the current brush for the DC.
    %End

    void SetPen(
        const wxPen & pen
    );
    %Docstring
        SetPen(pen)
        
        Sets the current pen for the DC.
    %End

    bool CanUseTransformMatrix() const;
    %Docstring
        CanUseTransformMatrix() -> bool
        
        Check if the use of transformation matrix is supported by the current
        system.
    %End

    bool SetTransformMatrix(
        const wxAffineMatrix2D & matrix
    );
    %Docstring
        SetTransformMatrix(matrix) -> bool
        
        Set the transformation matrix.
    %End

    wxAffineMatrix2D GetTransformMatrix() const;
    %Docstring
        GetTransformMatrix() -> AffineMatrix2D
        
        Return the transformation matrix used by this device context.
    %End

    void ResetTransformMatrix();
    %Docstring
        ResetTransformMatrix()
        
        Revert the transformation matrix to identity matrix.
    %End

    bool CanDrawBitmap() const;
    %Docstring
        CanDrawBitmap() -> bool
        
        Does the DC support drawing bitmaps?
    %End

    bool CanGetTextExtent() const;
    %Docstring
        CanGetTextExtent() -> bool
        
        Does the DC support calculating the size required to draw text?
    %End

    void GetLogicalOrigin(
        wxCoord * x   /Out/,
        wxCoord * y   /Out/
    ) const;
    %Docstring
        GetLogicalOrigin() -> (x, y)
        
        Return the coordinates of the logical point (0, 0).
    %End

    void CopyAttributes(
        const wxDC & dc
    );
    %Docstring
        CopyAttributes(dc)
        
        Copy attributes from another DC.
    %End

    int GetDepth() const;
    %Docstring
        GetDepth() -> int
        
        Returns the depth (number of bits/pixel) of this DC.
    %End

    wxPoint GetDeviceOrigin() const;
    %Docstring
        GetDeviceOrigin() -> Point
        
        Returns the current device origin.
    %End

    wxRasterOperationMode GetLogicalFunction() const;
    %Docstring
        GetLogicalFunction() -> RasterOperationMode
        
        Gets the current logical function.
    %End

    wxMappingMode GetMapMode() const;
    %Docstring
        GetMapMode() -> MappingMode
        
        Gets the current mapping mode for the device context.
    %End

    wxColour* GetPixel(wxCoord x,  wxCoord y)   /Factory/;
    %Docstring
        GetPixel(x, y) -> Colour
        
        Gets the colour at the specified location on the DC.
        
        This method isn't available for ``wx.PostScriptDC`` or
        ``wx.MetafileDC`` nor
        for any DC in wxOSX port, and simply returns ``wx.NullColour`` there.
        
        .. note:: Setting a pixel can be done using DrawPoint().
        
        .. note:: This method shouldn't be used with ``wx.PaintDC`` as
        accessing the
                  DC while drawing can result in unexpected results, notably
        in wxGTK.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetPixel(sipCpp, x, y);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxColour* _wxDC_GetPixel(wxDC* self, wxCoord x, wxCoord y)
    {
        wxColour* col = new wxColour;
        self->GetPixel(x, y, col);
        return col;
    }
    %End

    wxSize GetPPI() const;
    %Docstring
        GetPPI() -> Size
        
        Returns the resolution of the device in pixels per inch.
    %End

    wxSize GetSize() const;
    %Docstring
        GetSize() -> Size
        
        This is an overloaded member function, provided for convenience. It
        differs from the above function only in what argument(s) it accepts.
    %End

    wxSize GetSizeMM() const;
    %Docstring
        GetSizeMM() -> Size
        
        This is an overloaded member function, provided for convenience. It
        differs from the above function only in what argument(s) it accepts.
    %End

    void GetUserScale(
        double * x   /Out/,
        double * y   /Out/
    ) const;
    %Docstring
        GetUserScale() -> (x, y)
        
        Gets the current user scale factor.
    %End

    bool IsOk() const;
    %Docstring
        IsOk() -> bool
        
        Returns true if the DC is ok to use.
    %End

    void SetAxisOrientation(
        bool xLeftRight,
        bool yBottomUp
    );
    %Docstring
        SetAxisOrientation(xLeftRight, yBottomUp)
        
        Sets the x and y axis orientation (i.e. the direction from lowest to
        highest values on the axis).
    %End

    void SetDeviceOrigin(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        SetDeviceOrigin(x, y)
        
        Sets the device origin (i.e. the origin in pixels after scaling has
        been applied).
    %End

    void SetLogicalFunction(
        wxRasterOperationMode function
    );
    %Docstring
        SetLogicalFunction(function)
        
        Sets the current logical function for the device context.
    %End

    void SetMapMode(
        wxMappingMode mode
    );
    %Docstring
        SetMapMode(mode)
        
        The mapping mode of the device context defines the unit of measurement
        used to convert logical units to device units.
    %End

    void SetPalette(
        const wxPalette & palette
    );
    %Docstring
        SetPalette(palette)
        
        If this is a window DC or memory DC, assigns the given palette to the
        window or bitmap associated with the DC.
    %End

    void SetUserScale(
        double xScale,
        double yScale
    );
    %Docstring
        SetUserScale(xScale, yScale)
        
        Sets the user scaling factor, useful for applications which require
        'zooming'.
    %End

    wxUIntPtr* GetHandle() const;
    %Docstring
        GetHandle() -> UIntPtr
        
        Returns a value that can be used as a handle to the native drawing
        context, if this wxDC has something that could be thought of in that
        way.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetHandle(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxUIntPtr* _wxDC_GetHandle(const wxDC* self)
    {
        return new wxUIntPtr((wxUIntPtr)self->GetHandle());
    }
    %End

    wxBitmap GetAsBitmap(
        const wxRect * subrect = NULL
    ) const;
    %Docstring
        GetAsBitmap(subrect=None) -> Bitmap
        
        If supported by the platform and the type of DC, fetch the contents of
        the DC, or a subset of it, as a bitmap.
    %End

    void SetLogicalScale(
        double x,
        double y
    );
    %Docstring
        SetLogicalScale(x, y)
        
        Set the scale to use for translating wxDC coordinates to the physical
        pixels.
    %End

    void GetLogicalScale(
        double * x   /Out/,
        double * y   /Out/
    ) const;
    %Docstring
        GetLogicalScale() -> (x, y)
        
        Return the scale set by the last call to SetLogicalScale().
    %End

    void SetLogicalOrigin(
        wxCoord x,
        wxCoord y
    );
    %Docstring
        SetLogicalOrigin(x, y)
        
        Change the offset used for translating wxDC coordinates.
    %End

    wxGraphicsContext * GetGraphicsContext() const;
    %Docstring
        GetGraphicsContext() -> GraphicsContext
        
        If supported by the platform and the wxDC implementation, this method
        will return the wxGraphicsContext associated with the DC.
    %End

    void SetGraphicsContext(
        wxGraphicsContext * ctx
    );
    %Docstring
        SetGraphicsContext(ctx)
        
        Associate a wxGraphicsContext with the DC.
    %End

    private:
        wxDC(const wxDC&);


    public:


    public:
        virtual ~wxDC();


    wxSize* GetTextExtent(const wxString& st) const   /Factory/;
    %Docstring
        GetTextExtent(st) -> Size
        
        Return the dimensions of the given string's text extent using the
        currently selected font.
        
        :param st: The string to be measured
        
        .. seealso:: :meth:`~wx.DC.GetFullTextExtent`
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetTextExtent(sipCpp, st);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxSize* _wxDC_GetTextExtent(const wxDC* self, const wxString* st)
    {
        return new wxSize(self->GetTextExtent(*st));
    }
    %End

    wxSize* GetMultiLineTextExtent(const wxString& st) const   /Factory/;
    %Docstring
        GetMultiLineTextExtent(st) -> Size
        
        Return the dimensions of the given string's text extent using the
        currently selected font, taking into account multiple lines if
        present in the string.
        
        :param st: The string to be measured
        
        .. seealso:: :meth:`~wx.DC.GetFullMultiLineTextExtent`
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetMultiLineTextExtent(sipCpp, st);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxSize* _wxDC_GetMultiLineTextExtent(const wxDC* self, const wxString* st)
    {
        return new wxSize(self->GetMultiLineTextExtent(*st));
    }
    %End

    int __nonzero__();
    %Docstring
        __nonzero__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC___nonzero__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxDC___nonzero__(wxDC* self)
    {
        return self->IsOk();
    }
    %End

    int __bool__();
    %Docstring
        __bool__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC___bool__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxDC___bool__(wxDC* self)
    {
        return self->IsOk();
    }
    %End

    long GetHDC();
    %Docstring
        GetHDC() -> long
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetHDC(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    long _wxDC_GetHDC(wxDC* self)
    {
        #ifdef __WXMSW__
            return (long)self->GetHandle();
        #else
            wxPyRaiseNotImplemented();
            return 0;
        #endif
    }
    %End

    wxUIntPtr* GetCGContext();
    %Docstring
        GetCGContext() -> UIntPtr
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetCGContext(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxUIntPtr* _wxDC_GetCGContext(wxDC* self)
    {
        #ifdef __WXMAC__
            return new wxUIntPtr((wxUIntPtr)self->GetHandle());
        #else
            wxPyRaiseNotImplemented();
            return NULL;
        #endif
    }
    %End

    wxUIntPtr* GetGdkDrawable();
    %Docstring
        GetGdkDrawable() -> UIntPtr
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC_GetGdkDrawable(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxUIntPtr* _wxDC_GetGdkDrawable(wxDC* self)
    {
        #ifdef __WXGTK__
            return new wxUIntPtr((wxUIntPtr)self->GetHandle());
        #else
            wxPyRaiseNotImplemented();
            return NULL;
        #endif
    }
    %End

    PyObject* _DrawPointList(PyObject* pyCoords,  PyObject* pyPens,  PyObject* pyBrushes);
    %Docstring
        _DrawPointList(pyCoords, pyPens, pyBrushes) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawPointList(sipCpp, pyCoords, pyPens, pyBrushes);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawPointList(wxDC* self, PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
    {
        return wxPyDrawXXXList(*self, wxPyDrawXXXPoint, pyCoords, pyPens, pyBrushes);
    }
    %End

    PyObject* _DrawLineList(PyObject* pyCoords,  PyObject* pyPens,  PyObject* pyBrushes);
    %Docstring
        _DrawLineList(pyCoords, pyPens, pyBrushes) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawLineList(sipCpp, pyCoords, pyPens, pyBrushes);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawLineList(wxDC* self, PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
    {
        return wxPyDrawXXXList(*self, wxPyDrawXXXLine, pyCoords, pyPens, pyBrushes);
    }
    %End

    PyObject* _DrawRectangleList(PyObject* pyCoords,  PyObject* pyPens,  PyObject* pyBrushes);
    %Docstring
        _DrawRectangleList(pyCoords, pyPens, pyBrushes) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawRectangleList(sipCpp, pyCoords, pyPens, pyBrushes);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawRectangleList(wxDC* self, PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
    {
        return wxPyDrawXXXList(*self, wxPyDrawXXXRectangle, pyCoords, pyPens, pyBrushes);
    }
    %End

    PyObject* _DrawEllipseList(PyObject* pyCoords,  PyObject* pyPens,  PyObject* pyBrushes);
    %Docstring
        _DrawEllipseList(pyCoords, pyPens, pyBrushes) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawEllipseList(sipCpp, pyCoords, pyPens, pyBrushes);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawEllipseList(wxDC* self, PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
    {
        return wxPyDrawXXXList(*self, wxPyDrawXXXEllipse, pyCoords, pyPens, pyBrushes);
    }
    %End

    PyObject* _DrawPolygonList(PyObject* pyCoords,  PyObject* pyPens,  PyObject* pyBrushes);
    %Docstring
        _DrawPolygonList(pyCoords, pyPens, pyBrushes) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawPolygonList(sipCpp, pyCoords, pyPens, pyBrushes);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawPolygonList(wxDC* self, PyObject* pyCoords, PyObject* pyPens, PyObject* pyBrushes)
    {
        return wxPyDrawXXXList(*self, wxPyDrawXXXPolygon, pyCoords, pyPens, pyBrushes);
    }
    %End

    PyObject* _DrawTextList(PyObject* textList,  PyObject* pyPoints,  PyObject* foregroundList,  PyObject* backgroundList);
    %Docstring
        _DrawTextList(textList, pyPoints, foregroundList, backgroundList) -> PyObject
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxDC__DrawTextList(sipCpp, textList, pyPoints, foregroundList, backgroundList);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    PyObject* _wxDC__DrawTextList(wxDC* self, PyObject* textList, PyObject* pyPoints, PyObject* foregroundList, PyObject* backgroundList)
    {
        return wxPyDrawTextList(*self, textList, pyPoints, foregroundList, backgroundList);
    }
    %End

    public:


    %Property(name=AsBitmap, get=GetAsBitmap)
    %Property(name=Background, get=GetBackground, set=SetBackground)
    %Property(name=BackgroundMode, get=GetBackgroundMode, set=SetBackgroundMode)
    %Property(name=Brush, get=GetBrush, set=SetBrush)
    %Property(name=CGContext, get=GetCGContext)
    %Property(name=CharHeight, get=GetCharHeight)
    %Property(name=CharWidth, get=GetCharWidth)
    %Property(name=Depth, get=GetDepth)
    %Property(name=DeviceOrigin, get=GetDeviceOrigin, set=SetDeviceOrigin)
    %Property(name=Font, get=GetFont, set=SetFont)
    %Property(name=FontMetrics, get=GetFontMetrics)
    %Property(name=GdkDrawable, get=GetGdkDrawable)
    %Property(name=GraphicsContext, get=GetGraphicsContext, set=SetGraphicsContext)
    %Property(name=HDC, get=GetHDC)
    %Property(name=Handle, get=GetHandle)
    %Property(name=LayoutDirection, get=GetLayoutDirection, set=SetLayoutDirection)
    %Property(name=LogicalFunction, get=GetLogicalFunction, set=SetLogicalFunction)
    %Property(name=MapMode, get=GetMapMode, set=SetMapMode)
    %Property(name=MultiLineTextExtent, get=GetMultiLineTextExtent)
    %Property(name=PPI, get=GetPPI)
    %Property(name=Pen, get=GetPen, set=SetPen)
    %Property(name=Pixel, get=GetPixel)
    %Property(name=Size, get=GetSize)
    %Property(name=SizeMM, get=GetSizeMM)
    %Property(name=TextBackground, get=GetTextBackground, set=SetTextBackground)
    %Property(name=TextExtent, get=GetTextExtent)
    %Property(name=TextForeground, get=GetTextForeground, set=SetTextForeground)
    %Property(name=TransformMatrix, get=GetTransformMatrix, set=SetTransformMatrix)
};  // end of class wxDC


%Extract(id=pycode_core)
def _DC_GetClippingRect(self):
    """
    Returns the rectangle surrounding the current clipping region as a wx.Rect.
    """
    rv, x, y, w, h = self.GetClippingBox()
    return wx.Rect(x,y,w,h)
DC.GetClippingRect = _DC_GetClippingRect
del _DC_GetClippingRect
%End

%Extract(id=pycode_core)
DC.DrawImageLabel = wx.deprecated(DC.DrawLabel, "Use DrawLabel instead.")

%End

%Extract(id=pycode_core)
def _DC_GetBoundingBox(self):
    """
    GetBoundingBox() -> (x1,y1, x2,y2)
    
    Returns the min and max points used in drawing commands so far.
    """
    return (self.MinX(), self.MinY(), self.MaxX(), self.MaxY())
DC.GetBoundingBox = _DC_GetBoundingBox
del _DC_GetBoundingBox
%End

%Extract(id=pycode_core)
DC.GetHDC = wx.deprecated(DC.GetHDC, "Use GetHandle instead.")

%End

%Extract(id=pycode_core)
DC.GetCGContext = wx.deprecated(DC.GetCGContext, "Use GetHandle instead.")

%End

%Extract(id=pycode_core)
DC.GetGdkDrawable = wx.deprecated(DC.GetGdkDrawable, "Use GetHandle instead.")

%End

%Extract(id=pycode_core)
def _DC___enter__(self):
    return self
DC.__enter__ = _DC___enter__
del _DC___enter__
%End

%Extract(id=pycode_core)
def _DC___exit__(self, exc_type, exc_val, exc_tb):
    self.Destroy()
DC.__exit__ = _DC___exit__
del _DC___exit__
%End

%Extract(id=pycode_core)
def _DC_DrawPointList(self, points, pens=None):
    """
    Draw a list of points as quickly as possible.
    
    :param points: A sequence of 2-element sequences representing
                   each point to draw, (x,y).
    :param pens:   If None, then the current pen is used.  If a single
                   pen then it will be used for all points.  If a list of
                   pens then there should be one for each point in points.
    """
    if pens is None:
        pens = []
    elif isinstance(pens, wx.Pen):
        pens = [pens]
    elif len(pens) != len(points):
        raise ValueError('points and pens must have same length')
    return self._DrawPointList(points, pens, [])
DC.DrawPointList = _DC_DrawPointList
del _DC_DrawPointList
%End

%Extract(id=pycode_core)
def _DC_DrawLineList(self, lines, pens=None):
    """
    Draw a list of lines as quickly as possible.
    
    :param lines: A sequence of 4-element sequences representing
                  each line to draw, (x1,y1, x2,y2).
    :param pens:  If None, then the current pen is used.  If a
                  single pen then it will be used for all lines.  If
                  a list of pens then there should be one for each line
                  in lines.
    """
    if pens is None:
        pens = []
    elif isinstance(pens, wx.Pen):
        pens = [pens]
    elif len(pens) != len(lines):
        raise ValueError('lines and pens must have same length')
    return self._DrawLineList(lines, pens, [])
DC.DrawLineList = _DC_DrawLineList
del _DC_DrawLineList
%End

%Extract(id=pycode_core)
def _DC_DrawRectangleList(self, rectangles, pens=None, brushes=None):
    """
    Draw a list of rectangles as quickly as possible.
    
    :param rectangles: A sequence of 4-element sequences representing
                       each rectangle to draw, (x,y, w,h).
    :param pens:       If None, then the current pen is used.  If a
                       single pen then it will be used for all rectangles.
                       If a list of pens then there should be one for each
                       rectangle in rectangles.
    :param brushes:    A brush or brushes to be used to fill the rectagles,
                       with similar semantics as the pens parameter.
    """
    if pens is None:
        pens = []
    elif isinstance(pens, wx.Pen):
        pens = [pens]
    elif len(pens) != len(rectangles):
        raise ValueError('rectangles and pens must have same length')
    if brushes is None:
        brushes = []
    elif isinstance(brushes, wx.Brush):
        brushes = [brushes]
    elif len(brushes) != len(rectangles):
        raise ValueError('rectangles and brushes must have same length')
    return self._DrawRectangleList(rectangles, pens, brushes)
DC.DrawRectangleList = _DC_DrawRectangleList
del _DC_DrawRectangleList
%End

%Extract(id=pycode_core)
def _DC_DrawEllipseList(self, ellipses, pens=None, brushes=None):
    """
    Draw a list of ellipses as quickly as possible.
    
    :param ellipses: A sequence of 4-element sequences representing
                     each ellipse to draw, (x,y, w,h).
    :param pens:     If None, then the current pen is used.  If a
                     single pen then it will be used for all ellipses.
                     If a list of pens then there should be one for each
                     ellipse in ellipses.
    :param brushes:  A brush or brushes to be used to fill the ellipses,
                     with similar semantics as the pens parameter.
    """
    if pens is None:
        pens = []
    elif isinstance(pens, wx.Pen):
        pens = [pens]
    elif len(pens) != len(ellipses):
        raise ValueError('ellipses and pens must have same length')
    if brushes is None:
        brushes = []
    elif isinstance(brushes, wx.Brush):
        brushes = [brushes]
    elif len(brushes) != len(ellipses):
        raise ValueError('ellipses and brushes must have same length')
    return self._DrawEllipseList(ellipses, pens, brushes)
DC.DrawEllipseList = _DC_DrawEllipseList
del _DC_DrawEllipseList
%End

%Extract(id=pycode_core)
def _DC_DrawPolygonList(self, polygons, pens=None, brushes=None):
    """
    Draw a list of polygons, each of which is a list of points.
    
    :param polygons: A sequence of sequences of sequences.
                     [[(x1,y1),(x2,y2),(x3,y3)...], [(x1,y1),(x2,y2),(x3,y3)...]]
    
    :param pens:     If None, then the current pen is used.  If a
                     single pen then it will be used for all polygons.
                     If a list of pens then there should be one for each
                     polygon.
    :param brushes:  A brush or brushes to be used to fill the polygons,
                     with similar semantics as the pens parameter.
    """
    if pens is None:
        pens = []
    elif isinstance(pens, wx.Pen):
        pens = [pens]
    elif len(pens) != len(polygons):
        raise ValueError('polygons and pens must have same length')
    if brushes is None:
        brushes = []
    elif isinstance(brushes, wx.Brush):
        brushes = [brushes]
    elif len(brushes) != len(polygons):
        raise ValueError('polygons and brushes must have same length')
    return self._DrawPolygonList(polygons, pens, brushes)
DC.DrawPolygonList = _DC_DrawPolygonList
del _DC_DrawPolygonList
%End

%Extract(id=pycode_core)
def _DC_DrawTextList(self, textList, coords, foregrounds=None, backgrounds=None):
    """
    Draw a list of strings using a list of coordinants for positioning each string.
    
    :param textList:    A list of strings
    :param coords:      A list of (x,y) positions
    :param foregrounds: A list of `wx.Colour` objects to use for the
                        foregrounds of the strings.
    :param backgrounds: A list of `wx.Colour` objects to use for the
                        backgrounds of the strings.
    
    NOTE: Make sure you set background mode to wx.Solid (DC.SetBackgroundMode)
          If you want backgrounds to do anything.
    """
    if type(textList) == type(''):
        textList = [textList]
    elif len(textList) != len(coords):
        raise ValueError('textlist and coords must have same length')
    if foregrounds is None:
        foregrounds = []
    elif isinstance(foregrounds, wx.Colour):
        foregrounds = [foregrounds]
    elif len(foregrounds) != len(coords):
        raise ValueError('foregrounds and coords must have same length')
    if backgrounds is None:
        backgrounds = []
    elif isinstance(backgrounds, wx.Colour):
        backgrounds = [backgrounds]
    elif len(backgrounds) != len(coords):
        raise ValueError('backgrounds and coords must have same length')
    return  self._DrawTextList(textList, coords, foregrounds, backgrounds)
DC.DrawTextList = _DC_DrawTextList
del _DC_DrawTextList
%End

%Extract(id=pycode_core)
DC.BoundingBox = property(DC.GetBoundingBox)
%End

%Extract(id=pycode_core)
DC.ClippingRect = property(DC.GetClippingRect)
%End

class wxDCClipper
{
    %Docstring
        DCClipper(dc, region)
        DCClipper(dc, rect)
        DCClipper(dc, x, y, w, h)
        
        wxDCClipper is a helper class for setting a clipping region on a wxDC
        during its lifetime.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCClipper(
        wxDC & dc,
        const wxRegion & region
    );

    wxDCClipper(
        wxDC & dc,
        const wxRect & rect
    );

    wxDCClipper(
        wxDC & dc,
        wxCoord x,
        wxCoord y,
        wxCoord w,
        wxCoord h
    );

    ~wxDCClipper();

    private:
        wxDCClipper(const wxDCClipper&);


};  // end of class wxDCClipper


%Extract(id=pycode_core)
def _DCClipper___enter__(self):
    return self
DCClipper.__enter__ = _DCClipper___enter__
del _DCClipper___enter__
%End

%Extract(id=pycode_core)
def _DCClipper___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCClipper.__exit__ = _DCClipper___exit__
del _DCClipper___exit__
%End

class wxDCBrushChanger
{
    %Docstring
        DCBrushChanger(dc, brush)
        
        wxDCBrushChanger is a small helper class for setting a brush on a wxDC
        and unsetting it automatically in the destructor, restoring the
        previous one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCBrushChanger(
        wxDC & dc,
        const wxBrush & brush
    );

    ~wxDCBrushChanger();

    private:
        wxDCBrushChanger(const wxDCBrushChanger&);


};  // end of class wxDCBrushChanger


%Extract(id=pycode_core)
def _DCBrushChanger___enter__(self):
    return self
DCBrushChanger.__enter__ = _DCBrushChanger___enter__
del _DCBrushChanger___enter__
%End

%Extract(id=pycode_core)
def _DCBrushChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCBrushChanger.__exit__ = _DCBrushChanger___exit__
del _DCBrushChanger___exit__
%End

class wxDCPenChanger
{
    %Docstring
        DCPenChanger(dc, pen)
        
        wxDCPenChanger is a small helper class for setting a pen on a wxDC and
        unsetting it automatically in the destructor, restoring the previous
        one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCPenChanger(
        wxDC & dc,
        const wxPen & pen
    );

    ~wxDCPenChanger();

    private:
        wxDCPenChanger(const wxDCPenChanger&);


};  // end of class wxDCPenChanger


%Extract(id=pycode_core)
def _DCPenChanger___enter__(self):
    return self
DCPenChanger.__enter__ = _DCPenChanger___enter__
del _DCPenChanger___enter__
%End

%Extract(id=pycode_core)
def _DCPenChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCPenChanger.__exit__ = _DCPenChanger___exit__
del _DCPenChanger___exit__
%End

class wxDCTextColourChanger
{
    %Docstring
        DCTextColourChanger(dc)
        DCTextColourChanger(dc, col)
        
        wxDCTextColourChanger is a small helper class for setting a foreground
        text colour on a wxDC and unsetting it automatically in the
        destructor, restoring the previous one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCTextColourChanger(
        wxDC & dc
    );

    wxDCTextColourChanger(
        wxDC & dc,
        const wxColour & col
    );

    ~wxDCTextColourChanger();

    void Set(
        const wxColour & col
    );
    %Docstring
        Set(col)
        
        Set the colour to use.
    %End

    private:
        wxDCTextColourChanger(const wxDCTextColourChanger&);


};  // end of class wxDCTextColourChanger


%Extract(id=pycode_core)
def _DCTextColourChanger___enter__(self):
    return self
DCTextColourChanger.__enter__ = _DCTextColourChanger___enter__
del _DCTextColourChanger___enter__
%End

%Extract(id=pycode_core)
def _DCTextColourChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCTextColourChanger.__exit__ = _DCTextColourChanger___exit__
del _DCTextColourChanger___exit__
%End

class wxDCFontChanger
{
    %Docstring
        DCFontChanger(dc)
        DCFontChanger(dc, font)
        
        wxDCFontChanger is a small helper class for setting a font on a wxDC
        and unsetting it automatically in the destructor, restoring the
        previous one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCFontChanger(
        wxDC & dc
    );

    wxDCFontChanger(
        wxDC & dc,
        const wxFont & font
    );

    ~wxDCFontChanger();

    void Set(
        const wxFont & font
    );
    %Docstring
        Set(font)
        
        Set the font to use.
    %End

    private:
        wxDCFontChanger(const wxDCFontChanger&);


};  // end of class wxDCFontChanger


%Extract(id=pycode_core)
def _DCFontChanger___enter__(self):
    return self
DCFontChanger.__enter__ = _DCFontChanger___enter__
del _DCFontChanger___enter__
%End

%Extract(id=pycode_core)
def _DCFontChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCFontChanger.__exit__ = _DCFontChanger___exit__
del _DCFontChanger___exit__
%End

class wxDCTextBgColourChanger
{
    %Docstring
        DCTextBgColourChanger(dc)
        DCTextBgColourChanger(dc, col)
        
        wxDCTextBgColourChanger is a small helper class for setting a
        background text colour on a wxDC and unsetting it automatically in the
        destructor, restoring the previous one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    wxDCTextBgColourChanger(
        wxDC & dc
    );

    wxDCTextBgColourChanger(
        wxDC & dc,
        const wxColour & col
    );

    ~wxDCTextBgColourChanger();

    void Set(
        const wxColour & col
    );
    %Docstring
        Set(col)
        
        Set the background colour to use.
    %End

    private:
        wxDCTextBgColourChanger(const wxDCTextBgColourChanger&);


};  // end of class wxDCTextBgColourChanger


%Extract(id=pycode_core)
def _DCTextBgColourChanger___enter__(self):
    return self
DCTextBgColourChanger.__enter__ = _DCTextBgColourChanger___enter__
del _DCTextBgColourChanger___enter__
%End

%Extract(id=pycode_core)
def _DCTextBgColourChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCTextBgColourChanger.__exit__ = _DCTextBgColourChanger___exit__
del _DCTextBgColourChanger___exit__
%End

class wxDCTextBgModeChanger
{
    %Docstring
        wxDCTextBgModeChanger is a small helper class for setting a background
        text mode on a wxDC and unsetting it automatically in the destructor,
        restoring the previous one.
    %End
    %TypeHeaderCode
        #include <wx/dc.h>
    %End

public:
    private:
        wxDCTextBgModeChanger(const wxDCTextBgModeChanger&);


};  // end of class wxDCTextBgModeChanger


%Extract(id=pycode_core)
def _DCTextBgModeChanger___enter__(self):
    return self
DCTextBgModeChanger.__enter__ = _DCTextBgModeChanger___enter__
del _DCTextBgModeChanger___enter__
%End

%Extract(id=pycode_core)
def _DCTextBgModeChanger___exit__(self, exc_type, exc_val, exc_tb):
    return False
DCTextBgModeChanger.__exit__ = _DCTextBgModeChanger___exit__
del _DCTextBgModeChanger___exit__
%End


//---------------------------------------------------------------------------

