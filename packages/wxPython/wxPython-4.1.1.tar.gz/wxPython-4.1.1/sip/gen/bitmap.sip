//---------------------------------------------------------------------------
// This file is generated by wxPython's SIP generator.  Do not edit by hand.
//
// Copyright: (c) 2020 by Total Control Software
// License:   wxWindows License
//
// This file will be included by _core.sip
//
//---------------------------------------------------------------------------

%ModuleHeaderCode
#include "bitmap_ex.h"
%End


//---------------------------------------------------------------------------

enum wxBitmapBufferFormat
{
    wxBitmapBufferFormat_RGB,
    wxBitmapBufferFormat_RGBA,
    wxBitmapBufferFormat_RGB32,
    wxBitmapBufferFormat_ARGB32
};

const int wxBITMAP_SCREEN_DEPTH;
class wxBitmap : wxGDIObject
{
    %Docstring
        Bitmap()
        Bitmap(bitmap)
        Bitmap(bits, width, height, depth=1)
        Bitmap(width, height, depth=BITMAP_SCREEN_DEPTH)
        Bitmap(sz, depth=BITMAP_SCREEN_DEPTH)
        Bitmap(name, type=BITMAP_TYPE_ANY)
        Bitmap(img, depth=BITMAP_SCREEN_DEPTH)
        Bitmap(listOfBytes)
        
        This class encapsulates the concept of a platform-dependent bitmap,
        either monochrome or colour or colour with alpha channel support.
    %End
    %TypeHeaderCode
        #include <wx/bitmap.h>
    %End

    %TypeCode
        //--------------------------------------------------------------------------
        // Name:        src/bitmap_ex.h
        // Purpose:     Helper functions and etc. for copying bitmap data to/from
        //              buffer objects.  This file is included in etg/bitmap.py and
        //              used in the wxBitmap wrapper.
        //
        // Author:      Robin Dunn
        //
        // Created:     27-Apr-2012
        // Copyright:   (c) 2012-2020 by Total Control Software
        // Licence:     wxWindows license
        //--------------------------------------------------------------------------
        
        
        #include <wx/rawbmp.h>
        
        // TODO: Switch these APIs to use the new wxPyBuffer class
        
        void wxPyCopyBitmapFromBuffer(wxBitmap* bmp,
                                      buffer data, Py_ssize_t DATASIZE,
                                      wxBitmapBufferFormat format, int stride)
        {
            int height = bmp->GetHeight();
            int width = bmp->GetWidth();
        
            switch (format) {
                // A simple sequence of RGB bytes
                case wxBitmapBufferFormat_RGB:
                {
                    if (DATASIZE < width * height * 3) {
                        wxPyErr_SetString(PyExc_ValueError, "Invalid data buffer size.");
                        return;
                    }
                    wxNativePixelData pixData(*bmp, wxPoint(0,0), wxSize(width, height));
                    if (! pixData) {
                        wxPyErr_SetString(PyExc_RuntimeError,
                                          "Failed to gain raw access to bitmap data.");
                        return;
                    }
        
                    wxNativePixelData::Iterator p(pixData);
                    for (int y=0; y<height; y++) {
                        wxNativePixelData::Iterator rowStart = p;
                        for (int x=0; x<width; x++) {
                            p.Red()   = *(data++);
                            p.Green() = *(data++);
                            p.Blue()  = *(data++);
                            ++p;
                        }
                        p = rowStart;
                        p.OffsetY(pixData, 1);
                    }
                    break;
                }
        
                // A simple sequence of RGBA bytes
                case wxBitmapBufferFormat_RGBA:
                {
                    if (DATASIZE < width * height * 4) {
                        wxPyErr_SetString(PyExc_ValueError, "Invalid data buffer size.");
                        return;
                    }
                    wxAlphaPixelData pixData(*bmp, wxPoint(0,0), wxSize(width, height));
                    if (! pixData) {
                        wxPyErr_SetString(PyExc_RuntimeError,
                                          "Failed to gain raw access to bitmap data.");
                        return;
                    }
                    wxAlphaPixelData::Iterator p(pixData);
                    for (int y=0; y<height; y++) {
                        wxAlphaPixelData::Iterator rowStart = p;
                        for (int x=0; x<width; x++) {
                            byte a = data[3];
                            p.Red()   = wxPy_premultiply(*(data++), a);
                            p.Green() = wxPy_premultiply(*(data++), a);
                            p.Blue()  = wxPy_premultiply(*(data++), a);
                            p.Alpha() = a; data++;
                            ++p;
                        }
                        p = rowStart;
                        p.OffsetY(pixData, 1);
                    }
                    break;
                }
        
                // A sequence of 32-bit values in native endian order,
                // where the alpha is in the upper 8 bits, then red, then
                // green, then blue.  The stride is the distance in bytes
                // from the beginning of one row of the image data to the
                // beginning of the next row.  This may not be the same as
                // width*4 if alignment or platform specific optimizations
                // have been utilized.
        
                // NOTE: This is normally used with Cairo, which seems to
                // already have the values premultiplied.  Should we have
                // a way to optionally do it anyway?
        
                case wxBitmapBufferFormat_RGB32:
                case wxBitmapBufferFormat_ARGB32:
                {
                    bool useAlpha = (format == wxBitmapBufferFormat_ARGB32);
                    byte* rowStart = data;
                    wxUint32* bufptr;
                    wxUint32  value;
        
                    if (stride == -1)
                        stride = width * 4;
        
                    if (DATASIZE < stride * height) {
                        wxPyErr_SetString(PyExc_ValueError, "Invalid data buffer size.");
                        return;
                    }
        
                    wxAlphaPixelData pixData(*bmp, wxPoint(0,0), wxSize(width,height));
                    if (! pixData) {
                        wxPyErr_SetString(PyExc_RuntimeError,
                                          "Failed to gain raw access to bitmap data.");
                        return;
                    }
        
                    wxAlphaPixelData::Iterator pix(pixData);
                    for (int y=0; y<height; y++) {
                        pix.MoveTo(pixData, 0, y);
                        bufptr = (wxUint32*)rowStart;
                        for (int x=0; x<width; x++) {
                            value = *bufptr;
                            pix.Alpha() = useAlpha ? (value >> 24) & 0xFF : 255;
                            pix.Red()   = (value >> 16) & 0xFF;
                            pix.Green() = (value >>  8) & 0xFF;
                            pix.Blue()  = (value >>  0) & 0xFF;
                            ++pix;
                            ++bufptr;
                        }
                        rowStart += stride;
                    }
                    break;
                }
            }
        }
        
        
        // Some helper macros used below to help declutter the code
        #define MAKE_PIXDATA(type) \
            type pixData(*bmp, wxPoint(0,0), wxSize(width, height)); \
            if (! pixData) { \
                wxPyErr_SetString(PyExc_RuntimeError, "Failed to gain raw access to bitmap data."); \
                return; \
            } \
            type::Iterator p(pixData); \
            type::Iterator rowStart
        
        #define CHECK_BUFFERSIZE(size_needed) \
            if (DATASIZE < size_needed) { \
                wxPyErr_SetString(PyExc_ValueError, "Invalid data buffer size."); \
                return; \
            }
        
        
        void wxPyCopyBitmapToBuffer(wxBitmap* bmp,
                                    buffer data, Py_ssize_t DATASIZE,
                                    wxBitmapBufferFormat format, int stride)
        {
            int height = bmp->GetHeight();
            int width = bmp->GetWidth();
            int depth = bmp->GetDepth();
        
            // images loaded from a file may not have set the depth, at least on Mac...
            if (depth == -1) {
                if (bmp->HasAlpha())
                    depth = 32;
                else
                    depth = 24;
            }
        
            switch (format) {
                // A simple sequence of RGB bytes
                case wxBitmapBufferFormat_RGB:
                {
                    CHECK_BUFFERSIZE(width * height * 3);
                    if (depth == 24) {
                        MAKE_PIXDATA(wxNativePixelData);
        
                        for (int y=0; y<height; y++) {
                            rowStart = p;
                            for (int x=0; x<width; x++) {
                                *(data++) = p.Red();
                                *(data++) = p.Green();
                                *(data++) = p.Blue();
                                ++p;
                            }
                            p = rowStart;
                            p.OffsetY(pixData, 1);
                        }
                    }
                    if (depth == 32) {
                        // Source has alpha, but we won't be using it because the
                        // destination buffer doesn't
                        MAKE_PIXDATA(wxAlphaPixelData);
        
                        for (int y=0; y<height; y++) {
                            rowStart = p;
                            for (int x=0; x<width; x++) {
                                *(data++) = p.Red();
                                *(data++) = p.Green();
                                *(data++) = p.Blue();
                                ++p;
                            }
                            p = rowStart;
                            p.OffsetY(pixData, 1);
                        }
                    }
                    break;
                }
        
                // A simple sequence of RGBA bytes
                case wxBitmapBufferFormat_RGBA:
                {
                    CHECK_BUFFERSIZE(width * height * 4);
                    if (depth == 24) {
                        MAKE_PIXDATA(wxNativePixelData);
                        for (int y=0; y<height; y++) {
                            rowStart = p;
                            for (int x=0; x<width; x++) {
                                byte a = wxALPHA_OPAQUE;
                                *(data++) = wxPy_unpremultiply(p.Red(), a);
                                *(data++) = wxPy_unpremultiply(p.Green(), a);
                                *(data++) = wxPy_unpremultiply(p.Blue(), a);
                                *(data++) = a;
                                ++p;
                            }
                            p = rowStart;
                            p.OffsetY(pixData, 1);
                        }
                    }
                    if (depth == 32) {
                        MAKE_PIXDATA(wxAlphaPixelData);
                        for (int y=0; y<height; y++) {
                            rowStart = p;
                            for (int x=0; x<width; x++) {
                                byte a = p.Alpha();
                                *(data++) = wxPy_unpremultiply(p.Red(), a);
                                *(data++) = wxPy_unpremultiply(p.Green(), a);
                                *(data++) = wxPy_unpremultiply(p.Blue(), a);
                                *(data++) = a;
                                ++p;
                            }
                            p = rowStart;
                            p.OffsetY(pixData, 1);
                        }
                    }
                    break;
                }
        
                // A sequence of 32-bit values in native endian order,
                // where the alpha is in the upper 8 bits, then red, then
                // green, then blue.  The stride is the distance in bytes
                // from the beginning of one row of the image data to the
                // beginning of the next row.  This may not be the same as
                // width*4 if alignment or platform specific optimizations
                // have been utilized.
        
                // NOTE: This is normally used with Cairo, which seems to
                // already have the values premultiplied.  Should we have
                // a way to optionally do it anyway?
        
                case wxBitmapBufferFormat_RGB32:
                case wxBitmapBufferFormat_ARGB32:
                {
                    bool useAlpha = (format == wxBitmapBufferFormat_ARGB32);
                    byte* dataRow = data;
                    wxUint32* bufptr;
                    wxUint32  value;
        
                    if (stride == -1)
                        stride = width * 4;
        
                    CHECK_BUFFERSIZE(stride * height);
        
                    if (useAlpha && depth == 32) {
                        MAKE_PIXDATA(wxAlphaPixelData);
                        for (int y=0; y<height; y++) {
                            p.MoveTo(pixData, 0, y);
                            bufptr = (wxUint32*)dataRow;
                            for (int x=0; x<width; x++) {
                                value =
                                    (p.Alpha() << 24) |
                                    (p.Red() << 16) |
                                    (p.Green() << 8) |
                                    (p.Blue());
                                *bufptr = value;
                                ++p;
                                ++bufptr;
                            }
                            dataRow += stride;
                        }
                    }
                    else // if (!useAlpha /*depth == 24*/)
                    {
                        MAKE_PIXDATA(wxNativePixelData);
                        for (int y=0; y<height; y++) {
                            p.MoveTo(pixData, 0, y);
                            bufptr = (wxUint32*)dataRow;
                            for (int x=0; x<width; x++) {
                                value =
                                    (wxALPHA_OPAQUE << 24) |
                                    (p.Red() << 16) |
                                    (p.Green() << 8) |
                                    (p.Blue());
                                *bufptr = value;
                                ++p;
                                ++bufptr;
                            }
                            dataRow += stride;
                        }
                    }
                    break;
                }
            }
        }
        
        //--------------------------------------------------------------------------
    %End
public:
    wxBitmap();
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        const wxBitmap & bitmap
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        const char* bits,
        int width,
        int height,
        int depth = 1
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        int width,
        int height,
        int depth = wxBITMAP_SCREEN_DEPTH
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        const wxSize & sz,
        int depth = wxBITMAP_SCREEN_DEPTH
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        const wxString & name,
        wxBitmapType type = wxBITMAP_TYPE_ANY
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(
        const wxImage & img,
        int depth = wxBITMAP_SCREEN_DEPTH
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxBitmap(PyObject* listOfBytes)   /NoDerived/;
    %MethodCode
        PyErr_Clear();
        sipCpp = _wxBitmap_ctor(listOfBytes);
    %End
    %TypeCode
    wxBitmap* _wxBitmap_ctor(PyObject* listOfBytes)
    {
        wxPyThreadBlocker blocker;
        char**    cArray = NULL;
        int       count;
        char      errMsg[] = "Expected a list of bytes objects.";
        
        if (!PyList_Check(listOfBytes)) {
            PyErr_SetString(PyExc_TypeError, errMsg);
            return NULL;
        }
        count = PyList_Size(listOfBytes);
        cArray = new char*[count];
        
        for(int x=0; x<count; x++) {
            PyObject* item = PyList_GET_ITEM(listOfBytes, x);
            if (!PyBytes_Check(item)) {
                PyErr_SetString(PyExc_TypeError, errMsg);
                delete [] cArray;
                return NULL;
            }
            cArray[x] = PyBytes_AsString(item);
        }
        wxBitmap* bmp = new wxBitmap(cArray);
        delete [] cArray;
        return bmp;
    }
    %End

    ~wxBitmap();

    wxImage ConvertToImage() const;
    %Docstring
        ConvertToImage() -> Image
        
        Creates an image from a platform-dependent bitmap.
    %End

    bool CopyFromIcon(
        const wxIcon & icon
    );
    %Docstring
        CopyFromIcon(icon) -> bool
        
        Creates the bitmap from an icon.
    %End

    bool Create(
        int width,
        int height,
        int depth = wxBITMAP_SCREEN_DEPTH
    );
    %Docstring
        Create(width, height, depth=BITMAP_SCREEN_DEPTH) -> bool
        Create(sz, depth=BITMAP_SCREEN_DEPTH) -> bool
        Create(width, height, dc) -> bool
        
        Creates a fresh bitmap.
    %End

    bool Create(
        const wxSize & sz,
        int depth = wxBITMAP_SCREEN_DEPTH
    );

    bool Create(
        int width,
        int height,
        const wxDC & dc
    );

    bool CreateScaled(
        int width,
        int height,
        int depth,
        double logicalScale
    );
    %Docstring
        CreateScaled(width, height, depth, logicalScale) -> bool
        
        Create a bitmap with a scale factor, width and height are multiplied
        with that factor.
    %End

    int GetDepth() const;
    %Docstring
        GetDepth() -> int
        
        Gets the colour depth of the bitmap.
    %End

    int GetHeight() const;
    %Docstring
        GetHeight() -> int
        
        Gets the height of the bitmap in pixels.
    %End

    wxMask * GetMask() const;
    %Docstring
        GetMask() -> Mask
        
        Gets the associated mask (if any) which may have been loaded from a
        file or set for the bitmap.
    %End

    wxPalette * GetPalette() const;
    %Docstring
        GetPalette() -> Palette
        
        Gets the associated palette (if any) which may have been loaded from a
        file or set for the bitmap.
    %End

    wxBitmap GetSubBitmap(
        const wxRect & rect
    ) const;
    %Docstring
        GetSubBitmap(rect) -> Bitmap
        
        Returns a sub bitmap of the current one as long as the rect belongs
        entirely to the bitmap.
    %End

    wxSize GetSize() const;
    %Docstring
        GetSize() -> Size
        
        Returns the size of the bitmap in pixels.
    %End

    wxBitmap ConvertToDisabled(
        unsigned char brightness = 255
    ) const;
    %Docstring
        ConvertToDisabled(brightness=255) -> Bitmap
        
        Returns disabled (dimmed) version of the bitmap.
    %End

    int GetWidth() const;
    %Docstring
        GetWidth() -> int
        
        Gets the width of the bitmap in pixels.
    %End

    bool IsOk() const;
    %Docstring
        IsOk() -> bool
        
        Returns true if bitmap data is present.
    %End

    bool LoadFile(
        const wxString & name,
        wxBitmapType type = wxBITMAP_TYPE_ANY
    );
    %Docstring
        LoadFile(name, type=BITMAP_TYPE_ANY) -> bool
        
        Loads a bitmap from a file or resource.
    %End

    bool SaveFile(
        const wxString & name,
        wxBitmapType type,
        const wxPalette * palette = NULL
    ) const;
    %Docstring
        SaveFile(name, type, palette=None) -> bool
        
        Saves a bitmap in the named file.
    %End

    void SetDepth(
        int depth
    )   /Deprecated/;
    %Docstring
        SetDepth(depth)
    %End

    void SetHeight(
        int height
    )   /Deprecated/;
    %Docstring
        SetHeight(height)
    %End

    void SetMask(
        wxMask * mask   /Transfer/
    );
    %Docstring
        SetMask(mask)
        
        Sets the mask for this bitmap.
    %End

    void SetPalette(
        const wxPalette & palette
    );
    %Docstring
        SetPalette(palette)
        
        Sets the associated palette.
    %End

    void SetWidth(
        int width
    )   /Deprecated/;
    %Docstring
        SetWidth(width)
    %End

    static
    wxBitmap NewFromPNGData(
        const void * data,
        size_t size
    );
    %Docstring
        NewFromPNGData(data, size) -> Bitmap
        
        Loads a bitmap from the memory containing image data in PNG format.
    %End

    void SetMaskColour(const wxColour& colour);
    %Docstring
        SetMaskColour(colour)
        
        Create a mask for this bitmap based on the pixels with the given
        colour.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxBitmap_SetMaskColour(sipCpp, colour);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxBitmap_SetMaskColour(wxBitmap* self, const wxColour* colour)
    {
        wxMask* mask = new wxMask(*self, *colour);
        self->SetMask(mask);
    }
    %End

    int __nonzero__();
    %Docstring
        __nonzero__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap___nonzero__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxBitmap___nonzero__(wxBitmap* self)
    {
        return self->IsOk();
    }
    %End

    int __bool__();
    %Docstring
        __bool__() -> int
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap___bool__(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    int _wxBitmap___bool__(wxBitmap* self)
    {
        return self->IsOk();
    }
    %End

    long GetHandle();
    %Docstring
        GetHandle() -> long
        
        MSW-only method to fetch the windows handle for the bitmap.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_GetHandle(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    long _wxBitmap_GetHandle(wxBitmap* self)
    {
        #ifdef __WXMSW__
            return (long)self->GetHandle();
        #else
            return 0;
        #endif
    }
    %End

    void SetHandle(long handle);
    %Docstring
        SetHandle(handle)
        
        MSW-only method to set the windows handle for the bitmap.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxBitmap_SetHandle(sipCpp, handle);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxBitmap_SetHandle(wxBitmap* self, long handle)
    {
        #ifdef __WXMSW__
            self->SetHandle((WXHANDLE)handle);
        #endif
    }
    %End

    void SetSize(const wxSize& size);
    %Docstring
        SetSize(size)
        
        Set the bitmap size (does not alter the existing native bitmap data or
        image size).
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxBitmap_SetSize(sipCpp, size);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxBitmap_SetSize(wxBitmap* self, const wxSize* size)
    {
        self->SetWidth(size->x);
        self->SetHeight(size->y);
    }
    %End

    void CopyFromBuffer(wxPyBuffer* data,  wxBitmapBufferFormat format=wxBitmapBufferFormat_RGB,  int stride=-1);
    %Docstring
        CopyFromBuffer(data, format=BitmapBufferFormat_RGB, stride=-1)
        
        Copy data from a buffer object to replace the bitmap pixel data.
        Default format is plain RGB, but other formats are now supported as
        well.  The following symbols are used to specify the format of the
        bytes in the buffer:
        
            =============================  ================================
            wx.BitmapBufferFormat_RGB      A simple sequence of RGB bytes
            wx.BitmapBufferFormat_RGBA     A simple sequence of RGBA bytes
            wx.BitmapBufferFormat_ARGB32   A sequence of 32-bit values in
        native endian order, with alpha in the upper 8 bits, followed by red,
        green, and blue.
            wx.BitmapBufferFormat_RGB32    Same as above but the alpha byte is
        ignored.
            =============================  ================================
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxBitmap_CopyFromBuffer(sipCpp, data, format, stride);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxBitmap_CopyFromBuffer(wxBitmap* self, wxPyBuffer* data, wxBitmapBufferFormat format, int stride)
    {
        wxPyCopyBitmapFromBuffer(self, (byte*)data->m_ptr, data->m_len, format, stride);
    }
    %End

    void CopyToBuffer(wxPyBuffer* data,  wxBitmapBufferFormat format=wxBitmapBufferFormat_RGB,  int stride=-1);
    %Docstring
        CopyToBuffer(data, format=BitmapBufferFormat_RGB, stride=-1)
        
        Copy pixel data to a buffer object.  See :meth:`CopyFromBuffer` for
        buffer
        format details.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxBitmap_CopyToBuffer(sipCpp, data, format, stride);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    void _wxBitmap_CopyToBuffer(wxBitmap* self, wxPyBuffer* data, wxBitmapBufferFormat format, int stride)
    {
        wxPyCopyBitmapToBuffer(self, (byte*)data->m_ptr, data->m_len, format, stride);
    }
    %End

    static wxBitmap* FromBufferAndAlpha(int width,  int height,  wxPyBuffer* data,  wxPyBuffer* alpha)   /Factory/;
    %Docstring
        FromBufferAndAlpha(width, height, data, alpha) -> Bitmap
        
        Creates a :class:`wx.Bitmap` from in-memory data.  The data and alpha
        parameters must be a Python object that implements the buffer
        interface, such as a string, bytearray, etc.  The data object
        is expected to contain a series of RGB bytes and be at least
        ``(width ∗ height ∗ 3)`` bytes long, while the alpha object is
        expected
        to be ``(width ∗ height)`` bytes long and represents the image's alpha
        channel.  On Windows and Mac the RGB values will be
        'premultiplied' by the alpha values.  (The other platforms do
        the multiplication themselves.)
        
        Unlike :func:`wx.ImageFromBuffer` the bitmap created with this
        function
        does not share the memory block with the buffer object.  This is
        because the native pixel buffer format varies on different
        platforms, and so instead an efficient as possible copy of the
        data is made from the buffer object to the bitmap's native pixel
        buffer.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_FromBufferAndAlpha(width, height, data, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxBitmap* _wxBitmap_FromBufferAndAlpha(int width, int height, wxPyBuffer* data, wxPyBuffer* alpha)
    {
        if (!data->checkSize(width*height*3) || !alpha->checkSize(width*height))
            return NULL;
        
        byte* ddata = (byte*)data->m_ptr;
        byte* adata = (byte*)alpha->m_ptr;
        wxBitmap* bmp = new wxBitmap(width, height, 32);
        
        wxAlphaPixelData pixData(*bmp, wxPoint(0,0), wxSize(width,height));
        if (! pixData) {
            wxPyErr_SetString(PyExc_RuntimeError, "Failed to gain raw access to bitmap data.");
            return NULL;
        }
        
        wxAlphaPixelData::Iterator p(pixData);
        for (int y=0; y<height; y++) {
            wxAlphaPixelData::Iterator rowStart = p;
            for (int x=0; x<width; x++) {
                byte a = *(adata++);
                p.Red()   = wxPy_premultiply(*(ddata++), a);
                p.Green() = wxPy_premultiply(*(ddata++), a);
                p.Blue()  = wxPy_premultiply(*(ddata++), a);
                p.Alpha() = a;
                ++p;
            }
            p = rowStart;
            p.OffsetY(pixData, 1);
        }
        return bmp;
    }
    %End

    static wxBitmap* FromBuffer(int width,  int height,  wxPyBuffer* data)   /Factory/;
    %Docstring
        FromBuffer(width, height, data) -> Bitmap
        
        Creates a :class:`wx.Bitmap` from in-memory data.  The data parameter
        must be a Python object that implements the buffer interface, such
        as a string, bytearray, etc.  The data object is expected to contain
        a series of RGB bytes and be at least ``(width ∗ height ∗ 3)`` bytes
        long.
        
        Unlike :func:`wx.ImageFromBuffer` the bitmap created with this
        function
        does not share the memory block with the buffer object.  This is
        because the native pixel buffer format varies on different
        platforms, and so instead an efficient as possible copy of the
        data is made from the buffer object to the bitmap's native pixel
        buffer.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_FromBuffer(width, height, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxBitmap* _wxBitmap_FromBuffer(int width, int height, wxPyBuffer* data)
    {
        wxBitmap* bmp = new wxBitmap(width, height, 24);
        wxPyCopyBitmapFromBuffer(bmp, (byte*)data->m_ptr, data->m_len, wxBitmapBufferFormat_RGB);
        wxPyThreadBlocker blocker;
        if (PyErr_Occurred()) {
            delete bmp;
            bmp = NULL;
        }
        return bmp;
    }
    %End

    static wxBitmap* FromBufferRGBA(int width,  int height,  wxPyBuffer* data)   /Factory/;
    %Docstring
        FromBufferRGBA(width, height, data) -> Bitmap
        
        Creates a :class:`wx.Bitmap` from in-memory data.  The data parameter
        must be a Python object that implements the buffer interface, such
        as a string, bytearray, etc.  The data object is expected to contain
        a series of RGBA bytes and be at least ``(width ∗ height ∗ 4)`` bytes
        long.
        On Windows and Mac the RGB values will be 'premultiplied' by the
        alpha values.  (The other platforms do the multiplication themselves.)
        
        Unlike :func:`wx.ImageFromBuffer` the bitmap created with this
        function
        does not share the memory block with the buffer object.  This is
        because the native pixel buffer format varies on different
        platforms, and so instead an efficient as possible copy of the
        data is made from the buffer object to the bitmap's native pixel
        buffer.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_FromBufferRGBA(width, height, data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxBitmap* _wxBitmap_FromBufferRGBA(int width, int height, wxPyBuffer* data)
    {
        wxBitmap* bmp = new wxBitmap(width, height, 32);
        wxPyCopyBitmapFromBuffer(bmp, (byte*)data->m_ptr, data->m_len, wxBitmapBufferFormat_RGBA);
        wxPyThreadBlocker blocker;
        if (PyErr_Occurred()) {
            delete bmp;
            bmp = NULL;
        }
        return bmp;
    }
    %End

    static wxBitmap* FromRGBA(int width,  int height,  byte red=0,  byte green=0,  byte blue=0,  byte alpha=0)   /Factory/;
    %Docstring
        FromRGBA(width, height, red=0, green=0, blue=0, alpha=0) -> Bitmap
        
        Creates a new empty 32-bit :class:`wx.Bitmap` where every pixel has
        been
        initialized with the given RGBA values.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_FromRGBA(width, height, red, green, blue, alpha);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxBitmap* _wxBitmap_FromRGBA(int width, int height, byte red, byte green, byte blue, byte alpha)
    {
        if ( !(width > 0 && height > 0) ) {
            wxPyErr_SetString(PyExc_ValueError, "Width and height must be greater than zero");
            return NULL;
        }
        
        wxBitmap* bmp = new wxBitmap(width, height, 32);
        wxAlphaPixelData pixData(*bmp, wxPoint(0,0), wxSize(width,height));
        if (! pixData) {
            wxPyErr_SetString(PyExc_RuntimeError, "Failed to gain raw access to bitmap data.");
            return NULL;
        }
        
        wxAlphaPixelData::Iterator p(pixData);
        for (int y=0; y<height; y++) {
            wxAlphaPixelData::Iterator rowStart = p;
            for (int x=0; x<width; x++) {
                p.Red()   = wxPy_premultiply(red, alpha);
                p.Green() = wxPy_premultiply(green, alpha);
                p.Blue()  = wxPy_premultiply(blue, alpha);
                p.Alpha() = alpha;
                ++p;
            }
            p = rowStart;
            p.OffsetY(pixData, 1);
        }
        return bmp;
    }
    %End

    static wxBitmap* FromPNGData(wxPyBuffer* data)   /Factory/;
    %Docstring
        FromPNGData(data) -> Bitmap
        
        Like :meth:`NewFromPNGData`, but with a simpler API accepting a Python
        buffer-compatible object.
    %End
    %MethodCode
        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxBitmap_FromPNGData(data);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
    %End
    %TypeCode
    wxBitmap* _wxBitmap_FromPNGData(wxPyBuffer* data)
    {
        wxBitmap bmp = wxBitmap::NewFromPNGData(data->m_ptr, data->m_len);
        return new wxBitmap(bmp);
    }
    %End

    public:


    %Property(name=Depth, get=GetDepth, set=SetDepth)
    %Property(name=Handle, get=GetHandle, set=SetHandle)
    %Property(name=Height, get=GetHeight, set=SetHeight)
    %Property(name=Mask, get=GetMask, set=SetMask)
    %Property(name=Palette, get=GetPalette, set=SetPalette)
    %Property(name=Size, get=GetSize, set=SetSize)
    %Property(name=Width, get=GetWidth, set=SetWidth)
};  // end of class wxBitmap


class wxMask : wxObject
{
    %Docstring
        Mask()
        Mask(bitmap, index)
        Mask(bitmap)
        Mask(bitmap, colour)
        
        This class encapsulates a monochrome mask bitmap, where the masked
        area is black and the unmasked area is white.
    %End
    %TypeHeaderCode
        #include <wx/bitmap.h>
    %End

public:
    wxMask();
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxMask(
        const wxBitmap & bitmap,
        int index
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxMask(
        const wxBitmap & bitmap
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    wxMask(
        const wxBitmap & bitmap,
        const wxColour & colour
    );
    %PreMethodCode
        if (!wxPyCheckForApp()) return NULL;
    %End

    virtual
    ~wxMask();

    wxBitmap GetBitmap() const;
    %Docstring
        GetBitmap() -> Bitmap
        
        Returns the mask as a monochrome bitmap.
    %End

    public:


    %Property(name=Bitmap, get=GetBitmap)
};  // end of class wxMask


wxBitmap wxNullBitmap;

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :meth:`wx.Bitmap.FromBuffer` or :meth:`wx.Bitmap.FromBufferAndAlpha` instead.")
def BitmapFromBuffer(width, height, dataBuffer, alphaBuffer=None):
    """
    A compatibility wrapper for :meth:`wx.Bitmap.FromBuffer` and :meth:`wx.Bitmap.FromBufferAndAlpha`
    """
    if alphaBuffer is not None:
        return Bitmap.FromBufferAndAlpha(width, height, dataBuffer, alphaBuffer)
    else:
        return Bitmap.FromBuffer(width, height, dataBuffer)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :meth:`wx.Bitmap.FromBufferRGBA` instead.")
def BitmapFromBufferRGBA(width, height, dataBuffer):
    """
    A compatibility wrapper for :meth:`wx.Bitmap.FromBufferRGBA`
    """
    return Bitmap.FromBufferRGBA(width, height, dataBuffer)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :meth:`wx.Bitmap.FromRGBA` instead.")
def EmptyBitmapRGBA(width, height, red=0, green=0, blue=0, alpha=0):
    """
    A compatibility wrapper for :meth:`wx.Bitmap.FromRGBA`
    """
    return Bitmap.FromRGBA(width, height, red, green, blue, alpha)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`wx.Bitmap` instead")
def EmptyBitmap(width, height, depth=BITMAP_SCREEN_DEPTH):
    """
    A compatibility wrapper for the wx.Bitmap(width, height, depth) constructor
    """
    return Bitmap(width, height, depth)

%End

%Extract(id=pycode_core)
@wx.deprecatedMsg("Use :class:`wx.Bitmap` instead")
def BitmapFromImage(image):
    """
    A compatibility wrapper for the wx.Bitmap(wx.Image) constructor
    """
    return Bitmap(image)

%End


//---------------------------------------------------------------------------

