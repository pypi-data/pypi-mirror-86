/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.24
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/listctrl.h>

        #include <wx/event.h>
        #include <wx/listctrl.h>
        #include <wx/gdicmn.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxListEvent : public  ::wxListEvent
{
public:
    sipwxListEvent( ::wxEventType,int);
    sipwxListEvent(const  ::wxListEvent&);
    virtual ~sipwxListEvent();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::wxEvent* Clone() const SIP_OVERRIDE;
     ::wxEventCategory GetEventCategory() const SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxListEvent(const sipwxListEvent &);
    sipwxListEvent &operator = (const sipwxListEvent &);

    char sipPyMethods[2];
};

sipwxListEvent::sipwxListEvent( ::wxEventType commandType,int id):  ::wxListEvent(commandType,id), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxListEvent::sipwxListEvent(const  ::wxListEvent& a0):  ::wxListEvent(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxListEvent::~sipwxListEvent()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

 ::wxEvent* sipwxListEvent::Clone() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,SIP_NULLPTR,sipName_Clone);

    if (!sipMeth)
        return  ::wxListEvent::Clone();

    extern  ::wxEvent* sipVH__core_98(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_98(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxEventCategory sipwxListEvent::GetEventCategory() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,SIP_NULLPTR,sipName_GetEventCategory);

    if (!sipMeth)
        return  ::wxListEvent::GetEventCategory();

    extern  ::wxEventCategory sipVH__core_99(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_99(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_wxListEvent_GetCacheFrom, "GetCacheFrom() -> long\n"
"\n"
"For EVT_LIST_CACHE_HINT event only: return the first item which the\n"
"list control advises us to cache.");

extern "C" {static PyObject *meth_wxListEvent_GetCacheFrom(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetCacheFrom(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCacheFrom();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetCacheFrom, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetCacheTo, "GetCacheTo() -> long\n"
"\n"
"For EVT_LIST_CACHE_HINT event only: return the last item (inclusive)\n"
"which the list control advises us to cache.");

extern "C" {static PyObject *meth_wxListEvent_GetCacheTo(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetCacheTo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCacheTo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetCacheTo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetColumn, "GetColumn() -> int\n"
"\n"
"The column position: it is only used with COL events.");

extern "C" {static PyObject *meth_wxListEvent_GetColumn(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetData, "GetData() -> UIntPtr\n"
"\n"
"The data.");

extern "C" {static PyObject *meth_wxListEvent_GetData(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxUIntPtr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxUIntPtr(sipCpp->GetData());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxUIntPtr,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetData, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetImage, "GetImage() -> int\n"
"\n"
"The image.");

extern "C" {static PyObject *meth_wxListEvent_GetImage(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetImage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetImage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetImage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetIndex, "GetIndex() -> long\n"
"\n"
"The item index.");

extern "C" {static PyObject *meth_wxListEvent_GetIndex(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetIndex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndex();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetIndex, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetItem, "GetItem() -> ListItem\n"
"\n"
"An item object, used by some events.");

extern "C" {static PyObject *meth_wxListEvent_GetItem(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetItem(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxListItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxListItem(sipCpp->GetItem());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxListItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetItem, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetKeyCode, "GetKeyCode() -> int\n"
"\n"
"Key code if the event is a keypress event.");

extern "C" {static PyObject *meth_wxListEvent_GetKeyCode(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetKeyCode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetKeyCode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetKeyCode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetLabel, "GetLabel() -> String\n"
"\n"
"The (new) item label for EVT_LIST_END_LABEL_EDIT event.");

extern "C" {static PyObject *meth_wxListEvent_GetLabel(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetLabel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabel());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetLabel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetMask, "GetMask() -> long\n"
"\n"
"The mask.");

extern "C" {static PyObject *meth_wxListEvent_GetMask(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetMask(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMask();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetMask, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetPoint, "GetPoint() -> Point\n"
"\n"
"The position of the mouse pointer if the event is a drag event.");

extern "C" {static PyObject *meth_wxListEvent_GetPoint(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPoint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_GetText, "GetText() -> String\n"
"\n"
"The text.");

extern "C" {static PyObject *meth_wxListEvent_GetText(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetText, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_IsEditCancelled, "IsEditCancelled() -> bool\n"
"\n"
"This method only makes sense for EVT_LIST_END_LABEL_EDIT message and\n"
"returns true if it the label editing has been cancelled by the user\n"
"(GetLabel() returns an empty string in this case but it doesn't allow\n"
"the application to distinguish between really cancelling the edit and\n"
"the admittedly rare case when the user wants to rename it to an empty\n"
"string).");

extern "C" {static PyObject *meth_wxListEvent_IsEditCancelled(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_IsEditCancelled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEditCancelled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_IsEditCancelled, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetKeyCode, "SetKeyCode(code)");

extern "C" {static PyObject *meth_wxListEvent_SetKeyCode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetKeyCode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int code;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_code,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxListEvent, &sipCpp, &code))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetKeyCode(code);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetKeyCode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetIndex, "SetIndex(index)");

extern "C" {static PyObject *meth_wxListEvent_SetIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long index;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &index))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndex(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetIndex, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetColumn, "SetColumn(col)");

extern "C" {static PyObject *meth_wxListEvent_SetColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int col;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxListEvent, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColumn(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetColumn, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetPoint, "SetPoint(point)");

extern "C" {static PyObject *meth_wxListEvent_SetPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPoint* point;
        int pointState = 0;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_point,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxListEvent, &sipCpp, sipType_wxPoint, &point, &pointState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPoint(*point);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(point),sipType_wxPoint,pointState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetPoint, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetItem, "SetItem(item)");

extern "C" {static PyObject *meth_wxListEvent_SetItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxListItem* item;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxListEvent, &sipCpp, sipType_wxListItem, &item))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetItem(*item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetItem, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetCacheFrom, "SetCacheFrom(cacheFrom)");

extern "C" {static PyObject *meth_wxListEvent_SetCacheFrom(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetCacheFrom(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long cacheFrom;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cacheFrom,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &cacheFrom))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCacheFrom(cacheFrom);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetCacheFrom, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_SetCacheTo, "SetCacheTo(cacheTo)");

extern "C" {static PyObject *meth_wxListEvent_SetCacheTo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetCacheTo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        long cacheTo;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cacheTo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &cacheTo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCacheTo(cacheTo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetCacheTo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxListEvent_Clone, "Clone(self) -> Event");

extern "C" {static PyObject *meth_wxListEvent_Clone(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_Clone(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxEvent*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxListEvent::Clone() : sipCpp->Clone());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxEvent,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_Clone, doc_wxListEvent_Clone);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxListEvent(void *, const sipTypeDef *);}
static void *cast_wxListEvent(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxListEvent *sipCpp = reinterpret_cast< ::wxListEvent *>(sipCppV);

    if (targetType == sipType_wxNotifyEvent)
        return static_cast< ::wxNotifyEvent *>(sipCpp);

    if (targetType == sipType_wxCommandEvent)
        return static_cast< ::wxCommandEvent *>(sipCpp);

    if (targetType == sipType_wxEvent)
        return static_cast< ::wxEvent *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxListEvent(void *, int);}
static void release_wxListEvent(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxListEvent *>(sipCppV);
    else
        delete reinterpret_cast< ::wxListEvent *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxListEvent(sipSimpleWrapper *);}
static void dealloc_wxListEvent(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxListEvent *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxListEvent(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxListEvent(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxListEvent(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxListEvent *sipCpp = SIP_NULLPTR;

    {
         ::wxEventType commandType = wxEVT_NULL;
        int id = 0;

        static const char *sipKwdList[] = {
            sipName_commandType,
            sipName_id,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|ii", &commandType, &id))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxListEvent(commandType,id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::wxListEvent* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_wxListEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxListEvent(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxListEvent[] = {{369, 255, 1}};


static PyMethodDef methods_wxListEvent[] = {
    {SIP_MLNAME_CAST(sipName_Clone), meth_wxListEvent_Clone, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_Clone)},
    {SIP_MLNAME_CAST(sipName_GetCacheFrom), meth_wxListEvent_GetCacheFrom, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetCacheFrom)},
    {SIP_MLNAME_CAST(sipName_GetCacheTo), meth_wxListEvent_GetCacheTo, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetCacheTo)},
    {SIP_MLNAME_CAST(sipName_GetColumn), meth_wxListEvent_GetColumn, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetColumn)},
    {SIP_MLNAME_CAST(sipName_GetData), meth_wxListEvent_GetData, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetData)},
    {SIP_MLNAME_CAST(sipName_GetImage), meth_wxListEvent_GetImage, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetImage)},
    {SIP_MLNAME_CAST(sipName_GetIndex), meth_wxListEvent_GetIndex, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetIndex)},
    {SIP_MLNAME_CAST(sipName_GetItem), meth_wxListEvent_GetItem, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetItem)},
    {SIP_MLNAME_CAST(sipName_GetKeyCode), meth_wxListEvent_GetKeyCode, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetKeyCode)},
    {SIP_MLNAME_CAST(sipName_GetLabel), meth_wxListEvent_GetLabel, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetLabel)},
    {SIP_MLNAME_CAST(sipName_GetMask), meth_wxListEvent_GetMask, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetMask)},
    {SIP_MLNAME_CAST(sipName_GetPoint), meth_wxListEvent_GetPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetPoint)},
    {SIP_MLNAME_CAST(sipName_GetText), meth_wxListEvent_GetText, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetText)},
    {SIP_MLNAME_CAST(sipName_IsEditCancelled), meth_wxListEvent_IsEditCancelled, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_IsEditCancelled)},
    {SIP_MLNAME_CAST(sipName_SetCacheFrom), SIP_MLMETH_CAST(meth_wxListEvent_SetCacheFrom), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetCacheFrom)},
    {SIP_MLNAME_CAST(sipName_SetCacheTo), SIP_MLMETH_CAST(meth_wxListEvent_SetCacheTo), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetCacheTo)},
    {SIP_MLNAME_CAST(sipName_SetColumn), SIP_MLMETH_CAST(meth_wxListEvent_SetColumn), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetColumn)},
    {SIP_MLNAME_CAST(sipName_SetIndex), SIP_MLMETH_CAST(meth_wxListEvent_SetIndex), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetIndex)},
    {SIP_MLNAME_CAST(sipName_SetItem), SIP_MLMETH_CAST(meth_wxListEvent_SetItem), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetItem)},
    {SIP_MLNAME_CAST(sipName_SetKeyCode), SIP_MLMETH_CAST(meth_wxListEvent_SetKeyCode), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetKeyCode)},
    {SIP_MLNAME_CAST(sipName_SetPoint), SIP_MLMETH_CAST(meth_wxListEvent_SetPoint), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetPoint)}
};

sipVariableDef variables_wxListEvent[] = {
    {PropertyVariable, sipName_Text, &methods_wxListEvent[12], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Point, &methods_wxListEvent[11], &methods_wxListEvent[20], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Mask, &methods_wxListEvent[10], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Label, &methods_wxListEvent[9], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_KeyCode, &methods_wxListEvent[8], &methods_wxListEvent[19], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Item, &methods_wxListEvent[7], &methods_wxListEvent[18], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Index, &methods_wxListEvent[6], &methods_wxListEvent[17], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Image, &methods_wxListEvent[5], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Data, &methods_wxListEvent[4], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Column, &methods_wxListEvent[3], &methods_wxListEvent[16], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CacheTo, &methods_wxListEvent[2], &methods_wxListEvent[15], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_CacheFrom, &methods_wxListEvent[1], &methods_wxListEvent[14], SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxListEvent, "ListEvent(commandType=wxEVT_NULL, id=0)\n"
"\n"
"A list event holds information about events associated with wxListCtrl\n"
"objects.");


sipClassTypeDef sipTypeDef__core_wxListEvent = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxListEvent,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ListEvent,
        {0, 0, 1},
        21, methods_wxListEvent,
        0, SIP_NULLPTR,
        12, variables_wxListEvent,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxListEvent,
    -1,
    -1,
    supers_wxListEvent,
    SIP_NULLPTR,
    init_type_wxListEvent,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_wxListEvent,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_wxListEvent,
    cast_wxListEvent,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
