/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.24
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/app.h>

        #include <wx/apptrait.h>
        #include <wx/evtloop.h>
        #include <wx/object.h>
        #include <wx/event.h>
        #include <wx/eventfilter.h>
        #include <wx/event.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxAppConsole : public  ::wxAppConsole
{
public:
    sipwxAppConsole();
    virtual ~sipwxAppConsole();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int OnRun() SIP_OVERRIDE;
    bool OnInit() SIP_OVERRIDE;
    int OnExit() SIP_OVERRIDE;
    void OnEventLoopExit( ::wxEventLoopBase*) SIP_OVERRIDE;
    void OnEventLoopEnter( ::wxEventLoopBase*) SIP_OVERRIDE;
    void ProcessPendingEvents() SIP_OVERRIDE;
    bool UsesEventLoop() const SIP_OVERRIDE;
    void ExitMainLoop() SIP_OVERRIDE;
    int MainLoop() SIP_OVERRIDE;
    int FilterEvent( ::wxEvent&) SIP_OVERRIDE;
    bool ProcessEvent( ::wxEvent&) SIP_OVERRIDE;
    bool TryBefore( ::wxEvent&) SIP_OVERRIDE;
    bool TryAfter( ::wxEvent&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxAppConsole(const sipwxAppConsole &);
    sipwxAppConsole &operator = (const sipwxAppConsole &);

    char sipPyMethods[13];
};

sipwxAppConsole::sipwxAppConsole():  ::wxAppConsole(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxAppConsole::~sipwxAppConsole()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

int sipwxAppConsole::OnRun()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_OnRun);

    if (!sipMeth)
        return  ::wxAppConsole::OnRun();

    extern int sipVH__core_107(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_107(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxAppConsole::OnInit()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_OnInit);

    if (!sipMeth)
        return  ::wxAppConsole::OnInit();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxAppConsole::OnExit()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,SIP_NULLPTR,sipName_OnExit);

    if (!sipMeth)
        return  ::wxAppConsole::OnExit();

    extern int sipVH__core_107(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_107(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxAppConsole::OnEventLoopExit( ::wxEventLoopBase*loop)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,SIP_NULLPTR,sipName_OnEventLoopExit);

    if (!sipMeth)
    {
         ::wxAppConsole::OnEventLoopExit(loop);
        return;
    }

    extern void sipVH__core_117(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEventLoopBase*);

    sipVH__core_117(sipGILState, 0, sipPySelf, sipMeth, loop);
}

void sipwxAppConsole::OnEventLoopEnter( ::wxEventLoopBase*loop)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,SIP_NULLPTR,sipName_OnEventLoopEnter);

    if (!sipMeth)
    {
         ::wxAppConsole::OnEventLoopEnter(loop);
        return;
    }

    extern void sipVH__core_117(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEventLoopBase*);

    sipVH__core_117(sipGILState, 0, sipPySelf, sipMeth, loop);
}

void sipwxAppConsole::ProcessPendingEvents()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,SIP_NULLPTR,sipName_ProcessPendingEvents);

    if (!sipMeth)
    {
         ::wxAppConsole::ProcessPendingEvents();
        return;
    }

    extern void sipVH__core_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_53(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxAppConsole::UsesEventLoop() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,SIP_NULLPTR,sipName_UsesEventLoop);

    if (!sipMeth)
        return  ::wxAppConsole::UsesEventLoop();

    extern bool sipVH__core_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_6(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxAppConsole::ExitMainLoop()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,SIP_NULLPTR,sipName_ExitMainLoop);

    if (!sipMeth)
    {
         ::wxAppConsole::ExitMainLoop();
        return;
    }

    extern void sipVH__core_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_53(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxAppConsole::MainLoop()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,SIP_NULLPTR,sipName_MainLoop);

    if (!sipMeth)
        return  ::wxAppConsole::MainLoop();

    extern int sipVH__core_107(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_107(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxAppConsole::FilterEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,SIP_NULLPTR,sipName_FilterEvent);

    if (!sipMeth)
        return  ::wxAppConsole::FilterEvent(event);

    extern int sipVH__core_106(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_106(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxAppConsole::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,SIP_NULLPTR,sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxAppConsole::ProcessEvent(event);

    extern bool sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxAppConsole::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[11],sipPySelf,SIP_NULLPTR,sipName_TryBefore);

    if (!sipMeth)
        return  ::wxAppConsole::TryBefore(event);

    extern bool sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxAppConsole::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[12],sipPySelf,SIP_NULLPTR,sipName_TryAfter);

    if (!sipMeth)
        return  ::wxAppConsole::TryAfter(event);

    extern bool sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxAppConsole::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxEvtHandler::TryBefore(event) : TryBefore(event));
}

bool sipwxAppConsole::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxEvtHandler::TryAfter(event) : TryAfter(event));
}


PyDoc_STRVAR(doc_wxAppConsole_TryBefore, "TryBefore(event) -> bool\n"
"\n"
"Method called by ProcessEvent() before examining this object event\n"
"tables.");

extern "C" {static PyObject *meth_wxAppConsole_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_TryBefore, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_TryAfter, "TryAfter(event) -> bool\n"
"\n"
"Method called by ProcessEvent() as last resort.");

extern "C" {static PyObject *meth_wxAppConsole_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_TryAfter, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_MainLoop, "MainLoop() -> int\n"
"\n"
"Called by wxWidgets on creation of the application.");

extern "C" {static PyObject *meth_wxAppConsole_MainLoop(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_MainLoop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::MainLoop() : sipCpp->MainLoop());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_MainLoop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_ExitMainLoop, "ExitMainLoop()\n"
"\n"
"Call this to explicitly exit the main message (event) loop.");

extern "C" {static PyObject *meth_wxAppConsole_ExitMainLoop(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_ExitMainLoop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxAppConsole::ExitMainLoop() : sipCpp->ExitMainLoop());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_ExitMainLoop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_FilterEvent, "FilterEvent(event) -> int\n"
"\n"
"Overridden wxEventFilter method.");

extern "C" {static PyObject *meth_wxAppConsole_FilterEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_FilterEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxEvent, &event))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::FilterEvent(*event) : sipCpp->FilterEvent(*event));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_FilterEvent, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetMainLoop, "GetMainLoop() -> EventLoopBase\n"
"\n"
"Returns the main event loop instance, i.e. the event loop which is\n"
"started by OnRun() and which dispatches all events sent from the\n"
"native toolkit to the application (except when new event loops are\n"
"temporarily set-up).");

extern "C" {static PyObject *meth_wxAppConsole_GetMainLoop(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetMainLoop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxEventLoopBase*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMainLoop();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxEventLoopBase,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetMainLoop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_UsesEventLoop, "UsesEventLoop() -> bool\n"
"\n"
"Returns true if the application is using an event loop.");

extern "C" {static PyObject *meth_wxAppConsole_UsesEventLoop(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_UsesEventLoop(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::UsesEventLoop() : sipCpp->UsesEventLoop());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_UsesEventLoop, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_ProcessPendingEvents, "ProcessPendingEvents()\n"
"\n"
"Process all pending events; it is necessary to call this function to\n"
"process events posted with wxEvtHandler::QueueEvent or\n"
"wxEvtHandler::AddPendingEvent.");

extern "C" {static PyObject *meth_wxAppConsole_ProcessPendingEvents(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_ProcessPendingEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxAppConsole::ProcessPendingEvents() : sipCpp->ProcessPendingEvents());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_ProcessPendingEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_DeletePendingEvents, "DeletePendingEvents()\n"
"\n"
"Deletes the pending events of all wxEvtHandlers of this application.");

extern "C" {static PyObject *meth_wxAppConsole_DeletePendingEvents(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_DeletePendingEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DeletePendingEvents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_DeletePendingEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_HasPendingEvents, "HasPendingEvents() -> bool\n"
"\n"
"Returns true if there are pending events on the internal pending event\n"
"list.");

extern "C" {static PyObject *meth_wxAppConsole_HasPendingEvents(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_HasPendingEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->HasPendingEvents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_HasPendingEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SuspendProcessingOfPendingEvents, "SuspendProcessingOfPendingEvents()\n"
"\n"
"Temporary suspends processing of the pending events.");

extern "C" {static PyObject *meth_wxAppConsole_SuspendProcessingOfPendingEvents(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SuspendProcessingOfPendingEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SuspendProcessingOfPendingEvents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SuspendProcessingOfPendingEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_ResumeProcessingOfPendingEvents, "ResumeProcessingOfPendingEvents()\n"
"\n"
"Resume processing of the pending events previously stopped because of\n"
"a call to SuspendProcessingOfPendingEvents().");

extern "C" {static PyObject *meth_wxAppConsole_ResumeProcessingOfPendingEvents(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_ResumeProcessingOfPendingEvents(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ResumeProcessingOfPendingEvents();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_ResumeProcessingOfPendingEvents, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_ScheduleForDestruction, "ScheduleForDestruction(object)\n"
"\n"
"Delayed objects destruction.");

extern "C" {static PyObject *meth_wxAppConsole_ScheduleForDestruction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_ScheduleForDestruction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxObject* object;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_object,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxObject, &object))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ScheduleForDestruction(object);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_ScheduleForDestruction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_IsScheduledForDestruction, "IsScheduledForDestruction(object) -> bool\n"
"\n"
"Check if the object had been scheduled for destruction with\n"
"ScheduleForDestruction().");

extern "C" {static PyObject *meth_wxAppConsole_IsScheduledForDestruction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_IsScheduledForDestruction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxObject* object;
        const  ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_object,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxObject, &object))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsScheduledForDestruction(object);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_IsScheduledForDestruction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_OnEventLoopEnter, "OnEventLoopEnter(loop)\n"
"\n"
"Called by wxEventLoopBase::SetActive(): you can override this function\n"
"and put here the code which needs an active event loop.");

extern "C" {static PyObject *meth_wxAppConsole_OnEventLoopEnter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_OnEventLoopEnter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEventLoopBase* loop;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_loop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxEventLoopBase, &loop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxAppConsole::OnEventLoopEnter(loop) : sipCpp->OnEventLoopEnter(loop));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_OnEventLoopEnter, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_OnEventLoopExit, "OnEventLoopExit(loop)\n"
"\n"
"Called by wxEventLoopBase::OnExit() for each event loop which is\n"
"exited.");

extern "C" {static PyObject *meth_wxAppConsole_OnEventLoopExit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_OnEventLoopExit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEventLoopBase* loop;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_loop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxEventLoopBase, &loop))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxAppConsole::OnEventLoopExit(loop) : sipCpp->OnEventLoopExit(loop));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_OnEventLoopExit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_OnExit, "OnExit() -> int\n"
"\n"
"Override this member function for any processing which needs to be\n"
"done as the application is about to exit.");

extern "C" {static PyObject *meth_wxAppConsole_OnExit(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_OnExit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::OnExit() : sipCpp->OnExit());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_OnExit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_OnInit, "OnInit() -> bool\n"
"\n"
"This must be provided by the application, and will usually create the\n"
"application's main window, optionally calling SetTopWindow().");

extern "C" {static PyObject *meth_wxAppConsole_OnInit(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_OnInit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::OnInit() : sipCpp->OnInit());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_OnInit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_OnRun, "OnRun() -> int\n"
"\n"
"This virtual function is where the execution of a program written in\n"
"wxWidgets starts.");

extern "C" {static PyObject *meth_wxAppConsole_OnRun(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_OnRun(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxAppConsole::OnRun() : sipCpp->OnRun());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_OnRun, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetAppDisplayName, "GetAppDisplayName() -> String\n"
"\n"
"Returns the user-readable application name.");

extern "C" {static PyObject *meth_wxAppConsole_GetAppDisplayName(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetAppDisplayName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetAppDisplayName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetAppDisplayName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetAppName, "GetAppName() -> String\n"
"\n"
"Returns the application name.");

extern "C" {static PyObject *meth_wxAppConsole_GetAppName(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetAppName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetAppName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetAppName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetClassName, "GetClassName() -> String\n"
"\n"
"Gets the class name of the application.");

extern "C" {static PyObject *meth_wxAppConsole_GetClassName(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetClassName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetClassName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetClassName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetTraits, "GetTraits() -> AppTraits\n"
"\n"
"Returns a pointer to the wxAppTraits object for the application.");

extern "C" {static PyObject *meth_wxAppConsole_GetTraits(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetTraits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxAppTraits*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTraits();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxAppTraits,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetTraits, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetVendorDisplayName, "GetVendorDisplayName() -> String\n"
"\n"
"Returns the user-readable vendor name.");

extern "C" {static PyObject *meth_wxAppConsole_GetVendorDisplayName(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetVendorDisplayName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetVendorDisplayName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetVendorDisplayName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetVendorName, "GetVendorName() -> String\n"
"\n"
"Returns the application's vendor name.");

extern "C" {static PyObject *meth_wxAppConsole_GetVendorName(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetVendorName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetVendorName());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetVendorName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetAppDisplayName, "SetAppDisplayName(name)\n"
"\n"
"Set the application name to be used in the user-visible places such as\n"
"window titles.");

extern "C" {static PyObject *meth_wxAppConsole_SetAppDisplayName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetAppDisplayName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxString,&name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAppDisplayName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name),sipType_wxString,nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetAppDisplayName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetAppName, "SetAppName(name)\n"
"\n"
"Sets the name of the application.");

extern "C" {static PyObject *meth_wxAppConsole_SetAppName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetAppName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxString,&name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetAppName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name),sipType_wxString,nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetAppName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetClassName, "SetClassName(name)\n"
"\n"
"Sets the class name of the application.");

extern "C" {static PyObject *meth_wxAppConsole_SetClassName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetClassName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxString,&name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClassName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name),sipType_wxString,nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetClassName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetVendorDisplayName, "SetVendorDisplayName(name)\n"
"\n"
"Set the vendor name to be used in the user-visible places.");

extern "C" {static PyObject *meth_wxAppConsole_SetVendorDisplayName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetVendorDisplayName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxString,&name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVendorDisplayName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name),sipType_wxString,nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetVendorDisplayName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetVendorName, "SetVendorName(name)\n"
"\n"
"Sets the name of application's vendor.");

extern "C" {static PyObject *meth_wxAppConsole_SetVendorName(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetVendorName(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* name;
        int nameState = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxAppConsole, &sipCpp, sipType_wxString,&name, &nameState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVendorName(*name);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(name),sipType_wxString,nameState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetVendorName, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_Yield, "Yield(onlyIfNeeded=False) -> bool\n"
"\n"
"Yields control to pending messages in the event loop.");

extern "C" {static PyObject *meth_wxAppConsole_Yield(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_Yield(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool onlyIfNeeded = 0;
         ::wxAppConsole *sipCpp;

        static const char *sipKwdList[] = {
            sipName_onlyIfNeeded,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxAppConsole, &sipCpp, &onlyIfNeeded))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Yield(onlyIfNeeded);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_Yield, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetCLocale, "SetCLocale()\n"
"\n"
"Sets the C locale to the default locale for the current environment.");

extern "C" {static PyObject *meth_wxAppConsole_SetCLocale(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetCLocale(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxAppConsole, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCLocale();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetCLocale, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_SetInstance, "SetInstance(app)\n"
"\n"
"Allows external code to modify global wxTheApp, but you should really\n"
"know what you're doing if you call it.");

extern "C" {static PyObject *meth_wxAppConsole_SetInstance(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_SetInstance(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxAppConsole* app;

        static const char *sipKwdList[] = {
            sipName_app,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J8", sipType_wxAppConsole, &app))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
             ::wxAppConsole::SetInstance(app);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_SetInstance, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_GetInstance, "GetInstance() -> AppConsole\n"
"\n"
"Returns the one and only global application object.");

extern "C" {static PyObject *meth_wxAppConsole_GetInstance(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_GetInstance(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxAppConsole*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxAppConsole::GetInstance();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxAppConsole,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_GetInstance, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxAppConsole_IsMainLoopRunning, "IsMainLoopRunning() -> bool\n"
"\n"
"Returns true if the main event loop is currently running, i.e. if the\n"
"application is inside OnRun().");

extern "C" {static PyObject *meth_wxAppConsole_IsMainLoopRunning(PyObject *, PyObject *);}
static PyObject *meth_wxAppConsole_IsMainLoopRunning(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes =  ::wxAppConsole::IsMainLoopRunning();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_AppConsole, sipName_IsMainLoopRunning, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxAppConsole(void *, const sipTypeDef *);}
static void *cast_wxAppConsole(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxAppConsole *sipCpp = reinterpret_cast< ::wxAppConsole *>(sipCppV);

    if (targetType == sipType_wxEvtHandler)
        return static_cast< ::wxEvtHandler *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    if (targetType == sipType_wxTrackable)
        return static_cast< ::wxTrackable *>(sipCpp);

    if (targetType == sipType_wxEventFilter)
        return static_cast< ::wxEventFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxAppConsole(void *, int);}
static void release_wxAppConsole(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxAppConsole *>(sipCppV);
    else
        delete reinterpret_cast< ::wxAppConsole *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void *array_wxAppConsole(Py_ssize_t);}
static void *array_wxAppConsole(Py_ssize_t sipNrElem)
{
    return new  ::wxAppConsole[sipNrElem];
}


extern "C" {static void dealloc_wxAppConsole(sipSimpleWrapper *);}
static void dealloc_wxAppConsole(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxAppConsole *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxAppConsole(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxAppConsole(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxAppConsole(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxAppConsole *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxAppConsole();
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxAppConsole[] = {{154, 255, 0}, {150, 255, 1}};


static PyMethodDef methods_wxAppConsole[] = {
    {SIP_MLNAME_CAST(sipName_DeletePendingEvents), meth_wxAppConsole_DeletePendingEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_DeletePendingEvents)},
    {SIP_MLNAME_CAST(sipName_ExitMainLoop), meth_wxAppConsole_ExitMainLoop, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_ExitMainLoop)},
    {SIP_MLNAME_CAST(sipName_FilterEvent), SIP_MLMETH_CAST(meth_wxAppConsole_FilterEvent), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_FilterEvent)},
    {SIP_MLNAME_CAST(sipName_GetAppDisplayName), meth_wxAppConsole_GetAppDisplayName, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetAppDisplayName)},
    {SIP_MLNAME_CAST(sipName_GetAppName), meth_wxAppConsole_GetAppName, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetAppName)},
    {SIP_MLNAME_CAST(sipName_GetClassName), meth_wxAppConsole_GetClassName, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetClassName)},
    {SIP_MLNAME_CAST(sipName_GetInstance), meth_wxAppConsole_GetInstance, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetInstance)},
    {SIP_MLNAME_CAST(sipName_GetMainLoop), meth_wxAppConsole_GetMainLoop, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetMainLoop)},
    {SIP_MLNAME_CAST(sipName_GetTraits), meth_wxAppConsole_GetTraits, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetTraits)},
    {SIP_MLNAME_CAST(sipName_GetVendorDisplayName), meth_wxAppConsole_GetVendorDisplayName, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetVendorDisplayName)},
    {SIP_MLNAME_CAST(sipName_GetVendorName), meth_wxAppConsole_GetVendorName, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_GetVendorName)},
    {SIP_MLNAME_CAST(sipName_HasPendingEvents), meth_wxAppConsole_HasPendingEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_HasPendingEvents)},
    {SIP_MLNAME_CAST(sipName_IsMainLoopRunning), meth_wxAppConsole_IsMainLoopRunning, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_IsMainLoopRunning)},
    {SIP_MLNAME_CAST(sipName_IsScheduledForDestruction), SIP_MLMETH_CAST(meth_wxAppConsole_IsScheduledForDestruction), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_IsScheduledForDestruction)},
    {SIP_MLNAME_CAST(sipName_MainLoop), meth_wxAppConsole_MainLoop, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_MainLoop)},
    {SIP_MLNAME_CAST(sipName_OnEventLoopEnter), SIP_MLMETH_CAST(meth_wxAppConsole_OnEventLoopEnter), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_OnEventLoopEnter)},
    {SIP_MLNAME_CAST(sipName_OnEventLoopExit), SIP_MLMETH_CAST(meth_wxAppConsole_OnEventLoopExit), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_OnEventLoopExit)},
    {SIP_MLNAME_CAST(sipName_OnExit), meth_wxAppConsole_OnExit, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_OnExit)},
    {SIP_MLNAME_CAST(sipName_OnInit), meth_wxAppConsole_OnInit, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_OnInit)},
    {SIP_MLNAME_CAST(sipName_OnRun), meth_wxAppConsole_OnRun, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_OnRun)},
    {SIP_MLNAME_CAST(sipName_ProcessPendingEvents), meth_wxAppConsole_ProcessPendingEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_ProcessPendingEvents)},
    {SIP_MLNAME_CAST(sipName_ResumeProcessingOfPendingEvents), meth_wxAppConsole_ResumeProcessingOfPendingEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_ResumeProcessingOfPendingEvents)},
    {SIP_MLNAME_CAST(sipName_ScheduleForDestruction), SIP_MLMETH_CAST(meth_wxAppConsole_ScheduleForDestruction), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_ScheduleForDestruction)},
    {SIP_MLNAME_CAST(sipName_SetAppDisplayName), SIP_MLMETH_CAST(meth_wxAppConsole_SetAppDisplayName), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetAppDisplayName)},
    {SIP_MLNAME_CAST(sipName_SetAppName), SIP_MLMETH_CAST(meth_wxAppConsole_SetAppName), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetAppName)},
    {SIP_MLNAME_CAST(sipName_SetCLocale), meth_wxAppConsole_SetCLocale, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_SetCLocale)},
    {SIP_MLNAME_CAST(sipName_SetClassName), SIP_MLMETH_CAST(meth_wxAppConsole_SetClassName), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetClassName)},
    {SIP_MLNAME_CAST(sipName_SetInstance), SIP_MLMETH_CAST(meth_wxAppConsole_SetInstance), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetInstance)},
    {SIP_MLNAME_CAST(sipName_SetVendorDisplayName), SIP_MLMETH_CAST(meth_wxAppConsole_SetVendorDisplayName), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetVendorDisplayName)},
    {SIP_MLNAME_CAST(sipName_SetVendorName), SIP_MLMETH_CAST(meth_wxAppConsole_SetVendorName), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_SetVendorName)},
    {SIP_MLNAME_CAST(sipName_SuspendProcessingOfPendingEvents), meth_wxAppConsole_SuspendProcessingOfPendingEvents, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_SuspendProcessingOfPendingEvents)},
    {SIP_MLNAME_CAST(sipName_TryAfter), SIP_MLMETH_CAST(meth_wxAppConsole_TryAfter), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_TryBefore), SIP_MLMETH_CAST(meth_wxAppConsole_TryBefore), METH_VARARGS|METH_KEYWORDS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_UsesEventLoop), meth_wxAppConsole_UsesEventLoop, METH_VARARGS, SIP_MLDOC_CAST(doc_wxAppConsole_UsesEventLoop)},
    {SIP_MLNAME_CAST(sipName_Yield), SIP_MLMETH_CAST(meth_wxAppConsole_Yield), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxAppConsole_Yield)}
};

sipVariableDef variables_wxAppConsole[] = {
    {PropertyVariable, sipName_Traits, &methods_wxAppConsole[8], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_VendorName, &methods_wxAppConsole[10], &methods_wxAppConsole[29], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_VendorDisplayName, &methods_wxAppConsole[9], &methods_wxAppConsole[28], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ClassName, &methods_wxAppConsole[5], &methods_wxAppConsole[26], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AppName, &methods_wxAppConsole[4], &methods_wxAppConsole[24], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_AppDisplayName, &methods_wxAppConsole[3], &methods_wxAppConsole[23], SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxAppConsole, "This class is essential for writing console-only or hybrid apps\n"
"without having to define wxUSE_GUI=0.");


sipClassTypeDef sipTypeDef__core_wxAppConsole = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxAppConsole,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_AppConsole,
        {0, 0, 1},
        35, methods_wxAppConsole,
        0, SIP_NULLPTR,
        6, variables_wxAppConsole,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxAppConsole,
    -1,
    -1,
    supers_wxAppConsole,
    SIP_NULLPTR,
    init_type_wxAppConsole,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_wxAppConsole,
    SIP_NULLPTR,
    array_wxAppConsole,
    SIP_NULLPTR,
    release_wxAppConsole,
    cast_wxAppConsole,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
