/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.24
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/dcsvg.h>

        #include <wx/dcsvg.h>
        #include <wx/palette.h>
        #include <wx/colour.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/gdicmn.h>
        #include <wx/graphics.h>
        #include <wx/bitmap.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/dc.h>
        #include <wx/affinematrix2d.h>
        #include <wx/pen.h>
        #include "arrayholder.h"
        #include <wx/brush.h>
        #include <wx/font.h>
        #include <wx/dc.h>
        #include <wx/region.h>
        
        
        #include <wx/icon.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxSVGFileDC : public  ::wxSVGFileDC
{
public:
    sipwxSVGFileDC(const  ::wxString&,int,int,double,const  ::wxString&);
    ~sipwxSVGFileDC();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxSVGFileDC(const sipwxSVGFileDC &);
    sipwxSVGFileDC &operator = (const sipwxSVGFileDC &);
};

sipwxSVGFileDC::sipwxSVGFileDC(const  ::wxString& filename,int width,int height,double dpi,const  ::wxString& title):  ::wxSVGFileDC(filename,width,height,dpi,title), sipPySelf(SIP_NULLPTR)
{
}

sipwxSVGFileDC::~sipwxSVGFileDC()
{
    sipInstanceDestroyedEx(&sipPySelf);
}


PyDoc_STRVAR(doc_wxSVGFileDC_CrossHair, "CrossHair(x, y)\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_CrossHair(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_CrossHair(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CrossHair(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_CrossHair, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_FloodFill, "FloodFill(x, y, colour, style=FLOOD_SURFACE) -> bool\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_FloodFill(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_FloodFill(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxFloodFillStyle style = wxFLOOD_SURFACE;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_colour,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ1|E", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, sipType_wxColour, &colour, &colourState, sipType_wxFloodFillStyle, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FloodFill(x,y,*colour,style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour),sipType_wxColour,colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_FloodFill, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_GetPixel, "GetPixel(x, y, colour) -> bool\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_GetPixel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_GetPixel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxColour* colour;
        int colourState = 0;
        const  ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ0", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, sipType_wxColour, &colour, &colourState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPixel(x,y,colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(colour,sipType_wxColour,colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_GetPixel, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetPalette, "SetPalette(palette)\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetPalette(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetPalette(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxPalette* palette;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_palette,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxPalette, &palette))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPalette(*palette);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetPalette, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_GetDepth, "GetDepth() -> int\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_GetDepth(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_GetDepth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDepth();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_GetDepth, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetLogicalFunction, "SetLogicalFunction(function)\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetLogicalFunction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetLogicalFunction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxRasterOperationMode function;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_function,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxRasterOperationMode, &function))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLogicalFunction(function);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetLogicalFunction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_GetLogicalFunction, "GetLogicalFunction() -> RasterOperationMode\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_GetLogicalFunction(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_GetLogicalFunction(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
             ::wxRasterOperationMode sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetLogicalFunction();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxRasterOperationMode);
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_GetLogicalFunction, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_StartDoc, "StartDoc(message) -> bool\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_StartDoc(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_StartDoc(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* message;
        int messageState = 0;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_message,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxString,&message, &messageState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StartDoc(*message);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(message),sipType_wxString,messageState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_StartDoc, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_EndDoc, "EndDoc()\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_EndDoc(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_EndDoc(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndDoc();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_EndDoc, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_StartPage, "StartPage()\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_StartPage(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_StartPage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->StartPage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_StartPage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_EndPage, "EndPage()\n"
"\n"
"Function not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_EndPage(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_EndPage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndPage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_EndPage, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_Clear, "Clear()\n"
"\n"
"Draws a rectangle the size of the SVG using the wxDC::SetBackground()\n"
"brush.");

extern "C" {static PyObject *meth_wxSVGFileDC_Clear(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_Clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Clear();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_Clear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetBitmapHandler, "SetBitmapHandler(handler)\n"
"\n"
"Replaces the default bitmap handler with handler.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetBitmapHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetBitmapHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGBitmapHandler* handler;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_handler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxSVGBitmapHandler, &handler))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetBitmapHandler(handler);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetBitmapHandler, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetShapeRenderingMode, "SetShapeRenderingMode(renderingMode)\n"
"\n"
"Set the shape rendering mode of the generated SVG.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetShapeRenderingMode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetShapeRenderingMode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGShapeRenderingMode renderingMode;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_renderingMode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BE", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxSVGShapeRenderingMode, &renderingMode))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetShapeRenderingMode(renderingMode);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetShapeRenderingMode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetClippingRegion, "SetClippingRegion(x, y, width, height)\n"
"\n"
"Sets the clipping region for this device context to the intersection\n"
"of the given region described by the parameters of this method and the\n"
"previously set clipping region.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetClippingRegion(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetClippingRegion(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxCoord width;
         ::wxCoord height;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClippingRegion(x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetClippingRegion, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSVGFileDC_DestroyClippingRegion, "DestroyClippingRegion()\n"
"\n"
"Destroys the current clipping region so that none of the DC is\n"
"clipped.");

extern "C" {static PyObject *meth_wxSVGFileDC_DestroyClippingRegion(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_DestroyClippingRegion(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DestroyClippingRegion();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_DestroyClippingRegion, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxSVGFileDC(void *, const sipTypeDef *);}
static void *cast_wxSVGFileDC(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxSVGFileDC *sipCpp = reinterpret_cast< ::wxSVGFileDC *>(sipCppV);

    if (targetType == sipType_wxDC)
        return static_cast< ::wxDC *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxSVGFileDC(void *, int);}
static void release_wxSVGFileDC(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxSVGFileDC *>(sipCppV);
    else
        delete reinterpret_cast< ::wxSVGFileDC *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxSVGFileDC(sipSimpleWrapper *);}
static void dealloc_wxSVGFileDC(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxSVGFileDC *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxSVGFileDC(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxSVGFileDC(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxSVGFileDC(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxSVGFileDC *sipCpp = SIP_NULLPTR;

    {
        const  ::wxString* filename;
        int filenameState = 0;
        int width = 320;
        int height = 240;
        double dpi = 72;
        const  ::wxString& titledef = wxString();
        const  ::wxString* title = &titledef;
        int titleState = 0;

        static const char *sipKwdList[] = {
            sipName_filename,
            sipName_width,
            sipName_height,
            sipName_dpi,
            sipName_title,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|iidJ1", sipType_wxString,&filename, &filenameState, &width, &height, &dpi, sipType_wxString,&title, &titleState))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxSVGFileDC(*filename,width,height,dpi,*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename),sipType_wxString,filenameState);
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxSVGFileDC[] = {{97, 255, 1}};


static PyMethodDef methods_wxSVGFileDC[] = {
    {SIP_MLNAME_CAST(sipName_Clear), meth_wxSVGFileDC_Clear, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_Clear)},
    {SIP_MLNAME_CAST(sipName_CrossHair), SIP_MLMETH_CAST(meth_wxSVGFileDC_CrossHair), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_CrossHair)},
    {SIP_MLNAME_CAST(sipName_DestroyClippingRegion), meth_wxSVGFileDC_DestroyClippingRegion, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_DestroyClippingRegion)},
    {SIP_MLNAME_CAST(sipName_EndDoc), meth_wxSVGFileDC_EndDoc, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_EndDoc)},
    {SIP_MLNAME_CAST(sipName_EndPage), meth_wxSVGFileDC_EndPage, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_EndPage)},
    {SIP_MLNAME_CAST(sipName_FloodFill), SIP_MLMETH_CAST(meth_wxSVGFileDC_FloodFill), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_FloodFill)},
    {SIP_MLNAME_CAST(sipName_GetDepth), meth_wxSVGFileDC_GetDepth, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_GetDepth)},
    {SIP_MLNAME_CAST(sipName_GetLogicalFunction), meth_wxSVGFileDC_GetLogicalFunction, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_GetLogicalFunction)},
    {SIP_MLNAME_CAST(sipName_GetPixel), SIP_MLMETH_CAST(meth_wxSVGFileDC_GetPixel), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_GetPixel)},
    {SIP_MLNAME_CAST(sipName_SetBitmapHandler), SIP_MLMETH_CAST(meth_wxSVGFileDC_SetBitmapHandler), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetBitmapHandler)},
    {SIP_MLNAME_CAST(sipName_SetClippingRegion), SIP_MLMETH_CAST(meth_wxSVGFileDC_SetClippingRegion), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetClippingRegion)},
    {SIP_MLNAME_CAST(sipName_SetLogicalFunction), SIP_MLMETH_CAST(meth_wxSVGFileDC_SetLogicalFunction), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetLogicalFunction)},
    {SIP_MLNAME_CAST(sipName_SetPalette), SIP_MLMETH_CAST(meth_wxSVGFileDC_SetPalette), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetPalette)},
    {SIP_MLNAME_CAST(sipName_SetShapeRenderingMode), SIP_MLMETH_CAST(meth_wxSVGFileDC_SetShapeRenderingMode), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetShapeRenderingMode)},
    {SIP_MLNAME_CAST(sipName_StartDoc), SIP_MLMETH_CAST(meth_wxSVGFileDC_StartDoc), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_StartDoc)},
    {SIP_MLNAME_CAST(sipName_StartPage), meth_wxSVGFileDC_StartPage, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_StartPage)}
};

sipVariableDef variables_wxSVGFileDC[] = {
    {PropertyVariable, sipName_LogicalFunction, &methods_wxSVGFileDC[7], &methods_wxSVGFileDC[11], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Depth, &methods_wxSVGFileDC[6], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxSVGFileDC, "SVGFileDC(filename, width=320, height=240, dpi=72, title=\"\")\n"
"\n"
"A wxSVGFileDC is a device context onto which graphics and text can be\n"
"drawn, and the output produced as a vector file, in SVG format.");


sipClassTypeDef sipTypeDef__core_wxSVGFileDC = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxSVGFileDC,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_SVGFileDC,
        {0, 0, 1},
        16, methods_wxSVGFileDC,
        0, SIP_NULLPTR,
        2, variables_wxSVGFileDC,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxSVGFileDC,
    -1,
    -1,
    supers_wxSVGFileDC,
    SIP_NULLPTR,
    init_type_wxSVGFileDC,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_wxSVGFileDC,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_wxSVGFileDC,
    cast_wxSVGFileDC,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
