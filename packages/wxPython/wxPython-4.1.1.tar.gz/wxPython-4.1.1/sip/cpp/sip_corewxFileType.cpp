/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.24
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/mimetype.h>

        #include <wx/mimetype.h>
        #include <wx/iconloc.h>
        #include <wx/mimetype.h>
            #include <wx/mimetype.h>
        #include <wx/icon.h>
    wxString* _wxFileType_GetOpenCommand(wxFileType* self, const wxFileType::MessageParameters* params)
    {
        wxString rv;
        self->GetOpenCommand(&rv, *params);
        return new wxString(rv);
    }
    wxString* _wxFileType_GetOpenCommand(wxFileType* self, const wxString* filename)
    {
        return new wxString( self->GetOpenCommand(*filename) );
    }
    wxString* _wxFileType_GetDescription(wxFileType* self)
    {
        wxString rv;
        self->GetDescription(&rv);
        return new wxString(rv);
    }
    wxArrayString* _wxFileType_GetExtensions(wxFileType* self)
    {
        wxArrayString* arr = new wxArrayString;
        self->GetExtensions(*arr); return arr;
    }
    wxIcon* _wxFileType_GetIcon(wxFileType* self)
    {
        wxIconLocation loc;
        if (self->GetIcon(&loc))
            return new wxIcon(loc);
        else
            return NULL;
    }
    wxString* _wxFileType_GetMimeType(wxFileType* self)
    {
        wxString rv;
        self->GetMimeType(&rv);
        return new wxString(rv);
    }
    wxArrayString* _wxFileType_GetMimeTypes(wxFileType* self)
    {
        wxArrayString* arr = new wxArrayString;
        self->GetMimeTypes(*arr);
        return arr;
    }
    wxString* _wxFileType_GetPrintCommand(wxFileType* self, const wxFileType::MessageParameters* params)
    {
        wxString rv;
        self->GetPrintCommand(&rv, *params);
        return new wxString(rv);
    }
    wxIconLocation* _wxFileType_GetIconLocation(wxFileType* self)
    {
        wxIconLocation loc;
        if (self->GetIcon(&loc))
            return new wxIconLocation(loc);
        else
            return NULL;
    }
    PyObject* _wxFileType_GetIconInfo(wxFileType* self)
    {
        wxIconLocation loc;
        if (self->GetIcon(&loc)) {
            wxString iconFile = loc.GetFileName();
            int iconIndex     = -1;
        #ifdef __WXMSW__
            iconIndex = loc.GetIndex();
        #endif
            // Make a tuple and put the values in it
            wxPyThreadBlocker blocker;
            PyObject* tuple = PyTuple_New(3);
            PyTuple_SetItem(tuple, 0,
                wxPyConstructObject(new wxIcon(loc), wxT("wxIcon"), true));
            PyTuple_SetItem(tuple, 1, wx2PyString(iconFile));
            PyTuple_SetItem(tuple, 2, wxPyInt_FromLong(iconIndex));
            return tuple;
        }
        else
            RETURN_NONE();
    }


PyDoc_STRVAR(doc_wxFileType_GetOpenCommand, "GetOpenCommand(params) -> String\n"
"GetOpenCommand(filename) -> String\n"
"\n"
"Returns the command which must be executed (see wx.Execute()) in order\n"
"to open the file of the given type. The name of the file as well as\n"
"any other parameters is retrieved from MessageParameters() class.\n"
"");

extern "C" {static PyObject *meth_wxFileType_GetOpenCommand(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetOpenCommand(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFileType::MessageParameters* params;
         ::wxFileType *sipCpp;

        static const char *sipKwdList[] = {
            sipName_params,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxFileType, &sipCpp, sipType_wxFileType_MessageParameters, &params))
        {
             ::wxString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetOpenCommand(sipCpp, params);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    {
        const  ::wxString* filename;
        int filenameState = 0;
         ::wxFileType *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxFileType, &sipCpp, sipType_wxString,&filename, &filenameState))
        {
             ::wxString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetOpenCommand(sipCpp, filename);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxString *>(filename),sipType_wxString,filenameState);

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetOpenCommand, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetDescription, "GetDescription() -> String\n"
"\n"
"Returns a brief description for this file type: for example, \"text\n"
"document\" for\n"
"the \"text/plain\" MIME type.");

extern "C" {static PyObject *meth_wxFileType_GetDescription(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetDescription(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetDescription(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetDescription, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetExtensions, "GetExtensions() -> ArrayString\n"
"\n"
"Returns all extensions associated with this file type: for\n"
"example, it may contain the following two elements for the MIME\n"
"type \"text/html\" (notice the absence of the leading dot): \"html\"\n"
"and \"htm\".\n"
"\n"
"This function is not implemented on Windows, there is no (efficient)\n"
"way to retrieve associated extensions from the given MIME type on\n"
"this platform.");

extern "C" {static PyObject *meth_wxFileType_GetExtensions(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetExtensions(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxArrayString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetExtensions(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetExtensions, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetIcon, "GetIcon() -> Icon\n"
"\n"
"Return the icon associated with this mime type, if any.");

extern "C" {static PyObject *meth_wxFileType_GetIcon(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetIcon(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxIcon*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetIcon(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxIcon,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetIcon, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetMimeType, "GetMimeType() -> String\n"
"\n"
"Returns full MIME type specification for this file type: for example,\n"
"\"text/plain\".");

extern "C" {static PyObject *meth_wxFileType_GetMimeType(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetMimeType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetMimeType(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetMimeType, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetMimeTypes, "GetMimeTypes() -> ArrayString\n"
"\n"
"Same as GetMimeType but returns a list of types.  This will usually\n"
"contain\n"
"only one item, but sometimes, such as on Unix with KDE more than one\n"
"type\n"
"if there are differences between KDE< mailcap and mime.types.");

extern "C" {static PyObject *meth_wxFileType_GetMimeTypes(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetMimeTypes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxArrayString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetMimeTypes(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxArrayString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetMimeTypes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetPrintCommand, "GetPrintCommand(params) -> String\n"
"\n"
"Returns the command which must be executed (see wxExecute()) in order\n"
"to\n"
"print the file of the given type. The name of the file is retrieved\n"
"from\n"
"the MessageParameters class.");

extern "C" {static PyObject *meth_wxFileType_GetPrintCommand(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetPrintCommand(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxFileType::MessageParameters* params;
         ::wxFileType *sipCpp;

        static const char *sipKwdList[] = {
            sipName_params,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxFileType, &sipCpp, sipType_wxFileType_MessageParameters, &params))
        {
             ::wxString*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetPrintCommand(sipCpp, params);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetPrintCommand, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetExpandedCommand, "GetExpandedCommand(verb, params) -> String\n"
"\n"
"The returned string is the command to be executed in order to\n"
"open/print/edit the file of the given type.");

extern "C" {static PyObject *meth_wxFileType_GetExpandedCommand(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetExpandedCommand(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* verb;
        int verbState = 0;
        const  ::wxFileType::MessageParameters* params;
        const  ::wxFileType *sipCpp;

        static const char *sipKwdList[] = {
            sipName_verb,
            sipName_params,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxFileType, &sipCpp, sipType_wxString,&verb, &verbState, sipType_wxFileType_MessageParameters, &params))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetExpandedCommand(*verb,*params));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(verb),sipType_wxString,verbState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetExpandedCommand, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetAllCommands, "GetAllCommands(params) -> (verbs, commands)\n"
"\n"
"Returns a tuple containing the `verbs` and `commands` arrays,\n"
"corresponding for the registered information for this mime type.");

extern "C" {static PyObject *meth_wxFileType_GetAllCommands(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetAllCommands(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxArrayString* verbs;
         ::wxArrayString* commands;
        const  ::wxFileType::MessageParameters* params;
        const  ::wxFileType *sipCpp;

        static const char *sipKwdList[] = {
            sipName_params,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9", &sipSelf, sipType_wxFileType, &sipCpp, sipType_wxFileType_MessageParameters, &params))
        {
            verbs = new  ::wxArrayString();
            commands = new  ::wxArrayString();

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetAllCommands(verbs,commands,*params);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(NN)",verbs,sipType_wxArrayString,SIP_NULLPTR,commands,sipType_wxArrayString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetAllCommands, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_ExpandCommand, "ExpandCommand(command, params) -> String\n"
"\n"
"This function is primarily intended for GetOpenCommand and\n"
"GetPrintCommand usage but may be also used by the application directly\n"
"if, for example, you want to use some non-default command to open the\n"
"file.");

extern "C" {static PyObject *meth_wxFileType_ExpandCommand(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxFileType_ExpandCommand(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxString* command;
        int commandState = 0;
        const  ::wxFileType::MessageParameters* params;

        static const char *sipKwdList[] = {
            sipName_command,
            sipName_params,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "J1J9", sipType_wxString,&command, &commandState, sipType_wxFileType_MessageParameters, &params))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString( ::wxFileType::ExpandCommand(*command,*params));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(command),sipType_wxString,commandState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_ExpandCommand, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetIconLocation, "GetIconLocation() -> IconLocation\n"
"\n"
"Returns a wx.IconLocation that can be used to fetch the icon for this\n"
"mime type.");

extern "C" {static PyObject *meth_wxFileType_GetIconLocation(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetIconLocation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
             ::wxIconLocation*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetIconLocation(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxIconLocation,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetIconLocation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxFileType_GetIconInfo, "GetIconInfo() -> PyObject\n"
"\n"
"Returns a tuple containing the Icon for this file type, the file where\n"
"the\n"
"icon is found, and the index of the image in that file, if applicable.");

extern "C" {static PyObject *meth_wxFileType_GetIconInfo(PyObject *, PyObject *);}
static PyObject *meth_wxFileType_GetIconInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxFileType *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxFileType, &sipCpp))
        {
            PyObject * sipRes = SIP_NULLPTR;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxFileType_GetIconInfo(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    sipNoMethod(sipParseErr, sipName_FileType, sipName_GetIconInfo, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxFileType(void *, int);}
static void release_wxFileType(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::wxFileType *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxFileType(sipSimpleWrapper *);}
static void dealloc_wxFileType(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxFileType(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_wxFileType(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxFileType(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::wxFileType *sipCpp = SIP_NULLPTR;

    {
        const  ::wxFileTypeInfo* ftInfo;

        static const char *sipKwdList[] = {
            sipName_ftInfo,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_wxFileTypeInfo, &ftInfo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new  ::wxFileType(*ftInfo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_wxFileType[] = {
    {SIP_MLNAME_CAST(sipName_ExpandCommand), SIP_MLMETH_CAST(meth_wxFileType_ExpandCommand), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxFileType_ExpandCommand)},
    {SIP_MLNAME_CAST(sipName_GetAllCommands), SIP_MLMETH_CAST(meth_wxFileType_GetAllCommands), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxFileType_GetAllCommands)},
    {SIP_MLNAME_CAST(sipName_GetDescription), meth_wxFileType_GetDescription, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetDescription)},
    {SIP_MLNAME_CAST(sipName_GetExpandedCommand), SIP_MLMETH_CAST(meth_wxFileType_GetExpandedCommand), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxFileType_GetExpandedCommand)},
    {SIP_MLNAME_CAST(sipName_GetExtensions), meth_wxFileType_GetExtensions, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetExtensions)},
    {SIP_MLNAME_CAST(sipName_GetIcon), meth_wxFileType_GetIcon, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetIcon)},
    {SIP_MLNAME_CAST(sipName_GetIconInfo), meth_wxFileType_GetIconInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetIconInfo)},
    {SIP_MLNAME_CAST(sipName_GetIconLocation), meth_wxFileType_GetIconLocation, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetIconLocation)},
    {SIP_MLNAME_CAST(sipName_GetMimeType), meth_wxFileType_GetMimeType, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetMimeType)},
    {SIP_MLNAME_CAST(sipName_GetMimeTypes), meth_wxFileType_GetMimeTypes, METH_VARARGS, SIP_MLDOC_CAST(doc_wxFileType_GetMimeTypes)},
    {SIP_MLNAME_CAST(sipName_GetOpenCommand), SIP_MLMETH_CAST(meth_wxFileType_GetOpenCommand), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxFileType_GetOpenCommand)},
    {SIP_MLNAME_CAST(sipName_GetPrintCommand), SIP_MLMETH_CAST(meth_wxFileType_GetPrintCommand), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxFileType_GetPrintCommand)}
};

sipVariableDef variables_wxFileType[] = {
    {PropertyVariable, sipName_PrintCommand, &methods_wxFileType[11], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_OpenCommand, &methods_wxFileType[10], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MimeTypes, &methods_wxFileType[9], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MimeType, &methods_wxFileType[8], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IconLocation, &methods_wxFileType[7], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_IconInfo, &methods_wxFileType[6], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Icon, &methods_wxFileType[5], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Extensions, &methods_wxFileType[4], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Description, &methods_wxFileType[2], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxFileType, "FileType(ftInfo)\n"
"\n"
"This class holds information about a given file type.");


sipClassTypeDef sipTypeDef__core_wxFileType = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_CLASS,
        sipNameNr_wxFileType,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_FileType,
        {0, 0, 1},
        12, methods_wxFileType,
        0, SIP_NULLPTR,
        9, variables_wxFileType,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxFileType,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_wxFileType,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_wxFileType,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_wxFileType,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
