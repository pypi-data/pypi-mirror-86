/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.24
 *
 *     Copyright: (c) 2020 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/sizer.h>

        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/sizer.h>
        #include <wx/sizer.h>
        
        
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    wxSizerItem* _wxSizer_Add(wxSizer* self, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Add(size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Add(wxSizer* self, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Add(size->x, size->y, *flags);
    }
    wxSizerItem* _wxSizer_Insert(wxSizer* self, ulong index, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Insert(index, size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Insert(wxSizer* self, ulong index, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Insert(index, size->x, size->y, *flags);
    }
    wxSizerItem* _wxSizer_Prepend(wxSizer* self, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Prepend(size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Prepend(wxSizer* self, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Prepend(size->x, size->y, *flags);
    }


class sipwxSizer : public  ::wxSizer
{
public:
    sipwxSizer();
    virtual ~sipwxSizer();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void RecalcSizes() SIP_OVERRIDE;
    void RepositionChildren(const  ::wxSize&) SIP_OVERRIDE;
     ::wxSize CalcMin() SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxSizer(const sipwxSizer &);
    sipwxSizer &operator = (const sipwxSizer &);

    char sipPyMethods[3];
};

sipwxSizer::sipwxSizer():  ::wxSizer(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxSizer::~sipwxSizer()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipwxSizer::RecalcSizes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_RecalcSizes);

    if (!sipMeth)
    {
         ::wxSizer::RecalcSizes();
        return;
    }

    extern void sipVH__core_53(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_53(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxSizer::RepositionChildren(const  ::wxSize& minSize)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_RepositionChildren);

    if (!sipMeth)
    {
         ::wxSizer::RepositionChildren(minSize);
        return;
    }

    extern void sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxSize&);

    sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth, minSize);
}

 ::wxSize sipwxSizer::CalcMin()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,sipName_Sizer,sipName_CalcMin);

    if (!sipMeth)
        return  ::wxSize();

    extern  ::wxSize sipVH__core_100(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_100(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_wxSizer_GetChildren, "GetChildren() -> SizerItemList\n"
"\n"
"Returns the list of the items in this sizer.");

extern "C" {static PyObject *meth_wxSizer_GetChildren(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSizerItemList*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItemList,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_SetItemMinSize, "SetItemMinSize(window, width, height) -> bool\n"
"SetItemMinSize(window, size) -> bool\n"
"SetItemMinSize(sizer, width, height) -> bool\n"
"SetItemMinSize(sizer, size) -> bool\n"
"SetItemMinSize(index, width, height) -> bool\n"
"SetItemMinSize(index, size) -> bool\n"
"\n"
"Set an item's minimum size by window, sizer, or position.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetItemMinSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetItemMinSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8ii", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(window,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxWindow* window;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(window,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8ii", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(sizer,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(sizer,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=ii", &sipSelf, sipType_wxSizer, &sipCpp, &index, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(index,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J1", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(index,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetItemMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Add, "Add(window, flags) -> SizerItem\n"
"Add(window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(sizer, flags) -> SizerItem\n"
"Add(sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(width, height, flags) -> SizerItem\n"
"Add(item) -> SizerItem\n"
"Add(size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Add(size, flags) -> SizerItem\n"
"\n"
"Appends a child to the sizer.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Add(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Add(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(window,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(sizer,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ9", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(width,height,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Add(sipCpp, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Add(sipCpp, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Add, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_AddSpacer, "AddSpacer(size) -> SizerItem\n"
"\n"
"This base function adds non-stretchable space to both the horizontal\n"
"and vertical orientation of the sizer.");

extern "C" {static PyObject *meth_wxSizer_AddSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_AddSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AddSpacer(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_AddSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_AddStretchSpacer, "AddStretchSpacer(prop=1) -> SizerItem\n"
"\n"
"Adds stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_AddStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_AddStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxSizer, &sipCpp, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AddStretchSpacer(prop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_AddStretchSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_CalcMin, "CalcMin() -> Size\n"
"\n"
"This method is abstract and has to be overwritten by any derived\n"
"class.");

extern "C" {static PyObject *meth_wxSizer_CalcMin(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_CalcMin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Sizer, sipName_CalcMin);
                return SIP_NULLPTR;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->CalcMin());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_CalcMin, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Clear, "Clear(delete_windows=False)\n"
"\n"
"Detaches all children from the sizer.");

extern "C" {static PyObject *meth_wxSizer_Clear(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Clear(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool delete_windows = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_delete_windows,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|b", &sipSelf, sipType_wxSizer, &sipCpp, &delete_windows))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Clear(delete_windows);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Clear, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_ComputeFittingClientSize, "ComputeFittingClientSize(window) -> Size\n"
"\n"
"Computes client area size for window so that it matches the sizer's\n"
"minimal size.");

extern "C" {static PyObject *meth_wxSizer_ComputeFittingClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ComputeFittingClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ComputeFittingClientSize(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ComputeFittingClientSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_ComputeFittingWindowSize, "ComputeFittingWindowSize(window) -> Size\n"
"\n"
"Like ComputeFittingClientSize(), but converts the result into window\n"
"size.");

extern "C" {static PyObject *meth_wxSizer_ComputeFittingWindowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ComputeFittingWindowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ComputeFittingWindowSize(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ComputeFittingWindowSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Detach, "Detach(window) -> bool\n"
"Detach(sizer) -> bool\n"
"Detach(index) -> bool\n"
"\n"
"Detach the child window from the sizer without destroying it.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Detach(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Detach(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Detach, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Fit, "Fit(window) -> Size\n"
"\n"
"Tell the sizer to resize the window so that its client area matches\n"
"the sizer's minimal size (ComputeFittingClientSize() is called to\n"
"determine it).");

extern "C" {static PyObject *meth_wxSizer_Fit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Fit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->Fit(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Fit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_FitInside, "FitInside(window)\n"
"\n"
"Tell the sizer to resize the virtual size of the window to match the\n"
"sizer's minimal size.");

extern "C" {static PyObject *meth_wxSizer_FitInside(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_FitInside(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FitInside(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_FitInside, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_InformFirstDirection, "InformFirstDirection(direction, size, availableOtherDir) -> bool\n"
"\n"
"Inform sizer about the first direction that has been decided (by\n"
"parent item).");

extern "C" {static PyObject *meth_wxSizer_InformFirstDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InformFirstDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int direction;
        int size;
        int availableOtherDir;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
            sipName_size,
            sipName_availableOtherDir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biii", &sipSelf, sipType_wxSizer, &sipCpp, &direction, &size, &availableOtherDir))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InformFirstDirection(direction,size,availableOtherDir);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InformFirstDirection, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetContainingWindow, "GetContainingWindow() -> Window\n"
"\n"
"Returns the window this sizer is used in or NULL if none.");

extern "C" {static PyObject *meth_wxSizer_GetContainingWindow(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetContainingWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetContainingWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetContainingWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_SetContainingWindow, "SetContainingWindow(window)\n"
"\n"
"Set the window this sizer is used in.");

extern "C" {static PyObject *meth_wxSizer_SetContainingWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetContainingWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetContainingWindow(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetContainingWindow, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetItemCount, "GetItemCount() -> size_t\n"
"\n"
"Returns the number of items in the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetItemCount(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItemCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            size_t sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItemCount();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItemCount, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetItem, "GetItem(window, recursive=False) -> SizerItem\n"
"GetItem(sizer, recursive=False) -> SizerItem\n"
"GetItem(index) -> SizerItem\n"
"\n"
"Finds wxSizerItem which holds the given window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_GetItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(window,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizer* sizer;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(sizer,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItem, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetItemById, "GetItemById(id, recursive=False) -> SizerItem\n"
"\n"
"Finds item of the sizer which has the given id.");

extern "C" {static PyObject *meth_wxSizer_GetItemById(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItemById(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int id;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi|b", &sipSelf, sipType_wxSizer, &sipCpp, &id, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItemById(id,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItemById, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetMinSize, "GetMinSize() -> Size\n"
"\n"
"Returns the minimal size of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetMinSize(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetMinSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMinSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetPosition, "GetPosition() -> Point\n"
"\n"
"Returns the current position of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetPosition(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPosition());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetPosition, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_GetSize, "GetSize() -> Size\n"
"\n"
"Returns the current size of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetSize(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Hide, "Hide(window, recursive=False) -> bool\n"
"Hide(sizer, recursive=False) -> bool\n"
"Hide(index) -> bool\n"
"\n"
"Hides the child window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Hide(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Hide(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(window,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(sizer,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Hide, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Insert, "Insert(index, window, flags) -> SizerItem\n"
"Insert(index, window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, sizer, flags) -> SizerItem\n"
"Insert(index, sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, width, height, flags) -> SizerItem\n"
"Insert(index, item) -> SizerItem\n"
"Insert(index, size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Insert(index, size, flags) -> SizerItem\n"
"\n"
"Insert a child into the sizer before any existing item at index.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Insert(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Insert(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        size_t index;
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J8J9", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,window,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J:J9", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,sizer,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=ii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &index, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=iiJ9", &sipSelf, sipType_wxSizer, &sipCpp, &index, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,width,height,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        size_t index;
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J:", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(index,item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::ulong index;
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BmJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Insert(sipCpp, index, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::ulong index;
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BmJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Insert(sipCpp, index, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Insert, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_InsertSpacer, "InsertSpacer(index, size) -> SizerItem\n"
"\n"
"Inserts non-stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_InsertSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InsertSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        size_t index;
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=i", &sipSelf, sipType_wxSizer, &sipCpp, &index, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertSpacer(index,size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InsertSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_InsertStretchSpacer, "InsertStretchSpacer(index, prop=1) -> SizerItem\n"
"\n"
"Inserts stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_InsertStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InsertStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        size_t index;
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=|i", &sipSelf, sipType_wxSizer, &sipCpp, &index, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertStretchSpacer(index,prop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InsertStretchSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_IsEmpty, "IsEmpty() -> bool\n"
"\n"
"Return true if the sizer has no elements.");

extern "C" {static PyObject *meth_wxSizer_IsEmpty(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_IsEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEmpty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_IsEmpty, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_IsShown, "IsShown(window) -> bool\n"
"IsShown(sizer) -> bool\n"
"IsShown(index) -> bool\n"
"\n"
"Returns true if the window is shown.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_IsShown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_IsShown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_IsShown, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Layout, "Layout()\n"
"\n"
"Call this to force layout of the children anew, e.g. after having\n"
"added a child to or removed a child (window, other sizer or space)\n"
"from the sizer while keeping the current dimension.");

extern "C" {static PyObject *meth_wxSizer_Layout(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Layout(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Layout();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Layout, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Prepend, "Prepend(window, flags) -> SizerItem\n"
"Prepend(window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(sizer, flags) -> SizerItem\n"
"Prepend(sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(width, height, flags) -> SizerItem\n"
"Prepend(item) -> SizerItem\n"
"Prepend(size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Prepend(size, flags) -> SizerItem\n"
"\n"
"Same as Add(), but prepends the items to the beginning of the list of\n"
"items (windows, subsizers or spaces) owned by this sizer.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Prepend(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Prepend(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(window,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(sizer,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BiiJ9", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(width,height,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ:", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Prepend(sipCpp, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Prepend(sipCpp, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Prepend, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_PrependSpacer, "PrependSpacer(size) -> SizerItem\n"
"\n"
"Prepends non-stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_PrependSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_PrependSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependSpacer(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_PrependSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_PrependStretchSpacer, "PrependStretchSpacer(prop=1) -> SizerItem\n"
"\n"
"Prepends stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_PrependStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_PrependStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B|i", &sipSelf, sipType_wxSizer, &sipCpp, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependStretchSpacer(prop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,SIP_NULLPTR);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_PrependStretchSpacer, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_RepositionChildren, "RepositionChildren(minSize)\n"
"\n"
"Method which must be overridden in the derived sizer classes.");

extern "C" {static PyObject *meth_wxSizer_RepositionChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_RepositionChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxSize* minSize;
        int minSizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &minSize, &minSizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxSizer::RepositionChildren(*minSize) : sipCpp->RepositionChildren(*minSize));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(minSize),sipType_wxSize,minSizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_RepositionChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_RecalcSizes, "RecalcSizes()\n"
"\n"
"This is a deprecated version of RepositionChildren()");

extern "C" {static PyObject *meth_wxSizer_RecalcSizes(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_RecalcSizes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxSizer::RecalcSizes() : sipCpp->RecalcSizes());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_RecalcSizes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Remove, "Remove(sizer) -> bool\n"
"Remove(index) -> bool\n"
"\n"
"Removes a sizer child from the sizer and destroys it.\n"
"");

extern "C" {static PyObject *meth_wxSizer_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxSizer* sizer;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Remove, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Replace, "Replace(oldwin, newwin, recursive=False) -> bool\n"
"Replace(oldsz, newsz, recursive=False) -> bool\n"
"Replace(index, newitem) -> bool\n"
"\n"
"Detaches the given oldwin from the sizer and replaces it with the\n"
"given newwin.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Replace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Replace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* oldwin;
         ::wxWindow* newwin;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldwin,
            sipName_newwin,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &oldwin, sipType_wxWindow, &newwin, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(oldwin,newwin,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* oldsz;
         ::wxSizer* newsz;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldsz,
            sipName_newsz,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8J8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &oldsz, sipType_wxSizer, &newsz, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(oldsz,newsz,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
         ::wxSizerItem* newitem;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_newitem,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=J8", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSizerItem, &newitem))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(index,newitem);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Replace, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_SetDimension, "SetDimension(x, y, width, height)\n"
"SetDimension(pos, size)\n"
"\n"
"Call this to force the sizer to take the given dimension and thus\n"
"force the items owned by the sizer to resize themselves according to\n"
"the rules defined by the parameter in the Add() and Prepend() methods.\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetDimension(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetDimension(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        int x;
        int y;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Biiii", &sipSelf, sipType_wxSizer, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDimension(x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPoint* pos;
        int posState = 0;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDimension(*pos,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos),sipType_wxPoint,posState);
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetDimension, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_SetMinSize, "SetMinSize(size)\n"
"SetMinSize(width, height)\n"
"\n"
"Call this to give the sizer a minimal size.\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetMinSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetMinSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bii", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinSize(width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetMinSize, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_SetSizeHints, "SetSizeHints(window)\n"
"\n"
"This method first calls Fit() and then\n"
"wxTopLevelWindow::SetSizeHints() on the window passed to it.");

extern "C" {static PyObject *meth_wxSizer_SetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizeHints(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetSizeHints, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_Show, "Show(window, show=True, recursive=False) -> bool\n"
"Show(sizer, show=True, recursive=False) -> bool\n"
"Show(index, show=True) -> bool\n"
"\n"
"Shows or hides the window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Show(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Show(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::wxWindow* window;
        bool show = 1;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_show,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|bb", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &show, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(window,show,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        bool show = 1;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_show,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ8|bb", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &show, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(sizer,show,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        size_t index;
        bool show = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "B=|b", &sipSelf, sipType_wxSizer, &sipCpp, &index, &show))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(index,show);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Show, SIP_NULLPTR);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_wxSizer_ShowItems, "ShowItems(show)\n"
"\n"
"Show or hide all items managed by the sizer.");

extern "C" {static PyObject *meth_wxSizer_ShowItems(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ShowItems(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        bool show;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "Bb", &sipSelf, sipType_wxSizer, &sipCpp, &show))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowItems(show);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ShowItems, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxSizer(void *, const sipTypeDef *);}
static void *cast_wxSizer(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxSizer *sipCpp = reinterpret_cast< ::wxSizer *>(sipCppV);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxSizer(void *, int);}
static void release_wxSizer(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxSizer *>(sipCppV);
    else
        delete reinterpret_cast< ::wxSizer *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxSizer(sipSimpleWrapper *);}
static void dealloc_wxSizer(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxSizer *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxSizer(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxSizer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxSizer(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxSizer *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxSizer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return SIP_NULLPTR;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxSizer[] = {{371, 255, 1}};


static PyMethodDef methods_wxSizer[] = {
    {SIP_MLNAME_CAST(sipName_Add), SIP_MLMETH_CAST(meth_wxSizer_Add), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Add)},
    {SIP_MLNAME_CAST(sipName_AddSpacer), SIP_MLMETH_CAST(meth_wxSizer_AddSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_AddSpacer)},
    {SIP_MLNAME_CAST(sipName_AddStretchSpacer), SIP_MLMETH_CAST(meth_wxSizer_AddStretchSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_AddStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_CalcMin), meth_wxSizer_CalcMin, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_CalcMin)},
    {SIP_MLNAME_CAST(sipName_Clear), SIP_MLMETH_CAST(meth_wxSizer_Clear), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Clear)},
    {SIP_MLNAME_CAST(sipName_ComputeFittingClientSize), SIP_MLMETH_CAST(meth_wxSizer_ComputeFittingClientSize), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ComputeFittingClientSize)},
    {SIP_MLNAME_CAST(sipName_ComputeFittingWindowSize), SIP_MLMETH_CAST(meth_wxSizer_ComputeFittingWindowSize), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ComputeFittingWindowSize)},
    {SIP_MLNAME_CAST(sipName_Detach), SIP_MLMETH_CAST(meth_wxSizer_Detach), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Detach)},
    {SIP_MLNAME_CAST(sipName_Fit), SIP_MLMETH_CAST(meth_wxSizer_Fit), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Fit)},
    {SIP_MLNAME_CAST(sipName_FitInside), SIP_MLMETH_CAST(meth_wxSizer_FitInside), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_FitInside)},
    {SIP_MLNAME_CAST(sipName_GetChildren), meth_wxSizer_GetChildren, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetChildren)},
    {SIP_MLNAME_CAST(sipName_GetContainingWindow), meth_wxSizer_GetContainingWindow, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetContainingWindow)},
    {SIP_MLNAME_CAST(sipName_GetItem), SIP_MLMETH_CAST(meth_wxSizer_GetItem), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_GetItem)},
    {SIP_MLNAME_CAST(sipName_GetItemById), SIP_MLMETH_CAST(meth_wxSizer_GetItemById), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_GetItemById)},
    {SIP_MLNAME_CAST(sipName_GetItemCount), meth_wxSizer_GetItemCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetItemCount)},
    {SIP_MLNAME_CAST(sipName_GetMinSize), meth_wxSizer_GetMinSize, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetMinSize)},
    {SIP_MLNAME_CAST(sipName_GetPosition), meth_wxSizer_GetPosition, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetPosition)},
    {SIP_MLNAME_CAST(sipName_GetSize), meth_wxSizer_GetSize, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetSize)},
    {SIP_MLNAME_CAST(sipName_Hide), SIP_MLMETH_CAST(meth_wxSizer_Hide), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Hide)},
    {SIP_MLNAME_CAST(sipName_InformFirstDirection), SIP_MLMETH_CAST(meth_wxSizer_InformFirstDirection), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InformFirstDirection)},
    {SIP_MLNAME_CAST(sipName_Insert), SIP_MLMETH_CAST(meth_wxSizer_Insert), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Insert)},
    {SIP_MLNAME_CAST(sipName_InsertSpacer), SIP_MLMETH_CAST(meth_wxSizer_InsertSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InsertSpacer)},
    {SIP_MLNAME_CAST(sipName_InsertStretchSpacer), SIP_MLMETH_CAST(meth_wxSizer_InsertStretchSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InsertStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_IsEmpty), meth_wxSizer_IsEmpty, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_IsEmpty)},
    {SIP_MLNAME_CAST(sipName_IsShown), SIP_MLMETH_CAST(meth_wxSizer_IsShown), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_IsShown)},
    {SIP_MLNAME_CAST(sipName_Layout), meth_wxSizer_Layout, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_Layout)},
    {SIP_MLNAME_CAST(sipName_Prepend), SIP_MLMETH_CAST(meth_wxSizer_Prepend), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Prepend)},
    {SIP_MLNAME_CAST(sipName_PrependSpacer), SIP_MLMETH_CAST(meth_wxSizer_PrependSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_PrependSpacer)},
    {SIP_MLNAME_CAST(sipName_PrependStretchSpacer), SIP_MLMETH_CAST(meth_wxSizer_PrependStretchSpacer), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_PrependStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_RecalcSizes), meth_wxSizer_RecalcSizes, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_RecalcSizes)},
    {SIP_MLNAME_CAST(sipName_Remove), SIP_MLMETH_CAST(meth_wxSizer_Remove), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Remove)},
    {SIP_MLNAME_CAST(sipName_Replace), SIP_MLMETH_CAST(meth_wxSizer_Replace), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Replace)},
    {SIP_MLNAME_CAST(sipName_RepositionChildren), SIP_MLMETH_CAST(meth_wxSizer_RepositionChildren), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_RepositionChildren)},
    {SIP_MLNAME_CAST(sipName_SetContainingWindow), SIP_MLMETH_CAST(meth_wxSizer_SetContainingWindow), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetContainingWindow)},
    {SIP_MLNAME_CAST(sipName_SetDimension), SIP_MLMETH_CAST(meth_wxSizer_SetDimension), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetDimension)},
    {SIP_MLNAME_CAST(sipName_SetItemMinSize), SIP_MLMETH_CAST(meth_wxSizer_SetItemMinSize), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetItemMinSize)},
    {SIP_MLNAME_CAST(sipName_SetMinSize), SIP_MLMETH_CAST(meth_wxSizer_SetMinSize), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetMinSize)},
    {SIP_MLNAME_CAST(sipName_SetSizeHints), SIP_MLMETH_CAST(meth_wxSizer_SetSizeHints), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetSizeHints)},
    {SIP_MLNAME_CAST(sipName_Show), SIP_MLMETH_CAST(meth_wxSizer_Show), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Show)},
    {SIP_MLNAME_CAST(sipName_ShowItems), SIP_MLMETH_CAST(meth_wxSizer_ShowItems), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ShowItems)}
};

sipVariableDef variables_wxSizer[] = {
    {PropertyVariable, sipName_Size, &methods_wxSizer[17], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Position, &methods_wxSizer[16], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_MinSize, &methods_wxSizer[15], &methods_wxSizer[36], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ItemCount, &methods_wxSizer[14], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_ContainingWindow, &methods_wxSizer[11], &methods_wxSizer[33], SIP_NULLPTR, SIP_NULLPTR},
    {PropertyVariable, sipName_Children, &methods_wxSizer[10], SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
};

PyDoc_STRVAR(doc_wxSizer, "Sizer()\n"
"\n"
"wxSizer is the abstract base class used for laying out subwindows in a\n"
"window.");


sipClassTypeDef sipTypeDef__core_wxSizer = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxSizer,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_Sizer,
        {0, 0, 1},
        40, methods_wxSizer,
        0, SIP_NULLPTR,
        6, variables_wxSizer,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_wxSizer,
    -1,
    -1,
    supers_wxSizer,
    SIP_NULLPTR,
    init_type_wxSizer,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_wxSizer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_wxSizer,
    cast_wxSizer,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
