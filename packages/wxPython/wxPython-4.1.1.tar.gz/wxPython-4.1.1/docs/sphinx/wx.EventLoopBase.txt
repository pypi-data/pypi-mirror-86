.. wxPython Phoenix documentation

   This file was generated by Phoenix's sphinx generator and associated
   tools, do not edit by hand.

   Copyright: (c) 2011-2020 by Total Control Software
   License:   wxWindows License

.. include:: headings.inc



.. _wx.EventLoopBase:

==========================================================================================================================================
|phoenix_title|  **wx.EventLoopBase**
==========================================================================================================================================

Base class for all event loop implementations.          

An event loop is a class which queries the queue of native events sent to the wxWidgets application and dispatches them to the appropriate EvtHandlers. 

An object of this class is created by :meth:`wx.AppTraits.CreateEventLoop`   and used by :ref:`wx.App`  to run the main application event loop. Temporary event loops are usually created by :meth:`wx.Dialog.ShowModal` . 

You can create your own event loop if you need, provided that you restore the main event loop once yours is destroyed (see :ref:`wx.EventLoopActivator`). 

Notice that there can be more than one event loop at any given moment, e.g. an event handler called from the main loop can show a modal dialog, which starts its own loop resulting in two nested loops, with the modal dialog being the active one (its :meth:`~wx.EventLoopBase.IsRunning`  returns ``True``). And a handler for a button inside the modal dialog can, of course, create another modal dialog with its own event loop and so on. So in general event loops form a stack and only the event loop at the top of the stack is considered to be active. It is also the only loop that can be directly asked to terminate by calling :ref:`wx.Exit`  (which is done by :meth:`wx.Dialog.EndModal` ), an outer event loop can't be stopped while an inner one is still running. It is however possible to ask an outer event loop to terminate as soon as all its nested loops exit and the control returns back to it by using :meth:`~wx.EventLoopBase.ScheduleExit`. 







         



.. seealso:: :ref:`wx.App`, :ref:`wx.EventLoopActivator`    







|

|class_hierarchy| Class Hierarchy
=================================

.. raw:: html

   <div id="toggleBlock" onclick="return toggleVisibility(this)" class="closed" style="cursor:pointer;">
   <img id="toggleBlock-trigger" src="_static/images/closed.png"/>
   Inheritance diagram for class <strong>EventLoopBase</strong>:
   </div>
   <div id="toggleBlock-summary" style="display:block;"></div>
   <div id="toggleBlock-content" style="display:none;">
   <p class="graphviz">
   <center><img src="_static/images/inheritance/wx.EventLoopBase_inheritance.png" alt="Inheritance diagram of EventLoopBase" usemap="#dummy" class="inheritance"/></center>
   <script type="text/javascript">toggleVisibilityOnLoad(document.getElementById('toggleBlock'))</script>
   <map id="dummy" name="dummy"> <area shape="rect" id="node1" href="wx.EventLoopBase.html" title="wx.EventLoopBase" alt="" coords="5,5,151,35"/> </map> 
   </p>
   </div>

|


|sub_classes| Known Subclasses
==============================

:ref:`wx.GUIEventLoop`

|


|method_summary| Methods Summary
================================

================================================================================ ================================================================================
:meth:`~wx.EventLoopBase.Dispatch`                                               Dispatches the next event in the windowing system event queue.
:meth:`~wx.EventLoopBase.DispatchTimeout`                                        Dispatch an event but not wait longer than the specified timeout for it.
:meth:`~wx.EventLoopBase.Exit`                                                   Exit the currently running loop with the given exit code.
:meth:`~wx.EventLoopBase.GetActive`                                              Return the currently active (running) event loop.
:meth:`~wx.EventLoopBase.IsEventAllowedInsideYield`                              Returns ``True`` if the given event category is allowed inside a :meth:`~EventLoopBase.YieldFor`   call (i.e.
:meth:`~wx.EventLoopBase.IsMain`                                                 Returns ``True`` if this is the main loop executed by :meth:`wx.App.OnRun` .
:meth:`~wx.EventLoopBase.IsOk`                                                   Use this to check whether the event loop was successfully created before using it.
:meth:`~wx.EventLoopBase.IsRunning`                                              Return ``True`` if this event loop is currently running.
:meth:`~wx.EventLoopBase.IsYielding`                                             Returns ``True`` if called from inside :ref:`wx.Yield`  or from inside :meth:`~EventLoopBase.YieldFor` .
:meth:`~wx.EventLoopBase.OnExit`                                                 This function is called before the event loop terminates, whether this happens normally (because of :ref:`wx.Exit`  call) or abnormally (because of an exception thrown from inside the loop).
:meth:`~wx.EventLoopBase.Pending`                                                Return ``True`` if any events are available.
:meth:`~wx.EventLoopBase.ProcessIdle`                                            This virtual function is called when the application becomes idle and normally just sends :ref:`wx.IdleEvent`  to all interested parties.
:meth:`~wx.EventLoopBase.Run`                                                    Start the event loop, return the exit code when it is finished.
:meth:`~wx.EventLoopBase.ScheduleExit`                                           Schedule an exit from the loop with the given exit code.
:meth:`~wx.EventLoopBase.SetActive`                                              Set currently active (running) event loop.
:meth:`~wx.EventLoopBase.WakeUp`                                                 Called by wxWidgets to wake up the event loop even if it is currently blocked inside :meth:`~EventLoopBase.Dispatch` .
:meth:`~wx.EventLoopBase.WakeUpIdle`                                             Makes sure that idle events are sent again.
:meth:`~wx.EventLoopBase.Yield`                                                  Yields control to pending messages in the windowing system.
:meth:`~wx.EventLoopBase.YieldFor`                                               Works like :ref:`wx.Yield`  with `onlyIfNeeded`  == ``True``, except that it allows the caller to specify a mask of the :ref:`wx.EventCategory`  values which indicates which events should be processed and which should instead be "delayed" (i.e.
================================================================================ ================================================================================


|


|api| Class API
===============


.. class:: wx.EventLoopBase(object)

   Base class for all event loop implementations.



   .. method:: Dispatch(self)

      Dispatches the next event in the windowing system event queue.                  

      Blocks until an event appears if there are none currently (use :meth:`Pending`   if this is not wanted). 

      This can be used for programming event loops, e.g. 

      ::

                  while evtloop.Pending():
                      evtloop.Dispatch()



                

      :rtype: `bool`







      :returns: 

         ``False`` if the event loop should stop and ``True`` otherwise.  







      .. seealso:: :meth:`Pending` , :ref:`wx.EventLoopBase`    








   .. method:: DispatchTimeout(self, timeout)

      Dispatch an event but not wait longer than the specified timeout for it.                  

      If an event is received before the specified `timeout`  expires, it is processed and the function returns 1 normally or 0 if the event loop should quite. Otherwise, i.e. if the timeout expires, the functions returns -1 without processing any events. 




      :param `timeout`: The maximal time to wait for the events in milliseconds.  
      :type `timeout`: long






      :rtype: `int`



                  



      :returns: 

         1 if an event was processed, 0 if the event loop should quit or -1 if the timeout expired.   








   .. method:: Exit(self, rc=0)

      Exit the currently running loop with the given exit code.                  

      The loop will exit, i.e. its :meth:`Run`   method will return, during the next event loop iteration. 

      Notice that this method can only be used if this event loop is the currently running one, i.e. its :meth:`IsRunning`   returns ``True``. If this is not the case, an assert failure is triggered and nothing is done as outer event loops can't be exited from immediately. Use :meth:`ScheduleExit`   if you'd like to exit this loop even if it doesn't run currently.                  


      :param `rc`: 
      :type `rc`: int







   .. staticmethod:: GetActive()

      Return the currently active (running) event loop.                  

      May return ``None`` if there is no active event loop (e.g. during application startup or shutdown).                  

      :rtype: :ref:`wx.EventLoopBase`








   .. method:: IsEventAllowedInsideYield(self, cat)

      Returns ``True`` if the given event category is allowed inside a :meth:`YieldFor`   call (i.e.                  

      compares the given category against the last mask passed to :meth:`YieldFor` ). 

                


      :param `cat`: 
      :type `cat`: wx.EventCategory




      :rtype: `bool`







      .. seealso:: :meth:`wx.Event.GetEventCategory`     








   .. method:: IsMain(self)

      Returns ``True`` if this is the main loop executed by :meth:`wx.App.OnRun` .                  

      :rtype: `bool`








   .. method:: IsOk(self)

      Use this to check whether the event loop was successfully created before using it.                  

      :rtype: `bool`








   .. method:: IsRunning(self)

      Return ``True`` if this event loop is currently running.                  

      Notice that even if this event loop hasn't terminated yet but has just spawned a nested (e.g. modal) event loop, this method would return ``False``.                  

      :rtype: `bool`








   .. method:: IsYielding(self)

      Returns ``True`` if called from inside :ref:`wx.Yield`  or from inside :meth:`YieldFor` .                  

      :rtype: `bool`








   .. method:: OnExit(self)

      This function is called before the event loop terminates, whether this happens normally (because of :ref:`wx.Exit`  call) or abnormally (because of an exception thrown from inside the loop).                  

      The default implementation calls :meth:`wx.AppConsole.OnEventLoopExit` .                   





   .. method:: Pending(self)

      Return ``True`` if any events are available.                  

      If this method returns ``True``, calling :meth:`Dispatch`   will not block.                  

      :rtype: `bool`








   .. method:: ProcessIdle(self)

      This virtual function is called when the application becomes idle and normally just sends :ref:`wx.IdleEvent`  to all interested parties.                  

      It should return ``True`` if more idle events are needed, ``False`` if not.                  

      :rtype: `bool`








   .. method:: Run(self)

      Start the event loop, return the exit code when it is finished.                  

      Logically, this method calls :meth:`Dispatch`   in a loop until it returns ``False`` and also takes care of generating idle events during each loop iteration. However not all implementations of this class really implement it like this (e.g. wxGTK does not) so you shouldn't rely on :meth:`Dispatch`   being called from inside this function. 

                

      :rtype: `int`







      :returns: 

         The argument passed to :ref:`wx.Exit`  which terminated this event loop.   








   .. method:: ScheduleExit(self, rc=0)

      Schedule an exit from the loop with the given exit code.                  

      This method is similar to :ref:`wx.Exit`  but can be called even if this event loop is not the currently running one â€“  and if it is the active loop, then it works in exactly the same way as :ref:`wx.Exit`. 

      The loop will exit as soon as the control flow returns to it, i.e. after any nested loops terminate. 

                


      :param `rc`: 
      :type `rc`: int






      .. versionadded:: 2.9.5 
     








   .. staticmethod:: SetActive(loop)

      Set currently active (running) event loop.                  

      Called by :ref:`wx.EventLoopActivator`, use an instance of this class instead of calling this method directly to ensure that the previously active event loop is restored. 

      Results in a call to :meth:`wx.AppConsole.OnEventLoopEnter` .                  


      :param `loop`: 
      :type `loop`: wx.EventLoopBase







   .. method:: WakeUp(self)

      Called by wxWidgets to wake up the event loop even if it is currently blocked inside :meth:`Dispatch` .                   





   .. method:: WakeUpIdle(self)

      Makes sure that idle events are sent again.                   





   .. method:: Yield(self, onlyIfNeeded=False)

      Yields control to pending messages in the windowing system.                  

      This can be useful, for example, when a time-consuming process writes to a text window. Without an occasional yield, the text window will not be updated properly, and on systems with cooperative multitasking, other processes will not respond. 

      Caution should be exercised, however, since yielding may allow the user to perform actions which are not compatible with the current task. Disabling menu items or whole menus during processing can avoid unwanted reentrance of code: see :ref:`wx.SafeYield`  for a better function. 

      Note that :ref:`wx.Yield`  will not flush the message logs. This is intentional as calling :ref:`wx.Yield`  is usually done to quickly update the screen and popping up a message box dialog may be undesirable. If you do wish to flush the log messages immediately (otherwise it will be done during the next idle loop iteration), call :meth:`wx.Log.FlushActive` . 

      If `onlyIfNeeded`  parameter is ``True`` and the flow control is already inside :ref:`wx.Yield`, i.e. :meth:`IsYielding`   returns ``True``, the method just silently returns ``False`` and doesn't do anything.                  


      :param `onlyIfNeeded`: 
      :type `onlyIfNeeded`: bool




      :rtype: `bool`








   .. method:: YieldFor(self, eventsToProcess)

      Works like :ref:`wx.Yield`  with `onlyIfNeeded`  == ``True``, except that it allows the caller to specify a mask of the :ref:`wx.EventCategory`  values which indicates which events should be processed and which should instead be "delayed" (i.e.                  

      processed by the main loop later). 

      Note that this is a safer alternative to :ref:`wx.Yield`  since it ensures that only the events you're interested to will be processed; i.e. this method helps to avoid unwanted reentrancies. 

      Note that currently only wxMSW and wxGTK do support selective yield of native events coming from the underlying GUI toolkit. wxWidgets events posted using :meth:`wx.EvtHandler.AddPendingEvent`   or :meth:`wx.EvtHandler.QueueEvent`   are instead selectively processed by all ports. 

                


      :param `eventsToProcess`: 
      :type `eventsToProcess`: long




      :rtype: `bool`







      .. seealso:: :meth:`wx.Event.GetEventCategory`     







