# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_iDynTree')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_iDynTree')
    _iDynTree = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_iDynTree', [dirname(__file__)])
        except ImportError:
            import _iDynTree
            return _iDynTree
        try:
            _mod = imp.load_module('_iDynTree', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _iDynTree = swig_import_helper()
    del swig_import_helper
else:
    import _iDynTree
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _iDynTree.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _iDynTree.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _iDynTree.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _iDynTree.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _iDynTree.SwigPyIterator_equal(self, x)

    def copy(self):
        return _iDynTree.SwigPyIterator_copy(self)

    def next(self):
        return _iDynTree.SwigPyIterator_next(self)

    def __next__(self):
        return _iDynTree.SwigPyIterator___next__(self)

    def previous(self):
        return _iDynTree.SwigPyIterator_previous(self)

    def advance(self, n):
        return _iDynTree.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _iDynTree.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _iDynTree.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _iDynTree.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _iDynTree.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _iDynTree.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _iDynTree.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _iDynTree.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.StringVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.StringVector___bool__(self)

    def __len__(self):
        return _iDynTree.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.StringVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.StringVector_pop(self)

    def append(self, x):
        return _iDynTree.StringVector_append(self, x)

    def empty(self):
        return _iDynTree.StringVector_empty(self)

    def size(self):
        return _iDynTree.StringVector_size(self)

    def swap(self, v):
        return _iDynTree.StringVector_swap(self, v)

    def begin(self):
        return _iDynTree.StringVector_begin(self)

    def end(self):
        return _iDynTree.StringVector_end(self)

    def rbegin(self):
        return _iDynTree.StringVector_rbegin(self)

    def rend(self):
        return _iDynTree.StringVector_rend(self)

    def clear(self):
        return _iDynTree.StringVector_clear(self)

    def get_allocator(self):
        return _iDynTree.StringVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.StringVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.StringVector_push_back(self, x)

    def front(self):
        return _iDynTree.StringVector_front(self)

    def back(self):
        return _iDynTree.StringVector_back(self)

    def assign(self, n, x):
        return _iDynTree.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.StringVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.StringVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.StringVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.StringVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _iDynTree.StringVector_swigregister
StringVector_swigregister(StringVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.IntVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.IntVector___bool__(self)

    def __len__(self):
        return _iDynTree.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.IntVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.IntVector_pop(self)

    def append(self, x):
        return _iDynTree.IntVector_append(self, x)

    def empty(self):
        return _iDynTree.IntVector_empty(self)

    def size(self):
        return _iDynTree.IntVector_size(self)

    def swap(self, v):
        return _iDynTree.IntVector_swap(self, v)

    def begin(self):
        return _iDynTree.IntVector_begin(self)

    def end(self):
        return _iDynTree.IntVector_end(self)

    def rbegin(self):
        return _iDynTree.IntVector_rbegin(self)

    def rend(self):
        return _iDynTree.IntVector_rend(self)

    def clear(self):
        return _iDynTree.IntVector_clear(self)

    def get_allocator(self):
        return _iDynTree.IntVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.IntVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.IntVector_push_back(self, x)

    def front(self):
        return _iDynTree.IntVector_front(self)

    def back(self):
        return _iDynTree.IntVector_back(self)

    def assign(self, n, x):
        return _iDynTree.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.IntVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.IntVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.IntVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.IntVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _iDynTree.IntVector_swigregister
IntVector_swigregister(IntVector)

class BerdySensors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdySensors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdySensors, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.BerdySensors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.BerdySensors___nonzero__(self)

    def __bool__(self):
        return _iDynTree.BerdySensors___bool__(self)

    def __len__(self):
        return _iDynTree.BerdySensors___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.BerdySensors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.BerdySensors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.BerdySensors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.BerdySensors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.BerdySensors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.BerdySensors___setitem__(self, *args)

    def pop(self):
        return _iDynTree.BerdySensors_pop(self)

    def append(self, x):
        return _iDynTree.BerdySensors_append(self, x)

    def empty(self):
        return _iDynTree.BerdySensors_empty(self)

    def size(self):
        return _iDynTree.BerdySensors_size(self)

    def swap(self, v):
        return _iDynTree.BerdySensors_swap(self, v)

    def begin(self):
        return _iDynTree.BerdySensors_begin(self)

    def end(self):
        return _iDynTree.BerdySensors_end(self)

    def rbegin(self):
        return _iDynTree.BerdySensors_rbegin(self)

    def rend(self):
        return _iDynTree.BerdySensors_rend(self)

    def clear(self):
        return _iDynTree.BerdySensors_clear(self)

    def get_allocator(self):
        return _iDynTree.BerdySensors_get_allocator(self)

    def pop_back(self):
        return _iDynTree.BerdySensors_pop_back(self)

    def erase(self, *args):
        return _iDynTree.BerdySensors_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_BerdySensors(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.BerdySensors_push_back(self, x)

    def front(self):
        return _iDynTree.BerdySensors_front(self)

    def back(self):
        return _iDynTree.BerdySensors_back(self)

    def assign(self, n, x):
        return _iDynTree.BerdySensors_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.BerdySensors_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.BerdySensors_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.BerdySensors_reserve(self, n)

    def capacity(self):
        return _iDynTree.BerdySensors_capacity(self)
    __swig_destroy__ = _iDynTree.delete_BerdySensors
    __del__ = lambda self: None
BerdySensors_swigregister = _iDynTree.BerdySensors_swigregister
BerdySensors_swigregister(BerdySensors)

class BerdyDynamicVariables(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdyDynamicVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdyDynamicVariables, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.BerdyDynamicVariables_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.BerdyDynamicVariables___nonzero__(self)

    def __bool__(self):
        return _iDynTree.BerdyDynamicVariables___bool__(self)

    def __len__(self):
        return _iDynTree.BerdyDynamicVariables___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.BerdyDynamicVariables___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.BerdyDynamicVariables___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.BerdyDynamicVariables___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___setitem__(self, *args)

    def pop(self):
        return _iDynTree.BerdyDynamicVariables_pop(self)

    def append(self, x):
        return _iDynTree.BerdyDynamicVariables_append(self, x)

    def empty(self):
        return _iDynTree.BerdyDynamicVariables_empty(self)

    def size(self):
        return _iDynTree.BerdyDynamicVariables_size(self)

    def swap(self, v):
        return _iDynTree.BerdyDynamicVariables_swap(self, v)

    def begin(self):
        return _iDynTree.BerdyDynamicVariables_begin(self)

    def end(self):
        return _iDynTree.BerdyDynamicVariables_end(self)

    def rbegin(self):
        return _iDynTree.BerdyDynamicVariables_rbegin(self)

    def rend(self):
        return _iDynTree.BerdyDynamicVariables_rend(self)

    def clear(self):
        return _iDynTree.BerdyDynamicVariables_clear(self)

    def get_allocator(self):
        return _iDynTree.BerdyDynamicVariables_get_allocator(self)

    def pop_back(self):
        return _iDynTree.BerdyDynamicVariables_pop_back(self)

    def erase(self, *args):
        return _iDynTree.BerdyDynamicVariables_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_BerdyDynamicVariables(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.BerdyDynamicVariables_push_back(self, x)

    def front(self):
        return _iDynTree.BerdyDynamicVariables_front(self)

    def back(self):
        return _iDynTree.BerdyDynamicVariables_back(self)

    def assign(self, n, x):
        return _iDynTree.BerdyDynamicVariables_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.BerdyDynamicVariables_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.BerdyDynamicVariables_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.BerdyDynamicVariables_reserve(self, n)

    def capacity(self):
        return _iDynTree.BerdyDynamicVariables_capacity(self)
    __swig_destroy__ = _iDynTree.delete_BerdyDynamicVariables
    __del__ = lambda self: None
BerdyDynamicVariables_swigregister = _iDynTree.BerdyDynamicVariables_swigregister
BerdyDynamicVariables_swigregister(BerdyDynamicVariables)


def reportInfo(className, methodName, message):
    return _iDynTree.reportInfo(className, methodName, message)
reportInfo = _iDynTree.reportInfo

def reportDebug(className, methodName, message):
    return _iDynTree.reportDebug(className, methodName, message)
reportDebug = _iDynTree.reportDebug
class IndexRange(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexRange, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexRange, name)
    __repr__ = _swig_repr
    __swig_setmethods__["offset"] = _iDynTree.IndexRange_offset_set
    __swig_getmethods__["offset"] = _iDynTree.IndexRange_offset_get
    if _newclass:
        offset = _swig_property(_iDynTree.IndexRange_offset_get, _iDynTree.IndexRange_offset_set)
    __swig_setmethods__["size"] = _iDynTree.IndexRange_size_set
    __swig_getmethods__["size"] = _iDynTree.IndexRange_size_get
    if _newclass:
        size = _swig_property(_iDynTree.IndexRange_size_get, _iDynTree.IndexRange_size_set)

    def isValid(self):
        return _iDynTree.IndexRange_isValid(self)
    if _newclass:
        InvalidRange = staticmethod(_iDynTree.IndexRange_InvalidRange)
    else:
        InvalidRange = _iDynTree.IndexRange_InvalidRange

    def __init__(self):
        this = _iDynTree.new_IndexRange()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_IndexRange
    __del__ = lambda self: None
IndexRange_swigregister = _iDynTree.IndexRange_swigregister
IndexRange_swigregister(IndexRange)

def IndexRange_InvalidRange():
    return _iDynTree.IndexRange_InvalidRange()
IndexRange_InvalidRange = _iDynTree.IndexRange_InvalidRange

RowMajor = _iDynTree.RowMajor
ColumnMajor = _iDynTree.ColumnMajor

def checkDoublesAreEqual(*args):
    return _iDynTree.checkDoublesAreEqual(*args)
checkDoublesAreEqual = _iDynTree.checkDoublesAreEqual
class MatrixDynSize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixDynSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixDynSize, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_MatrixDynSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_MatrixDynSize
    __del__ = lambda self: None

    def __call__(self, *args):
        return _iDynTree.MatrixDynSize___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.MatrixDynSize_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.MatrixDynSize_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.MatrixDynSize_rows(self)

    def cols(self):
        return _iDynTree.MatrixDynSize_cols(self)

    def data(self):
        return _iDynTree.MatrixDynSize_data(self)

    def zero(self):
        return _iDynTree.MatrixDynSize_zero(self)

    def resize(self, _newRows, _newCols):
        return _iDynTree.MatrixDynSize_resize(self, _newRows, _newCols)

    def reserve(self, _newCapacity):
        return _iDynTree.MatrixDynSize_reserve(self, _newCapacity)

    def capacity(self):
        return _iDynTree.MatrixDynSize_capacity(self)

    def shrink_to_fit(self):
        return _iDynTree.MatrixDynSize_shrink_to_fit(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.MatrixDynSize_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.MatrixDynSize_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.MatrixDynSize_toString(self)

    def __str__(self):
        return _iDynTree.MatrixDynSize___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.MatrixDynSize_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.MatrixDynSize_FromPython)
    else:
        FromPython = _iDynTree.MatrixDynSize_FromPython
MatrixDynSize_swigregister = _iDynTree.MatrixDynSize_swigregister
MatrixDynSize_swigregister(MatrixDynSize)

def MatrixDynSize_FromPython(arg2):
    return _iDynTree.MatrixDynSize_FromPython(arg2)
MatrixDynSize_FromPython = _iDynTree.MatrixDynSize_FromPython

class SparseMatrixRowMajor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseMatrixRowMajor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparseMatrixRowMajor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SparseMatrixRowMajor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SparseMatrixRowMajor
    __del__ = lambda self: None

    def numberOfNonZeros(self):
        return _iDynTree.SparseMatrixRowMajor_numberOfNonZeros(self)

    def resize(self, *args):
        return _iDynTree.SparseMatrixRowMajor_resize(self, *args)

    def reserve(self, nonZeroElements):
        return _iDynTree.SparseMatrixRowMajor_reserve(self, nonZeroElements)

    def zero(self):
        return _iDynTree.SparseMatrixRowMajor_zero(self)

    def setFromConstTriplets(self, triplets):
        return _iDynTree.SparseMatrixRowMajor_setFromConstTriplets(self, triplets)

    def setFromTriplets(self, triplets):
        return _iDynTree.SparseMatrixRowMajor_setFromTriplets(self, triplets)
    if _newclass:
        sparseMatrixFromTriplets = staticmethod(_iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets)
    else:
        sparseMatrixFromTriplets = _iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets

    def __call__(self, *args):
        return _iDynTree.SparseMatrixRowMajor___call__(self, *args)

    def getValue(self, row, col):
        return _iDynTree.SparseMatrixRowMajor_getValue(self, row, col)

    def setValue(self, row, col, newValue):
        return _iDynTree.SparseMatrixRowMajor_setValue(self, row, col, newValue)

    def rows(self):
        return _iDynTree.SparseMatrixRowMajor_rows(self)

    def columns(self):
        return _iDynTree.SparseMatrixRowMajor_columns(self)

    def description(self, fullMatrix=False):
        return _iDynTree.SparseMatrixRowMajor_description(self, fullMatrix)
SparseMatrixRowMajor_swigregister = _iDynTree.SparseMatrixRowMajor_swigregister
SparseMatrixRowMajor_swigregister(SparseMatrixRowMajor)

def SparseMatrixRowMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements):
    return _iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)
SparseMatrixRowMajor_sparseMatrixFromTriplets = _iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets

class SparseMatrixColMajor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseMatrixColMajor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparseMatrixColMajor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SparseMatrixColMajor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SparseMatrixColMajor
    __del__ = lambda self: None

    def numberOfNonZeros(self):
        return _iDynTree.SparseMatrixColMajor_numberOfNonZeros(self)

    def resize(self, *args):
        return _iDynTree.SparseMatrixColMajor_resize(self, *args)

    def reserve(self, nonZeroElements):
        return _iDynTree.SparseMatrixColMajor_reserve(self, nonZeroElements)

    def zero(self):
        return _iDynTree.SparseMatrixColMajor_zero(self)

    def setFromConstTriplets(self, triplets):
        return _iDynTree.SparseMatrixColMajor_setFromConstTriplets(self, triplets)

    def setFromTriplets(self, triplets):
        return _iDynTree.SparseMatrixColMajor_setFromTriplets(self, triplets)
    if _newclass:
        sparseMatrixFromTriplets = staticmethod(_iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets)
    else:
        sparseMatrixFromTriplets = _iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets

    def __call__(self, *args):
        return _iDynTree.SparseMatrixColMajor___call__(self, *args)

    def getValue(self, row, col):
        return _iDynTree.SparseMatrixColMajor_getValue(self, row, col)

    def setValue(self, row, col, newValue):
        return _iDynTree.SparseMatrixColMajor_setValue(self, row, col, newValue)

    def rows(self):
        return _iDynTree.SparseMatrixColMajor_rows(self)

    def columns(self):
        return _iDynTree.SparseMatrixColMajor_columns(self)

    def description(self, fullMatrix=False):
        return _iDynTree.SparseMatrixColMajor_description(self, fullMatrix)
SparseMatrixColMajor_swigregister = _iDynTree.SparseMatrixColMajor_swigregister
SparseMatrixColMajor_swigregister(SparseMatrixColMajor)

def SparseMatrixColMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements):
    return _iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)
SparseMatrixColMajor_sparseMatrixFromTriplets = _iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets

class VectorDynSize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorDynSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorDynSize, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_VectorDynSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_VectorDynSize
    __del__ = lambda self: None

    def __call__(self, *args):
        return _iDynTree.VectorDynSize___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.VectorDynSize_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.VectorDynSize_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.VectorDynSize_cbegin(self)

    def cend(self):
        return _iDynTree.VectorDynSize_cend(self)

    def begin(self, *args):
        return _iDynTree.VectorDynSize_begin(self, *args)

    def end(self, *args):
        return _iDynTree.VectorDynSize_end(self, *args)

    def size(self):
        return _iDynTree.VectorDynSize_size(self)

    def data(self):
        return _iDynTree.VectorDynSize_data(self)

    def zero(self):
        return _iDynTree.VectorDynSize_zero(self)

    def reserve(self, newCapacity):
        return _iDynTree.VectorDynSize_reserve(self, newCapacity)

    def resize(self, newSize):
        return _iDynTree.VectorDynSize_resize(self, newSize)

    def shrink_to_fit(self):
        return _iDynTree.VectorDynSize_shrink_to_fit(self)

    def capacity(self):
        return _iDynTree.VectorDynSize_capacity(self)

    def fillBuffer(self, buf):
        return _iDynTree.VectorDynSize_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.VectorDynSize_toString(self)

    def __str__(self):
        return _iDynTree.VectorDynSize___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.VectorDynSize_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.VectorDynSize_FromPython)
    else:
        FromPython = _iDynTree.VectorDynSize_FromPython
VectorDynSize_swigregister = _iDynTree.VectorDynSize_swigregister
VectorDynSize_swigregister(VectorDynSize)

def VectorDynSize_FromPython(arg2):
    return _iDynTree.VectorDynSize_FromPython(arg2)
VectorDynSize_FromPython = _iDynTree.VectorDynSize_FromPython

class Matrix1x6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix1x6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix1x6, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix1x6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix1x6___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix1x6_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix1x6_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix1x6_rows(self)

    def cols(self):
        return _iDynTree.Matrix1x6_cols(self)

    def data(self):
        return _iDynTree.Matrix1x6_data(self)

    def zero(self):
        return _iDynTree.Matrix1x6_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix1x6_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix1x6_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix1x6_toString(self)

    def __str__(self):
        return _iDynTree.Matrix1x6___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix1x6_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix1x6_FromPython)
    else:
        FromPython = _iDynTree.Matrix1x6_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix1x6
    __del__ = lambda self: None
Matrix1x6_swigregister = _iDynTree.Matrix1x6_swigregister
Matrix1x6_swigregister(Matrix1x6)

def Matrix1x6_FromPython(arg2):
    return _iDynTree.Matrix1x6_FromPython(arg2)
Matrix1x6_FromPython = _iDynTree.Matrix1x6_FromPython

class Matrix2x3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix2x3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix2x3, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix2x3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix2x3___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix2x3_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix2x3_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix2x3_rows(self)

    def cols(self):
        return _iDynTree.Matrix2x3_cols(self)

    def data(self):
        return _iDynTree.Matrix2x3_data(self)

    def zero(self):
        return _iDynTree.Matrix2x3_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix2x3_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix2x3_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix2x3_toString(self)

    def __str__(self):
        return _iDynTree.Matrix2x3___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix2x3_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix2x3_FromPython)
    else:
        FromPython = _iDynTree.Matrix2x3_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix2x3
    __del__ = lambda self: None
Matrix2x3_swigregister = _iDynTree.Matrix2x3_swigregister
Matrix2x3_swigregister(Matrix2x3)

def Matrix2x3_FromPython(arg2):
    return _iDynTree.Matrix2x3_FromPython(arg2)
Matrix2x3_FromPython = _iDynTree.Matrix2x3_FromPython

class Matrix3x3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix3x3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix3x3, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix3x3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix3x3___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix3x3_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix3x3_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix3x3_rows(self)

    def cols(self):
        return _iDynTree.Matrix3x3_cols(self)

    def data(self):
        return _iDynTree.Matrix3x3_data(self)

    def zero(self):
        return _iDynTree.Matrix3x3_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix3x3_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix3x3_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix3x3_toString(self)

    def __str__(self):
        return _iDynTree.Matrix3x3___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix3x3_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix3x3_FromPython)
    else:
        FromPython = _iDynTree.Matrix3x3_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix3x3
    __del__ = lambda self: None
Matrix3x3_swigregister = _iDynTree.Matrix3x3_swigregister
Matrix3x3_swigregister(Matrix3x3)

def Matrix3x3_FromPython(arg2):
    return _iDynTree.Matrix3x3_FromPython(arg2)
Matrix3x3_FromPython = _iDynTree.Matrix3x3_FromPython

class Matrix4x4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix4x4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix4x4, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix4x4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix4x4___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix4x4_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix4x4_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix4x4_rows(self)

    def cols(self):
        return _iDynTree.Matrix4x4_cols(self)

    def data(self):
        return _iDynTree.Matrix4x4_data(self)

    def zero(self):
        return _iDynTree.Matrix4x4_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix4x4_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix4x4_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix4x4_toString(self)

    def __str__(self):
        return _iDynTree.Matrix4x4___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix4x4_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix4x4_FromPython)
    else:
        FromPython = _iDynTree.Matrix4x4_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix4x4
    __del__ = lambda self: None
Matrix4x4_swigregister = _iDynTree.Matrix4x4_swigregister
Matrix4x4_swigregister(Matrix4x4)

def Matrix4x4_FromPython(arg2):
    return _iDynTree.Matrix4x4_FromPython(arg2)
Matrix4x4_FromPython = _iDynTree.Matrix4x4_FromPython

class Matrix6x6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix6x6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix6x6, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix6x6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix6x6___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix6x6_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix6x6_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix6x6_rows(self)

    def cols(self):
        return _iDynTree.Matrix6x6_cols(self)

    def data(self):
        return _iDynTree.Matrix6x6_data(self)

    def zero(self):
        return _iDynTree.Matrix6x6_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix6x6_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix6x6_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix6x6_toString(self)

    def __str__(self):
        return _iDynTree.Matrix6x6___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix6x6_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix6x6_FromPython)
    else:
        FromPython = _iDynTree.Matrix6x6_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix6x6
    __del__ = lambda self: None
Matrix6x6_swigregister = _iDynTree.Matrix6x6_swigregister
Matrix6x6_swigregister(Matrix6x6)

def Matrix6x6_FromPython(arg2):
    return _iDynTree.Matrix6x6_FromPython(arg2)
Matrix6x6_FromPython = _iDynTree.Matrix6x6_FromPython

class Matrix6x10(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix6x10, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix6x10, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix6x10(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix6x10___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix6x10_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix6x10_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix6x10_rows(self)

    def cols(self):
        return _iDynTree.Matrix6x10_cols(self)

    def data(self):
        return _iDynTree.Matrix6x10_data(self)

    def zero(self):
        return _iDynTree.Matrix6x10_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix6x10_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix6x10_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix6x10_toString(self)

    def __str__(self):
        return _iDynTree.Matrix6x10___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix6x10_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix6x10_FromPython)
    else:
        FromPython = _iDynTree.Matrix6x10_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix6x10
    __del__ = lambda self: None
Matrix6x10_swigregister = _iDynTree.Matrix6x10_swigregister
Matrix6x10_swigregister(Matrix6x10)

def Matrix6x10_FromPython(arg2):
    return _iDynTree.Matrix6x10_FromPython(arg2)
Matrix6x10_FromPython = _iDynTree.Matrix6x10_FromPython

class Matrix10x16(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix10x16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix10x16, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Matrix10x16(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Matrix10x16___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix10x16_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix10x16_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix10x16_rows(self)

    def cols(self):
        return _iDynTree.Matrix10x16_cols(self)

    def data(self):
        return _iDynTree.Matrix10x16_data(self)

    def zero(self):
        return _iDynTree.Matrix10x16_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix10x16_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix10x16_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix10x16_toString(self)

    def __str__(self):
        return _iDynTree.Matrix10x16___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix10x16_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Matrix10x16_FromPython)
    else:
        FromPython = _iDynTree.Matrix10x16_FromPython
    __swig_destroy__ = _iDynTree.delete_Matrix10x16
    __del__ = lambda self: None
Matrix10x16_swigregister = _iDynTree.Matrix10x16_swigregister
Matrix10x16_swigregister(Matrix10x16)

def Matrix10x16_FromPython(arg2):
    return _iDynTree.Matrix10x16_FromPython(arg2)
Matrix10x16_FromPython = _iDynTree.Matrix10x16_FromPython

class Vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Vector3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Vector3___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector3_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector3_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector3_cbegin(self)

    def cend(self):
        return _iDynTree.Vector3_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector3_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector3_end(self, *args)

    def size(self):
        return _iDynTree.Vector3_size(self)

    def data(self):
        return _iDynTree.Vector3_data(self)

    def zero(self):
        return _iDynTree.Vector3_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector3_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector3_toString(self)

    def __str__(self):
        return _iDynTree.Vector3___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector3_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Vector3_FromPython)
    else:
        FromPython = _iDynTree.Vector3_FromPython
    __swig_destroy__ = _iDynTree.delete_Vector3
    __del__ = lambda self: None
Vector3_swigregister = _iDynTree.Vector3_swigregister
Vector3_swigregister(Vector3)

def Vector3_FromPython(arg2):
    return _iDynTree.Vector3_FromPython(arg2)
Vector3_FromPython = _iDynTree.Vector3_FromPython

class Vector4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector4, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Vector4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Vector4___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector4_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector4_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector4_cbegin(self)

    def cend(self):
        return _iDynTree.Vector4_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector4_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector4_end(self, *args)

    def size(self):
        return _iDynTree.Vector4_size(self)

    def data(self):
        return _iDynTree.Vector4_data(self)

    def zero(self):
        return _iDynTree.Vector4_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector4_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector4_toString(self)

    def __str__(self):
        return _iDynTree.Vector4___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector4_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Vector4_FromPython)
    else:
        FromPython = _iDynTree.Vector4_FromPython
    __swig_destroy__ = _iDynTree.delete_Vector4
    __del__ = lambda self: None
Vector4_swigregister = _iDynTree.Vector4_swigregister
Vector4_swigregister(Vector4)

def Vector4_FromPython(arg2):
    return _iDynTree.Vector4_FromPython(arg2)
Vector4_FromPython = _iDynTree.Vector4_FromPython

class Vector6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector6, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Vector6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Vector6___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector6_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector6_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector6_cbegin(self)

    def cend(self):
        return _iDynTree.Vector6_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector6_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector6_end(self, *args)

    def size(self):
        return _iDynTree.Vector6_size(self)

    def data(self):
        return _iDynTree.Vector6_data(self)

    def zero(self):
        return _iDynTree.Vector6_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector6_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector6_toString(self)

    def __str__(self):
        return _iDynTree.Vector6___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector6_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Vector6_FromPython)
    else:
        FromPython = _iDynTree.Vector6_FromPython
    __swig_destroy__ = _iDynTree.delete_Vector6
    __del__ = lambda self: None
Vector6_swigregister = _iDynTree.Vector6_swigregister
Vector6_swigregister(Vector6)

def Vector6_FromPython(arg2):
    return _iDynTree.Vector6_FromPython(arg2)
Vector6_FromPython = _iDynTree.Vector6_FromPython

class Vector10(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector10, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector10, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Vector10(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Vector10___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector10_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector10_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector10_cbegin(self)

    def cend(self):
        return _iDynTree.Vector10_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector10_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector10_end(self, *args)

    def size(self):
        return _iDynTree.Vector10_size(self)

    def data(self):
        return _iDynTree.Vector10_data(self)

    def zero(self):
        return _iDynTree.Vector10_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector10_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector10_toString(self)

    def __str__(self):
        return _iDynTree.Vector10___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector10_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Vector10_FromPython)
    else:
        FromPython = _iDynTree.Vector10_FromPython
    __swig_destroy__ = _iDynTree.delete_Vector10
    __del__ = lambda self: None
Vector10_swigregister = _iDynTree.Vector10_swigregister
Vector10_swigregister(Vector10)

def Vector10_FromPython(arg2):
    return _iDynTree.Vector10_FromPython(arg2)
Vector10_FromPython = _iDynTree.Vector10_FromPython

class Vector16(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector16, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Vector16(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args):
        return _iDynTree.Vector16___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector16_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector16_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector16_cbegin(self)

    def cend(self):
        return _iDynTree.Vector16_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector16_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector16_end(self, *args)

    def size(self):
        return _iDynTree.Vector16_size(self)

    def data(self):
        return _iDynTree.Vector16_data(self)

    def zero(self):
        return _iDynTree.Vector16_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector16_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector16_toString(self)

    def __str__(self):
        return _iDynTree.Vector16___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector16_toNumPy(self)
    if _newclass:
        FromPython = staticmethod(_iDynTree.Vector16_FromPython)
    else:
        FromPython = _iDynTree.Vector16_FromPython
    __swig_destroy__ = _iDynTree.delete_Vector16
    __del__ = lambda self: None
Vector16_swigregister = _iDynTree.Vector16_swigregister
Vector16_swigregister(Vector16)

def Vector16_FromPython(arg2):
    return _iDynTree.Vector16_FromPython(arg2)
Vector16_FromPython = _iDynTree.Vector16_FromPython

class PositionRaw(Vector3):
    __swig_setmethods__ = {}
    for _s in [Vector3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PositionRaw, name, value)
    __swig_getmethods__ = {}
    for _s in [Vector3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PositionRaw, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_PositionRaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changePoint(self, newPoint):
        return _iDynTree.PositionRaw_changePoint(self, newPoint)

    def changeRefPoint(self, newRefPoint):
        return _iDynTree.PositionRaw_changeRefPoint(self, newRefPoint)
    if _newclass:
        compose = staticmethod(_iDynTree.PositionRaw_compose)
    else:
        compose = _iDynTree.PositionRaw_compose
    if _newclass:
        inverse = staticmethod(_iDynTree.PositionRaw_inverse)
    else:
        inverse = _iDynTree.PositionRaw_inverse

    def changePointOf(self, *args):
        return _iDynTree.PositionRaw_changePointOf(self, *args)

    def toString(self):
        return _iDynTree.PositionRaw_toString(self)

    def __str__(self):
        return _iDynTree.PositionRaw___str__(self)
    __swig_destroy__ = _iDynTree.delete_PositionRaw
    __del__ = lambda self: None
PositionRaw_swigregister = _iDynTree.PositionRaw_swigregister
PositionRaw_swigregister(PositionRaw)

def PositionRaw_compose(op1, op2):
    return _iDynTree.PositionRaw_compose(op1, op2)
PositionRaw_compose = _iDynTree.PositionRaw_compose

def PositionRaw_inverse(op):
    return _iDynTree.PositionRaw_inverse(op)
PositionRaw_inverse = _iDynTree.PositionRaw_inverse

class Position(PositionRaw):
    __swig_setmethods__ = {}
    for _s in [PositionRaw]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Position, name, value)
    __swig_getmethods__ = {}
    for _s in [PositionRaw]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Position, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Position(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changePoint(self, newPoint):
        return _iDynTree.Position_changePoint(self, newPoint)

    def changeRefPoint(self, newRefPoint):
        return _iDynTree.Position_changeRefPoint(self, newRefPoint)

    def changeCoordinateFrame(self, newCoordinateFrame):
        return _iDynTree.Position_changeCoordinateFrame(self, newCoordinateFrame)
    if _newclass:
        compose = staticmethod(_iDynTree.Position_compose)
    else:
        compose = _iDynTree.Position_compose
    if _newclass:
        inverse = staticmethod(_iDynTree.Position_inverse)
    else:
        inverse = _iDynTree.Position_inverse

    def changePointOf(self, *args):
        return _iDynTree.Position_changePointOf(self, *args)

    def __add__(self, other):
        return _iDynTree.Position___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Position___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Position___neg__(self)

    def __mul__(self, *args):
        return _iDynTree.Position___mul__(self, *args)

    def toString(self):
        return _iDynTree.Position_toString(self)

    def __str__(self):
        return _iDynTree.Position___str__(self)
    if _newclass:
        Zero = staticmethod(_iDynTree.Position_Zero)
    else:
        Zero = _iDynTree.Position_Zero
    __swig_destroy__ = _iDynTree.delete_Position
    __del__ = lambda self: None
Position_swigregister = _iDynTree.Position_swigregister
Position_swigregister(Position)

def Position_compose(op1, op2):
    return _iDynTree.Position_compose(op1, op2)
Position_compose = _iDynTree.Position_compose

def Position_inverse(op):
    return _iDynTree.Position_inverse(op)
Position_inverse = _iDynTree.Position_inverse

def Position_Zero():
    return _iDynTree.Position_Zero()
Position_Zero = _iDynTree.Position_Zero

class GeomVector3(Vector3):
    __swig_setmethods__ = {}
    for _s in [Vector3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeomVector3, name, value)
    __swig_getmethods__ = {}
    for _s in [Vector3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeomVector3, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_GeomVector3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.GeomVector3_changeCoordFrame(self, newCoordFrame)

    def compose(self, op1, op2):
        return _iDynTree.GeomVector3_compose(self, op1, op2)

    def inverse(self, op):
        return _iDynTree.GeomVector3_inverse(self, op)

    def dot(self, other):
        return _iDynTree.GeomVector3_dot(self, other)

    def __add__(self, other):
        return _iDynTree.GeomVector3___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.GeomVector3___sub__(self, other)

    def __neg__(self):
        return _iDynTree.GeomVector3___neg__(self)

    def exp(self):
        return _iDynTree.GeomVector3_exp(self)

    def cross(self, other):
        return _iDynTree.GeomVector3_cross(self, other)
    __swig_destroy__ = _iDynTree.delete_GeomVector3
    __del__ = lambda self: None
GeomVector3_swigregister = _iDynTree.GeomVector3_swigregister
GeomVector3_swigregister(GeomVector3)

class SpatialMotionVectorBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialMotionVectorBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialMotionVectorBase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialMotionVectorBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getLinearVec3(self):
        return _iDynTree.SpatialMotionVectorBase_getLinearVec3(self)

    def getAngularVec3(self):
        return _iDynTree.SpatialMotionVectorBase_getAngularVec3(self)

    def setLinearVec3(self, _linearVec3):
        return _iDynTree.SpatialMotionVectorBase_setLinearVec3(self, _linearVec3)

    def setAngularVec3(self, _angularVec3):
        return _iDynTree.SpatialMotionVectorBase_setAngularVec3(self, _angularVec3)

    def __call__(self, index):
        return _iDynTree.SpatialMotionVectorBase___call__(self, index)

    def getVal(self, index):
        return _iDynTree.SpatialMotionVectorBase_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.SpatialMotionVectorBase_setVal(self, index, new_el)

    def size(self):
        return _iDynTree.SpatialMotionVectorBase_size(self)

    def zero(self):
        return _iDynTree.SpatialMotionVectorBase_zero(self)

    def changePoint(self, newPoint):
        return _iDynTree.SpatialMotionVectorBase_changePoint(self, newPoint)

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.SpatialMotionVectorBase_changeCoordFrame(self, newCoordFrame)
    if _newclass:
        compose = staticmethod(_iDynTree.SpatialMotionVectorBase_compose)
    else:
        compose = _iDynTree.SpatialMotionVectorBase_compose
    if _newclass:
        inverse = staticmethod(_iDynTree.SpatialMotionVectorBase_inverse)
    else:
        inverse = _iDynTree.SpatialMotionVectorBase_inverse

    def dot(self, other):
        return _iDynTree.SpatialMotionVectorBase_dot(self, other)

    def __add__(self, other):
        return _iDynTree.SpatialMotionVectorBase___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialMotionVectorBase___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialMotionVectorBase___neg__(self)
    if _newclass:
        Zero = staticmethod(_iDynTree.SpatialMotionVectorBase_Zero)
    else:
        Zero = _iDynTree.SpatialMotionVectorBase_Zero

    def asVector(self):
        return _iDynTree.SpatialMotionVectorBase_asVector(self)

    def toString(self):
        return _iDynTree.SpatialMotionVectorBase_toString(self)

    def __str__(self):
        return _iDynTree.SpatialMotionVectorBase___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.SpatialMotionVectorBase_toNumPy(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMotionVectorBase
    __del__ = lambda self: None
SpatialMotionVectorBase_swigregister = _iDynTree.SpatialMotionVectorBase_swigregister
SpatialMotionVectorBase_swigregister(SpatialMotionVectorBase)

def SpatialMotionVectorBase_compose(op1, op2):
    return _iDynTree.SpatialMotionVectorBase_compose(op1, op2)
SpatialMotionVectorBase_compose = _iDynTree.SpatialMotionVectorBase_compose

def SpatialMotionVectorBase_inverse(op):
    return _iDynTree.SpatialMotionVectorBase_inverse(op)
SpatialMotionVectorBase_inverse = _iDynTree.SpatialMotionVectorBase_inverse

def SpatialMotionVectorBase_Zero():
    return _iDynTree.SpatialMotionVectorBase_Zero()
SpatialMotionVectorBase_Zero = _iDynTree.SpatialMotionVectorBase_Zero

class SpatialForceVectorBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialForceVectorBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialForceVectorBase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialForceVectorBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getLinearVec3(self):
        return _iDynTree.SpatialForceVectorBase_getLinearVec3(self)

    def getAngularVec3(self):
        return _iDynTree.SpatialForceVectorBase_getAngularVec3(self)

    def setLinearVec3(self, _linearVec3):
        return _iDynTree.SpatialForceVectorBase_setLinearVec3(self, _linearVec3)

    def setAngularVec3(self, _angularVec3):
        return _iDynTree.SpatialForceVectorBase_setAngularVec3(self, _angularVec3)

    def __call__(self, index):
        return _iDynTree.SpatialForceVectorBase___call__(self, index)

    def getVal(self, index):
        return _iDynTree.SpatialForceVectorBase_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.SpatialForceVectorBase_setVal(self, index, new_el)

    def size(self):
        return _iDynTree.SpatialForceVectorBase_size(self)

    def zero(self):
        return _iDynTree.SpatialForceVectorBase_zero(self)

    def changePoint(self, newPoint):
        return _iDynTree.SpatialForceVectorBase_changePoint(self, newPoint)

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.SpatialForceVectorBase_changeCoordFrame(self, newCoordFrame)
    if _newclass:
        compose = staticmethod(_iDynTree.SpatialForceVectorBase_compose)
    else:
        compose = _iDynTree.SpatialForceVectorBase_compose
    if _newclass:
        inverse = staticmethod(_iDynTree.SpatialForceVectorBase_inverse)
    else:
        inverse = _iDynTree.SpatialForceVectorBase_inverse

    def dot(self, other):
        return _iDynTree.SpatialForceVectorBase_dot(self, other)

    def __add__(self, other):
        return _iDynTree.SpatialForceVectorBase___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialForceVectorBase___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialForceVectorBase___neg__(self)
    if _newclass:
        Zero = staticmethod(_iDynTree.SpatialForceVectorBase_Zero)
    else:
        Zero = _iDynTree.SpatialForceVectorBase_Zero

    def asVector(self):
        return _iDynTree.SpatialForceVectorBase_asVector(self)

    def toString(self):
        return _iDynTree.SpatialForceVectorBase_toString(self)

    def __str__(self):
        return _iDynTree.SpatialForceVectorBase___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.SpatialForceVectorBase_toNumPy(self)
    __swig_destroy__ = _iDynTree.delete_SpatialForceVectorBase
    __del__ = lambda self: None
SpatialForceVectorBase_swigregister = _iDynTree.SpatialForceVectorBase_swigregister
SpatialForceVectorBase_swigregister(SpatialForceVectorBase)

def SpatialForceVectorBase_compose(op1, op2):
    return _iDynTree.SpatialForceVectorBase_compose(op1, op2)
SpatialForceVectorBase_compose = _iDynTree.SpatialForceVectorBase_compose

def SpatialForceVectorBase_inverse(op):
    return _iDynTree.SpatialForceVectorBase_inverse(op)
SpatialForceVectorBase_inverse = _iDynTree.SpatialForceVectorBase_inverse

def SpatialForceVectorBase_Zero():
    return _iDynTree.SpatialForceVectorBase_Zero()
SpatialForceVectorBase_Zero = _iDynTree.SpatialForceVectorBase_Zero

class Dummy(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dummy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dummy, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_Dummy()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_Dummy
    __del__ = lambda self: None
Dummy_swigregister = _iDynTree.Dummy_swigregister
Dummy_swigregister(Dummy)

class SpatialMotionVector(SpatialMotionVectorBase):
    __swig_setmethods__ = {}
    for _s in [SpatialMotionVectorBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialMotionVector, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialMotionVectorBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialMotionVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialMotionVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __mul__(self, scalar):
        return _iDynTree.SpatialMotionVector___mul__(self, scalar)

    def cross(self, *args):
        return _iDynTree.SpatialMotionVector_cross(self, *args)

    def asCrossProductMatrix(self):
        return _iDynTree.SpatialMotionVector_asCrossProductMatrix(self)

    def asCrossProductMatrixWrench(self):
        return _iDynTree.SpatialMotionVector_asCrossProductMatrixWrench(self)

    def exp(self):
        return _iDynTree.SpatialMotionVector_exp(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMotionVector
    __del__ = lambda self: None
SpatialMotionVector_swigregister = _iDynTree.SpatialMotionVector_swigregister
SpatialMotionVector_swigregister(SpatialMotionVector)

class SpatialForceVector(SpatialForceVectorBase):
    __swig_setmethods__ = {}
    for _s in [SpatialForceVectorBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialForceVector, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialForceVectorBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialForceVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialForceVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SpatialForceVector
    __del__ = lambda self: None

    def __mul__(self, scalar):
        return _iDynTree.SpatialForceVector___mul__(self, scalar)
SpatialForceVector_swigregister = _iDynTree.SpatialForceVector_swigregister
SpatialForceVector_swigregister(SpatialForceVector)

class Twist(SpatialMotionVector):
    __swig_setmethods__ = {}
    for _s in [SpatialMotionVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Twist, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialMotionVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Twist, name)
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.Twist___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Twist___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Twist___neg__(self)

    def __mul__(self, *args):
        return _iDynTree.Twist___mul__(self, *args)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        this = _iDynTree.new_Twist(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        FromPython = staticmethod(_iDynTree.Twist_FromPython)
    else:
        FromPython = _iDynTree.Twist_FromPython
    __swig_destroy__ = _iDynTree.delete_Twist
    __del__ = lambda self: None
Twist_swigregister = _iDynTree.Twist_swigregister
Twist_swigregister(Twist)

def Twist_FromPython(arg2):
    return _iDynTree.Twist_FromPython(arg2)
Twist_FromPython = _iDynTree.Twist_FromPython

class Wrench(SpatialForceVector):
    __swig_setmethods__ = {}
    for _s in [SpatialForceVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Wrench, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialForceVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Wrench, name)
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.Wrench___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Wrench___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Wrench___neg__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        this = _iDynTree.new_Wrench(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        FromPython = staticmethod(_iDynTree.Wrench_FromPython)
    else:
        FromPython = _iDynTree.Wrench_FromPython
    __swig_destroy__ = _iDynTree.delete_Wrench
    __del__ = lambda self: None
Wrench_swigregister = _iDynTree.Wrench_swigregister
Wrench_swigregister(Wrench)

def Wrench_FromPython(arg2):
    return _iDynTree.Wrench_FromPython(arg2)
Wrench_FromPython = _iDynTree.Wrench_FromPython

class SpatialMomentum(SpatialForceVector):
    __swig_setmethods__ = {}
    for _s in [SpatialForceVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialMomentum, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialForceVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialMomentum, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialMomentum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __add__(self, other):
        return _iDynTree.SpatialMomentum___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialMomentum___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialMomentum___neg__(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMomentum
    __del__ = lambda self: None
SpatialMomentum_swigregister = _iDynTree.SpatialMomentum_swigregister
SpatialMomentum_swigregister(SpatialMomentum)

class SpatialAcc(SpatialMotionVector):
    __swig_setmethods__ = {}
    for _s in [SpatialMotionVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialAcc, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialMotionVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialAcc, name)
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.SpatialAcc___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialAcc___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialAcc___neg__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        this = _iDynTree.new_SpatialAcc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        FromPython = staticmethod(_iDynTree.SpatialAcc_FromPython)
    else:
        FromPython = _iDynTree.SpatialAcc_FromPython
    __swig_destroy__ = _iDynTree.delete_SpatialAcc
    __del__ = lambda self: None
SpatialAcc_swigregister = _iDynTree.SpatialAcc_swigregister
SpatialAcc_swigregister(SpatialAcc)

def SpatialAcc_FromPython(arg2):
    return _iDynTree.SpatialAcc_FromPython(arg2)
SpatialAcc_FromPython = _iDynTree.SpatialAcc_FromPython

class ClassicalAcc(Vector6):
    __swig_setmethods__ = {}
    for _s in [Vector6]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassicalAcc, name, value)
    __swig_getmethods__ = {}
    for _s in [Vector6]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassicalAcc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_ClassicalAcc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.ClassicalAcc_changeCoordFrame(self, newCoordFrame)
    if _newclass:
        Zero = staticmethod(_iDynTree.ClassicalAcc_Zero)
    else:
        Zero = _iDynTree.ClassicalAcc_Zero

    def fromSpatial(self, spatialAcc, vel):
        return _iDynTree.ClassicalAcc_fromSpatial(self, spatialAcc, vel)

    def toSpatial(self, spatialAcc, vel):
        return _iDynTree.ClassicalAcc_toSpatial(self, spatialAcc, vel)
    __swig_destroy__ = _iDynTree.delete_ClassicalAcc
    __del__ = lambda self: None
ClassicalAcc_swigregister = _iDynTree.ClassicalAcc_swigregister
ClassicalAcc_swigregister(ClassicalAcc)

def ClassicalAcc_Zero():
    return _iDynTree.ClassicalAcc_Zero()
ClassicalAcc_Zero = _iDynTree.ClassicalAcc_Zero

class Direction(Vector3):
    __swig_setmethods__ = {}
    for _s in [Vector3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Direction, name, value)
    __swig_getmethods__ = {}
    for _s in [Vector3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Direction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Normalize(self, *args):
        return _iDynTree.Direction_Normalize(self, *args)

    def isParallel(self, otherDirection, tolerance):
        return _iDynTree.Direction_isParallel(self, otherDirection, tolerance)

    def isPerpendicular(self, otherDirection, tolerance):
        return _iDynTree.Direction_isPerpendicular(self, otherDirection, tolerance)

    def reverse(self):
        return _iDynTree.Direction_reverse(self)

    def toString(self):
        return _iDynTree.Direction_toString(self)

    def __str__(self):
        return _iDynTree.Direction___str__(self)
    if _newclass:
        Default = staticmethod(_iDynTree.Direction_Default)
    else:
        Default = _iDynTree.Direction_Default
    __swig_destroy__ = _iDynTree.delete_Direction
    __del__ = lambda self: None
Direction_swigregister = _iDynTree.Direction_swigregister
Direction_swigregister(Direction)

def Direction_Default():
    return _iDynTree.Direction_Default()
Direction_Default = _iDynTree.Direction_Default

class Axis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Axis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Axis, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Axis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getDirection(self):
        return _iDynTree.Axis_getDirection(self)

    def getOrigin(self):
        return _iDynTree.Axis_getOrigin(self)

    def setDirection(self, _direction):
        return _iDynTree.Axis_setDirection(self, _direction)

    def setOrigin(self, _position):
        return _iDynTree.Axis_setOrigin(self, _position)

    def getRotationTransform(self, theta):
        return _iDynTree.Axis_getRotationTransform(self, theta)

    def getRotationTransformDerivative(self, theta):
        return _iDynTree.Axis_getRotationTransformDerivative(self, theta)

    def getRotationTwist(self, dtheta):
        return _iDynTree.Axis_getRotationTwist(self, dtheta)

    def getRotationSpatialAcc(self, d2theta):
        return _iDynTree.Axis_getRotationSpatialAcc(self, d2theta)

    def getTranslationTransform(self, dist):
        return _iDynTree.Axis_getTranslationTransform(self, dist)

    def getTranslationTransformDerivative(self, arg2):
        return _iDynTree.Axis_getTranslationTransformDerivative(self, arg2)

    def getTranslationTwist(self, ddist):
        return _iDynTree.Axis_getTranslationTwist(self, ddist)

    def getTranslationSpatialAcc(self, d2dist):
        return _iDynTree.Axis_getTranslationSpatialAcc(self, d2dist)

    def isParallel(self, otherAxis, tolerance):
        return _iDynTree.Axis_isParallel(self, otherAxis, tolerance)

    def reverse(self):
        return _iDynTree.Axis_reverse(self)

    def toString(self):
        return _iDynTree.Axis_toString(self)

    def __str__(self):
        return _iDynTree.Axis___str__(self)
    __swig_destroy__ = _iDynTree.delete_Axis
    __del__ = lambda self: None
Axis_swigregister = _iDynTree.Axis_swigregister
Axis_swigregister(Axis)

class RotationalInertiaRaw(Matrix3x3):
    __swig_setmethods__ = {}
    for _s in [Matrix3x3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationalInertiaRaw, name, value)
    __swig_getmethods__ = {}
    for _s in [Matrix3x3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationalInertiaRaw, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_RotationalInertiaRaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        Zero = staticmethod(_iDynTree.RotationalInertiaRaw_Zero)
    else:
        Zero = _iDynTree.RotationalInertiaRaw_Zero
    __swig_destroy__ = _iDynTree.delete_RotationalInertiaRaw
    __del__ = lambda self: None
RotationalInertiaRaw_swigregister = _iDynTree.RotationalInertiaRaw_swigregister
RotationalInertiaRaw_swigregister(RotationalInertiaRaw)

def RotationalInertiaRaw_Zero():
    return _iDynTree.RotationalInertiaRaw_Zero()
RotationalInertiaRaw_Zero = _iDynTree.RotationalInertiaRaw_Zero

class SpatialInertiaRaw(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialInertiaRaw, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialInertiaRaw, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialInertiaRaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fromRotationalInertiaWrtCenterOfMass(self, mass, com, rotInertia):
        return _iDynTree.SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass(self, mass, com, rotInertia)

    def getMass(self):
        return _iDynTree.SpatialInertiaRaw_getMass(self)

    def getCenterOfMass(self):
        return _iDynTree.SpatialInertiaRaw_getCenterOfMass(self)

    def getRotationalInertiaWrtFrameOrigin(self):
        return _iDynTree.SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin(self)

    def getRotationalInertiaWrtCenterOfMass(self):
        return _iDynTree.SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass(self)
    if _newclass:
        combine = staticmethod(_iDynTree.SpatialInertiaRaw_combine)
    else:
        combine = _iDynTree.SpatialInertiaRaw_combine

    def multiply(self, op):
        return _iDynTree.SpatialInertiaRaw_multiply(self, op)

    def zero(self):
        return _iDynTree.SpatialInertiaRaw_zero(self)
    __swig_destroy__ = _iDynTree.delete_SpatialInertiaRaw
    __del__ = lambda self: None
SpatialInertiaRaw_swigregister = _iDynTree.SpatialInertiaRaw_swigregister
SpatialInertiaRaw_swigregister(SpatialInertiaRaw)

def SpatialInertiaRaw_combine(op1, op2):
    return _iDynTree.SpatialInertiaRaw_combine(op1, op2)
SpatialInertiaRaw_combine = _iDynTree.SpatialInertiaRaw_combine

class SpatialInertia(SpatialInertiaRaw):
    __swig_setmethods__ = {}
    for _s in [SpatialInertiaRaw]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpatialInertia, name, value)
    __swig_getmethods__ = {}
    for _s in [SpatialInertiaRaw]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpatialInertia, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SpatialInertia(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        combine = staticmethod(_iDynTree.SpatialInertia_combine)
    else:
        combine = _iDynTree.SpatialInertia_combine

    def asMatrix(self):
        return _iDynTree.SpatialInertia_asMatrix(self)

    def applyInverse(self, mom):
        return _iDynTree.SpatialInertia_applyInverse(self, mom)

    def getInverse(self):
        return _iDynTree.SpatialInertia_getInverse(self)

    def __add__(self, other):
        return _iDynTree.SpatialInertia___add__(self, other)

    def __mul__(self, *args):
        return _iDynTree.SpatialInertia___mul__(self, *args)

    def biasWrench(self, V):
        return _iDynTree.SpatialInertia_biasWrench(self, V)

    def biasWrenchDerivative(self, V):
        return _iDynTree.SpatialInertia_biasWrenchDerivative(self, V)
    if _newclass:
        Zero = staticmethod(_iDynTree.SpatialInertia_Zero)
    else:
        Zero = _iDynTree.SpatialInertia_Zero

    def asVector(self):
        return _iDynTree.SpatialInertia_asVector(self)

    def fromVector(self, inertialParams):
        return _iDynTree.SpatialInertia_fromVector(self, inertialParams)

    def isPhysicallyConsistent(self):
        return _iDynTree.SpatialInertia_isPhysicallyConsistent(self)
    if _newclass:
        momentumRegressor = staticmethod(_iDynTree.SpatialInertia_momentumRegressor)
    else:
        momentumRegressor = _iDynTree.SpatialInertia_momentumRegressor
    if _newclass:
        momentumDerivativeRegressor = staticmethod(_iDynTree.SpatialInertia_momentumDerivativeRegressor)
    else:
        momentumDerivativeRegressor = _iDynTree.SpatialInertia_momentumDerivativeRegressor
    if _newclass:
        momentumDerivativeSlotineLiRegressor = staticmethod(_iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor)
    else:
        momentumDerivativeSlotineLiRegressor = _iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor
    __swig_destroy__ = _iDynTree.delete_SpatialInertia
    __del__ = lambda self: None
SpatialInertia_swigregister = _iDynTree.SpatialInertia_swigregister
SpatialInertia_swigregister(SpatialInertia)

def SpatialInertia_combine(op1, op2):
    return _iDynTree.SpatialInertia_combine(op1, op2)
SpatialInertia_combine = _iDynTree.SpatialInertia_combine

def SpatialInertia_Zero():
    return _iDynTree.SpatialInertia_Zero()
SpatialInertia_Zero = _iDynTree.SpatialInertia_Zero

def SpatialInertia_momentumRegressor(v):
    return _iDynTree.SpatialInertia_momentumRegressor(v)
SpatialInertia_momentumRegressor = _iDynTree.SpatialInertia_momentumRegressor

def SpatialInertia_momentumDerivativeRegressor(v, a):
    return _iDynTree.SpatialInertia_momentumDerivativeRegressor(v, a)
SpatialInertia_momentumDerivativeRegressor = _iDynTree.SpatialInertia_momentumDerivativeRegressor

def SpatialInertia_momentumDerivativeSlotineLiRegressor(v, vRef, aRef):
    return _iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor(v, vRef, aRef)
SpatialInertia_momentumDerivativeSlotineLiRegressor = _iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor

class ArticulatedBodyInertia(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ArticulatedBodyInertia, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ArticulatedBodyInertia, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_ArticulatedBodyInertia(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getLinearLinearSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getLinearLinearSubmatrix(self, *args)

    def getLinearAngularSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getLinearAngularSubmatrix(self, *args)

    def getAngularAngularSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getAngularAngularSubmatrix(self, *args)
    if _newclass:
        combine = staticmethod(_iDynTree.ArticulatedBodyInertia_combine)
    else:
        combine = _iDynTree.ArticulatedBodyInertia_combine

    def applyInverse(self, wrench):
        return _iDynTree.ArticulatedBodyInertia_applyInverse(self, wrench)

    def asMatrix(self):
        return _iDynTree.ArticulatedBodyInertia_asMatrix(self)

    def getInverse(self):
        return _iDynTree.ArticulatedBodyInertia_getInverse(self)

    def __add__(self, other):
        return _iDynTree.ArticulatedBodyInertia___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.ArticulatedBodyInertia___sub__(self, other)

    def __mul__(self, *args):
        return _iDynTree.ArticulatedBodyInertia___mul__(self, *args)

    def zero(self):
        return _iDynTree.ArticulatedBodyInertia_zero(self)
    if _newclass:
        ABADyadHelper = staticmethod(_iDynTree.ArticulatedBodyInertia_ABADyadHelper)
    else:
        ABADyadHelper = _iDynTree.ArticulatedBodyInertia_ABADyadHelper
    if _newclass:
        ABADyadHelperLin = staticmethod(_iDynTree.ArticulatedBodyInertia_ABADyadHelperLin)
    else:
        ABADyadHelperLin = _iDynTree.ArticulatedBodyInertia_ABADyadHelperLin
    __swig_destroy__ = _iDynTree.delete_ArticulatedBodyInertia
    __del__ = lambda self: None
ArticulatedBodyInertia_swigregister = _iDynTree.ArticulatedBodyInertia_swigregister
ArticulatedBodyInertia_swigregister(ArticulatedBodyInertia)

def ArticulatedBodyInertia_combine(op1, op2):
    return _iDynTree.ArticulatedBodyInertia_combine(op1, op2)
ArticulatedBodyInertia_combine = _iDynTree.ArticulatedBodyInertia_combine

def ArticulatedBodyInertia_ABADyadHelper(U, d):
    return _iDynTree.ArticulatedBodyInertia_ABADyadHelper(U, d)
ArticulatedBodyInertia_ABADyadHelper = _iDynTree.ArticulatedBodyInertia_ABADyadHelper

def ArticulatedBodyInertia_ABADyadHelperLin(U, inv_d, dU, d_inv_d):
    return _iDynTree.ArticulatedBodyInertia_ABADyadHelperLin(U, inv_d, dU, d_inv_d)
ArticulatedBodyInertia_ABADyadHelperLin = _iDynTree.ArticulatedBodyInertia_ABADyadHelperLin

class RigidBodyInertiaNonLinearParametrization(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RigidBodyInertiaNonLinearParametrization, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RigidBodyInertiaNonLinearParametrization, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mass"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_mass_set
    __swig_getmethods__["mass"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_mass_get
    if _newclass:
        mass = _swig_property(_iDynTree.RigidBodyInertiaNonLinearParametrization_mass_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_mass_set)
    __swig_setmethods__["com"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_com_set
    __swig_getmethods__["com"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_com_get
    if _newclass:
        com = _swig_property(_iDynTree.RigidBodyInertiaNonLinearParametrization_com_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_com_set)
    __swig_setmethods__["link_R_centroidal"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set
    __swig_getmethods__["link_R_centroidal"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get
    if _newclass:
        link_R_centroidal = _swig_property(_iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set)
    __swig_setmethods__["centralSecondMomentOfMass"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set
    __swig_getmethods__["centralSecondMomentOfMass"] = _iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get
    if _newclass:
        centralSecondMomentOfMass = _swig_property(_iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set)

    def getLinkCentroidalTransform(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform(self)

    def fromRigidBodyInertia(self, inertia):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia(self, inertia)

    def fromInertialParameters(self, inertialParams):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromInertialParameters(self, inertialParams)

    def toRigidBodyInertia(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia(self)

    def isPhysicallyConsistent(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent(self)

    def asVectorWithRotationAsVec(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec(self)

    def fromVectorWithRotationAsVec(self, vec):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec(self, vec)

    def getGradientWithRotationAsVec(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec(self)

    def __init__(self):
        this = _iDynTree.new_RigidBodyInertiaNonLinearParametrization()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_RigidBodyInertiaNonLinearParametrization
    __del__ = lambda self: None
RigidBodyInertiaNonLinearParametrization_swigregister = _iDynTree.RigidBodyInertiaNonLinearParametrization_swigregister
RigidBodyInertiaNonLinearParametrization_swigregister(RigidBodyInertiaNonLinearParametrization)

class RotationRaw(Matrix3x3):
    __swig_setmethods__ = {}
    for _s in [Matrix3x3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RotationRaw, name, value)
    __swig_getmethods__ = {}
    for _s in [Matrix3x3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RotationRaw, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_RotationRaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changeOrientFrame(self, newOrientFrame):
        return _iDynTree.RotationRaw_changeOrientFrame(self, newOrientFrame)

    def changeRefOrientFrame(self, newRefOrientFrame):
        return _iDynTree.RotationRaw_changeRefOrientFrame(self, newRefOrientFrame)
    if _newclass:
        compose = staticmethod(_iDynTree.RotationRaw_compose)
    else:
        compose = _iDynTree.RotationRaw_compose
    if _newclass:
        inverse2 = staticmethod(_iDynTree.RotationRaw_inverse2)
    else:
        inverse2 = _iDynTree.RotationRaw_inverse2

    def changeCoordFrameOf(self, *args):
        return _iDynTree.RotationRaw_changeCoordFrameOf(self, *args)
    if _newclass:
        RotX = staticmethod(_iDynTree.RotationRaw_RotX)
    else:
        RotX = _iDynTree.RotationRaw_RotX
    if _newclass:
        RotY = staticmethod(_iDynTree.RotationRaw_RotY)
    else:
        RotY = _iDynTree.RotationRaw_RotY
    if _newclass:
        RotZ = staticmethod(_iDynTree.RotationRaw_RotZ)
    else:
        RotZ = _iDynTree.RotationRaw_RotZ
    if _newclass:
        RPY = staticmethod(_iDynTree.RotationRaw_RPY)
    else:
        RPY = _iDynTree.RotationRaw_RPY
    if _newclass:
        Identity = staticmethod(_iDynTree.RotationRaw_Identity)
    else:
        Identity = _iDynTree.RotationRaw_Identity

    def toString(self):
        return _iDynTree.RotationRaw_toString(self)

    def __str__(self):
        return _iDynTree.RotationRaw___str__(self)
    __swig_destroy__ = _iDynTree.delete_RotationRaw
    __del__ = lambda self: None
RotationRaw_swigregister = _iDynTree.RotationRaw_swigregister
RotationRaw_swigregister(RotationRaw)

def RotationRaw_compose(op1, op2):
    return _iDynTree.RotationRaw_compose(op1, op2)
RotationRaw_compose = _iDynTree.RotationRaw_compose

def RotationRaw_inverse2(orient):
    return _iDynTree.RotationRaw_inverse2(orient)
RotationRaw_inverse2 = _iDynTree.RotationRaw_inverse2

def RotationRaw_RotX(angle):
    return _iDynTree.RotationRaw_RotX(angle)
RotationRaw_RotX = _iDynTree.RotationRaw_RotX

def RotationRaw_RotY(angle):
    return _iDynTree.RotationRaw_RotY(angle)
RotationRaw_RotY = _iDynTree.RotationRaw_RotY

def RotationRaw_RotZ(angle):
    return _iDynTree.RotationRaw_RotZ(angle)
RotationRaw_RotZ = _iDynTree.RotationRaw_RotZ

def RotationRaw_RPY(roll, pitch, yaw):
    return _iDynTree.RotationRaw_RPY(roll, pitch, yaw)
RotationRaw_RPY = _iDynTree.RotationRaw_RPY

def RotationRaw_Identity():
    return _iDynTree.RotationRaw_Identity()
RotationRaw_Identity = _iDynTree.RotationRaw_Identity

class Rotation(RotationRaw):
    __swig_setmethods__ = {}
    for _s in [RotationRaw]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rotation, name, value)
    __swig_getmethods__ = {}
    for _s in [RotationRaw]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Rotation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Rotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def changeOrientFrame(self, newOrientFrame):
        return _iDynTree.Rotation_changeOrientFrame(self, newOrientFrame)

    def changeRefOrientFrame(self, newRefOrientFrame):
        return _iDynTree.Rotation_changeRefOrientFrame(self, newRefOrientFrame)

    def changeCoordinateFrame(self, newCoordinateFrame):
        return _iDynTree.Rotation_changeCoordinateFrame(self, newCoordinateFrame)
    if _newclass:
        compose = staticmethod(_iDynTree.Rotation_compose)
    else:
        compose = _iDynTree.Rotation_compose
    if _newclass:
        inverse2 = staticmethod(_iDynTree.Rotation_inverse2)
    else:
        inverse2 = _iDynTree.Rotation_inverse2

    def changeCoordFrameOf(self, *args):
        return _iDynTree.Rotation_changeCoordFrameOf(self, *args)

    def inverse(self):
        return _iDynTree.Rotation_inverse(self)

    def __mul__(self, *args):
        return _iDynTree.Rotation___mul__(self, *args)

    def log(self):
        return _iDynTree.Rotation_log(self)

    def fromQuaternion(self, quaternion):
        return _iDynTree.Rotation_fromQuaternion(self, quaternion)

    def getRPY(self, r, p, y):
        return _iDynTree.Rotation_getRPY(self, r, p, y)

    def asRPY(self):
        return _iDynTree.Rotation_asRPY(self)

    def getQuaternion(self, *args):
        return _iDynTree.Rotation_getQuaternion(self, *args)

    def asQuaternion(self):
        return _iDynTree.Rotation_asQuaternion(self)
    if _newclass:
        RotX = staticmethod(_iDynTree.Rotation_RotX)
    else:
        RotX = _iDynTree.Rotation_RotX
    if _newclass:
        RotY = staticmethod(_iDynTree.Rotation_RotY)
    else:
        RotY = _iDynTree.Rotation_RotY
    if _newclass:
        RotZ = staticmethod(_iDynTree.Rotation_RotZ)
    else:
        RotZ = _iDynTree.Rotation_RotZ
    if _newclass:
        RotAxis = staticmethod(_iDynTree.Rotation_RotAxis)
    else:
        RotAxis = _iDynTree.Rotation_RotAxis
    if _newclass:
        RotAxisDerivative = staticmethod(_iDynTree.Rotation_RotAxisDerivative)
    else:
        RotAxisDerivative = _iDynTree.Rotation_RotAxisDerivative
    if _newclass:
        RPY = staticmethod(_iDynTree.Rotation_RPY)
    else:
        RPY = _iDynTree.Rotation_RPY
    if _newclass:
        RPYRightTrivializedDerivative = staticmethod(_iDynTree.Rotation_RPYRightTrivializedDerivative)
    else:
        RPYRightTrivializedDerivative = _iDynTree.Rotation_RPYRightTrivializedDerivative
    if _newclass:
        RPYRightTrivializedDerivativeRateOfChange = staticmethod(_iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange)
    else:
        RPYRightTrivializedDerivativeRateOfChange = _iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange
    if _newclass:
        RPYRightTrivializedDerivativeInverse = staticmethod(_iDynTree.Rotation_RPYRightTrivializedDerivativeInverse)
    else:
        RPYRightTrivializedDerivativeInverse = _iDynTree.Rotation_RPYRightTrivializedDerivativeInverse
    if _newclass:
        RPYRightTrivializedDerivativeInverseRateOfChange = staticmethod(_iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange)
    else:
        RPYRightTrivializedDerivativeInverseRateOfChange = _iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange
    if _newclass:
        QuaternionRightTrivializedDerivative = staticmethod(_iDynTree.Rotation_QuaternionRightTrivializedDerivative)
    else:
        QuaternionRightTrivializedDerivative = _iDynTree.Rotation_QuaternionRightTrivializedDerivative
    if _newclass:
        QuaternionRightTrivializedDerivativeInverse = staticmethod(_iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse)
    else:
        QuaternionRightTrivializedDerivativeInverse = _iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse
    if _newclass:
        Identity = staticmethod(_iDynTree.Rotation_Identity)
    else:
        Identity = _iDynTree.Rotation_Identity
    if _newclass:
        RotationFromQuaternion = staticmethod(_iDynTree.Rotation_RotationFromQuaternion)
    else:
        RotationFromQuaternion = _iDynTree.Rotation_RotationFromQuaternion
    if _newclass:
        leftJacobian = staticmethod(_iDynTree.Rotation_leftJacobian)
    else:
        leftJacobian = _iDynTree.Rotation_leftJacobian
    if _newclass:
        leftJacobianInverse = staticmethod(_iDynTree.Rotation_leftJacobianInverse)
    else:
        leftJacobianInverse = _iDynTree.Rotation_leftJacobianInverse

    def toString(self):
        return _iDynTree.Rotation_toString(self)

    def __str__(self):
        return _iDynTree.Rotation___str__(self)
    __swig_destroy__ = _iDynTree.delete_Rotation
    __del__ = lambda self: None
Rotation_swigregister = _iDynTree.Rotation_swigregister
Rotation_swigregister(Rotation)

def Rotation_compose(op1, op2):
    return _iDynTree.Rotation_compose(op1, op2)
Rotation_compose = _iDynTree.Rotation_compose

def Rotation_inverse2(orient):
    return _iDynTree.Rotation_inverse2(orient)
Rotation_inverse2 = _iDynTree.Rotation_inverse2

def Rotation_RotX(angle):
    return _iDynTree.Rotation_RotX(angle)
Rotation_RotX = _iDynTree.Rotation_RotX

def Rotation_RotY(angle):
    return _iDynTree.Rotation_RotY(angle)
Rotation_RotY = _iDynTree.Rotation_RotY

def Rotation_RotZ(angle):
    return _iDynTree.Rotation_RotZ(angle)
Rotation_RotZ = _iDynTree.Rotation_RotZ

def Rotation_RotAxis(direction, angle):
    return _iDynTree.Rotation_RotAxis(direction, angle)
Rotation_RotAxis = _iDynTree.Rotation_RotAxis

def Rotation_RotAxisDerivative(direction, angle):
    return _iDynTree.Rotation_RotAxisDerivative(direction, angle)
Rotation_RotAxisDerivative = _iDynTree.Rotation_RotAxisDerivative

def Rotation_RPY(roll, pitch, yaw):
    return _iDynTree.Rotation_RPY(roll, pitch, yaw)
Rotation_RPY = _iDynTree.Rotation_RPY

def Rotation_RPYRightTrivializedDerivative(roll, pitch, yaw):
    return _iDynTree.Rotation_RPYRightTrivializedDerivative(roll, pitch, yaw)
Rotation_RPYRightTrivializedDerivative = _iDynTree.Rotation_RPYRightTrivializedDerivative

def Rotation_RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)
Rotation_RPYRightTrivializedDerivativeRateOfChange = _iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange

def Rotation_RPYRightTrivializedDerivativeInverse(roll, pitch, yaw):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverse(roll, pitch, yaw)
Rotation_RPYRightTrivializedDerivativeInverse = _iDynTree.Rotation_RPYRightTrivializedDerivativeInverse

def Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)
Rotation_RPYRightTrivializedDerivativeInverseRateOfChange = _iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange

def Rotation_QuaternionRightTrivializedDerivative(quaternion):
    return _iDynTree.Rotation_QuaternionRightTrivializedDerivative(quaternion)
Rotation_QuaternionRightTrivializedDerivative = _iDynTree.Rotation_QuaternionRightTrivializedDerivative

def Rotation_QuaternionRightTrivializedDerivativeInverse(quaternion):
    return _iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse(quaternion)
Rotation_QuaternionRightTrivializedDerivativeInverse = _iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse

def Rotation_Identity():
    return _iDynTree.Rotation_Identity()
Rotation_Identity = _iDynTree.Rotation_Identity

def Rotation_RotationFromQuaternion(quaternion):
    return _iDynTree.Rotation_RotationFromQuaternion(quaternion)
Rotation_RotationFromQuaternion = _iDynTree.Rotation_RotationFromQuaternion

def Rotation_leftJacobian(omega):
    return _iDynTree.Rotation_leftJacobian(omega)
Rotation_leftJacobian = _iDynTree.Rotation_leftJacobian

def Rotation_leftJacobianInverse(omega):
    return _iDynTree.Rotation_leftJacobianInverse(omega)
Rotation_leftJacobianInverse = _iDynTree.Rotation_leftJacobianInverse

class Transform(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Transform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def fromHomogeneousTransform(self, transform):
        return _iDynTree.Transform_fromHomogeneousTransform(self, transform)

    def getRotation(self):
        return _iDynTree.Transform_getRotation(self)

    def getPosition(self):
        return _iDynTree.Transform_getPosition(self)

    def setRotation(self, rotation):
        return _iDynTree.Transform_setRotation(self, rotation)

    def setPosition(self, position):
        return _iDynTree.Transform_setPosition(self, position)
    if _newclass:
        compose = staticmethod(_iDynTree.Transform_compose)
    else:
        compose = _iDynTree.Transform_compose
    if _newclass:
        inverse2 = staticmethod(_iDynTree.Transform_inverse2)
    else:
        inverse2 = _iDynTree.Transform_inverse2

    def inverse(self):
        return _iDynTree.Transform_inverse(self)

    def __mul__(self, *args):
        return _iDynTree.Transform___mul__(self, *args)
    if _newclass:
        Identity = staticmethod(_iDynTree.Transform_Identity)
    else:
        Identity = _iDynTree.Transform_Identity

    def asHomogeneousTransform(self):
        return _iDynTree.Transform_asHomogeneousTransform(self)

    def asAdjointTransform(self):
        return _iDynTree.Transform_asAdjointTransform(self)

    def asAdjointTransformWrench(self):
        return _iDynTree.Transform_asAdjointTransformWrench(self)

    def log(self):
        return _iDynTree.Transform_log(self)

    def toString(self):
        return _iDynTree.Transform_toString(self)

    def __str__(self):
        return _iDynTree.Transform___str__(self)
    __swig_destroy__ = _iDynTree.delete_Transform
    __del__ = lambda self: None
Transform_swigregister = _iDynTree.Transform_swigregister
Transform_swigregister(Transform)

def Transform_compose(op1, op2):
    return _iDynTree.Transform_compose(op1, op2)
Transform_compose = _iDynTree.Transform_compose

def Transform_inverse2(trans):
    return _iDynTree.Transform_inverse2(trans)
Transform_inverse2 = _iDynTree.Transform_inverse2

def Transform_Identity():
    return _iDynTree.Transform_Identity()
Transform_Identity = _iDynTree.Transform_Identity

class TransformDerivative(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformDerivative, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TransformDerivative, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_TransformDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_TransformDerivative
    __del__ = lambda self: None

    def getRotationDerivative(self):
        return _iDynTree.TransformDerivative_getRotationDerivative(self)

    def getPositionDerivative(self):
        return _iDynTree.TransformDerivative_getPositionDerivative(self)

    def setRotationDerivative(self, rotationDerivative):
        return _iDynTree.TransformDerivative_setRotationDerivative(self, rotationDerivative)

    def setPositionDerivative(self, positionDerivative):
        return _iDynTree.TransformDerivative_setPositionDerivative(self, positionDerivative)
    if _newclass:
        Zero = staticmethod(_iDynTree.TransformDerivative_Zero)
    else:
        Zero = _iDynTree.TransformDerivative_Zero

    def asHomogeneousTransformDerivative(self):
        return _iDynTree.TransformDerivative_asHomogeneousTransformDerivative(self)

    def asAdjointTransformDerivative(self, transform):
        return _iDynTree.TransformDerivative_asAdjointTransformDerivative(self, transform)

    def asAdjointTransformWrenchDerivative(self, transform):
        return _iDynTree.TransformDerivative_asAdjointTransformWrenchDerivative(self, transform)

    def __mul__(self, otherTransform):
        return _iDynTree.TransformDerivative___mul__(self, otherTransform)

    def derivativeOfInverse(self, transform):
        return _iDynTree.TransformDerivative_derivativeOfInverse(self, transform)

    def transform(self, *args):
        return _iDynTree.TransformDerivative_transform(self, *args)
TransformDerivative_swigregister = _iDynTree.TransformDerivative_swigregister
TransformDerivative_swigregister(TransformDerivative)

def TransformDerivative_Zero():
    return _iDynTree.TransformDerivative_Zero()
TransformDerivative_Zero = _iDynTree.TransformDerivative_Zero

class DynamicSpan(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicSpan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicSpan, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_DynamicSpan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_DynamicSpan
    __del__ = lambda self: None

    def first(self, count):
        return _iDynTree.DynamicSpan_first(self, count)

    def last(self, count):
        return _iDynTree.DynamicSpan_last(self, count)

    def subspan(self, *args):
        return _iDynTree.DynamicSpan_subspan(self, *args)

    def size(self):
        return _iDynTree.DynamicSpan_size(self)

    def size_bytes(self):
        return _iDynTree.DynamicSpan_size_bytes(self)

    def empty(self):
        return _iDynTree.DynamicSpan_empty(self)

    def getVal(self, idx):
        return _iDynTree.DynamicSpan_getVal(self, idx)

    def setVal(self, idx, val):
        return _iDynTree.DynamicSpan_setVal(self, idx, val)

    def at(self, idx):
        return _iDynTree.DynamicSpan_at(self, idx)

    def __call__(self, idx):
        return _iDynTree.DynamicSpan___call__(self, idx)

    def begin(self):
        return _iDynTree.DynamicSpan_begin(self)

    def end(self):
        return _iDynTree.DynamicSpan_end(self)

    def cbegin(self):
        return _iDynTree.DynamicSpan_cbegin(self)

    def cend(self):
        return _iDynTree.DynamicSpan_cend(self)

    def rbegin(self):
        return _iDynTree.DynamicSpan_rbegin(self)

    def rend(self):
        return _iDynTree.DynamicSpan_rend(self)

    def crbegin(self):
        return _iDynTree.DynamicSpan_crbegin(self)

    def crend(self):
        return _iDynTree.DynamicSpan_crend(self)
DynamicSpan_swigregister = _iDynTree.DynamicSpan_swigregister
DynamicSpan_swigregister(DynamicSpan)
cvar = _iDynTree.cvar
dynamic_extent = cvar.dynamic_extent
DynamicSpan.extent = _iDynTree.cvar.DynamicSpan_extent

class DynamicMatrixView(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicMatrixView, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicMatrixView, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_DynamicMatrixView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def storageOrder(self):
        return _iDynTree.DynamicMatrixView_storageOrder(self)

    def __call__(self, row, col):
        return _iDynTree.DynamicMatrixView___call__(self, row, col)

    def rows(self):
        return _iDynTree.DynamicMatrixView_rows(self)

    def cols(self):
        return _iDynTree.DynamicMatrixView_cols(self)
    __swig_destroy__ = _iDynTree.delete_DynamicMatrixView
    __del__ = lambda self: None
DynamicMatrixView_swigregister = _iDynTree.DynamicMatrixView_swigregister
DynamicMatrixView_swigregister(DynamicMatrixView)

class LinkPositions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkPositions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkPositions, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkPositions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkPositions_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkPositions_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkPositions_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkPositions___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkPositions_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkPositions
    __del__ = lambda self: None
LinkPositions_swigregister = _iDynTree.LinkPositions_swigregister
LinkPositions_swigregister(LinkPositions)

class LinkWrenches(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkWrenches, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkWrenches, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkWrenches(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkWrenches_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkWrenches_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkWrenches_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkWrenches___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkWrenches_toString(self, model)

    def zero(self):
        return _iDynTree.LinkWrenches_zero(self)
    __swig_destroy__ = _iDynTree.delete_LinkWrenches
    __del__ = lambda self: None
LinkWrenches_swigregister = _iDynTree.LinkWrenches_swigregister
LinkWrenches_swigregister(LinkWrenches)

class LinkInertias(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkInertias, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkInertias, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkInertias(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkInertias_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkInertias_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkInertias___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_LinkInertias
    __del__ = lambda self: None
LinkInertias_swigregister = _iDynTree.LinkInertias_swigregister
LinkInertias_swigregister(LinkInertias)

class LinkArticulatedBodyInertias(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkArticulatedBodyInertias, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkArticulatedBodyInertias, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkArticulatedBodyInertias(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkArticulatedBodyInertias_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkArticulatedBodyInertias_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkArticulatedBodyInertias___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_LinkArticulatedBodyInertias
    __del__ = lambda self: None
LinkArticulatedBodyInertias_swigregister = _iDynTree.LinkArticulatedBodyInertias_swigregister
LinkArticulatedBodyInertias_swigregister(LinkArticulatedBodyInertias)

class LinkVelArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkVelArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkVelArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkVelArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkVelArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkVelArray_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkVelArray_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkVelArray___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkVelArray_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkVelArray
    __del__ = lambda self: None
LinkVelArray_swigregister = _iDynTree.LinkVelArray_swigregister
LinkVelArray_swigregister(LinkVelArray)

class LinkAccArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkAccArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkAccArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkAccArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkAccArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkAccArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkAccArray___call__(self, *args)

    def getNrOfLinks(self):
        return _iDynTree.LinkAccArray_getNrOfLinks(self)

    def toString(self, model):
        return _iDynTree.LinkAccArray_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkAccArray
    __del__ = lambda self: None
LinkAccArray_swigregister = _iDynTree.LinkAccArray_swigregister
LinkAccArray_swigregister(LinkAccArray)

class Link(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Link, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Link, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_Link()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def inertia(self, *args):
        return _iDynTree.Link_inertia(self, *args)

    def setInertia(self, _inertia):
        return _iDynTree.Link_setInertia(self, _inertia)

    def getInertia(self):
        return _iDynTree.Link_getInertia(self)

    def setIndex(self, _index):
        return _iDynTree.Link_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.Link_getIndex(self)
    __swig_destroy__ = _iDynTree.delete_Link
    __del__ = lambda self: None
Link_swigregister = _iDynTree.Link_swigregister
Link_swigregister(Link)

class IJoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IJoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IJoint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IJoint
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.IJoint_clone(self)

    def getNrOfPosCoords(self):
        return _iDynTree.IJoint_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.IJoint_getNrOfDOFs(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.IJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.IJoint_setRestTransform(self, link1_X_link2)

    def getFirstAttachedLink(self):
        return _iDynTree.IJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.IJoint_getSecondAttachedLink(self)

    def getRestTransform(self, child, parent):
        return _iDynTree.IJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.IJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.IJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, dof_i, child, parent):
        return _iDynTree.IJoint_getMotionSubspaceVector(self, dof_i, child, parent)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.IJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.IJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.IJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def setIndex(self, _index):
        return _iDynTree.IJoint_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.IJoint_getIndex(self)

    def setPosCoordsOffset(self, _index):
        return _iDynTree.IJoint_setPosCoordsOffset(self, _index)

    def getPosCoordsOffset(self):
        return _iDynTree.IJoint_getPosCoordsOffset(self)

    def setDOFsOffset(self, _index):
        return _iDynTree.IJoint_setDOFsOffset(self, _index)

    def getDOFsOffset(self):
        return _iDynTree.IJoint_getDOFsOffset(self)

    def hasPosLimits(self):
        return _iDynTree.IJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.IJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.IJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.IJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.IJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.IJoint_setPosLimits(self, _index, min, max)

    def isRevoluteJoint(self):
        return _iDynTree.IJoint_isRevoluteJoint(self)

    def isFixedJoint(self):
        return _iDynTree.IJoint_isFixedJoint(self)

    def asRevoluteJoint(self):
        return _iDynTree.IJoint_asRevoluteJoint(self)

    def asFixedJoint(self):
        return _iDynTree.IJoint_asFixedJoint(self)
IJoint_swigregister = _iDynTree.IJoint_swigregister
IJoint_swigregister(IJoint)

class FixedJoint(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedJoint, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedJoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FixedJoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_FixedJoint
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.FixedJoint_clone(self)

    def getNrOfPosCoords(self):
        return _iDynTree.FixedJoint_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.FixedJoint_getNrOfDOFs(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.FixedJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.FixedJoint_setRestTransform(self, link1_X_link2)

    def getFirstAttachedLink(self):
        return _iDynTree.FixedJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.FixedJoint_getSecondAttachedLink(self)

    def getRestTransform(self, child, parent):
        return _iDynTree.FixedJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.FixedJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.FixedJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, dof_i, child, parent):
        return _iDynTree.FixedJoint_getMotionSubspaceVector(self, dof_i, child, parent)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.FixedJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.FixedJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def setIndex(self, _index):
        return _iDynTree.FixedJoint_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.FixedJoint_getIndex(self)

    def setPosCoordsOffset(self, _index):
        return _iDynTree.FixedJoint_setPosCoordsOffset(self, _index)

    def getPosCoordsOffset(self):
        return _iDynTree.FixedJoint_getPosCoordsOffset(self)

    def setDOFsOffset(self, _index):
        return _iDynTree.FixedJoint_setDOFsOffset(self, _index)

    def getDOFsOffset(self):
        return _iDynTree.FixedJoint_getDOFsOffset(self)

    def hasPosLimits(self):
        return _iDynTree.FixedJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.FixedJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.FixedJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.FixedJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.FixedJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.FixedJoint_setPosLimits(self, _index, min, max)
FixedJoint_swigregister = _iDynTree.FixedJoint_swigregister
FixedJoint_swigregister(FixedJoint)

class MovableJointImpl1(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl1, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl1, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl1
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl1_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl1_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl1_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl1_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl1_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl1_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl1_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl1_getDOFsOffset(self)
MovableJointImpl1_swigregister = _iDynTree.MovableJointImpl1_swigregister
MovableJointImpl1_swigregister(MovableJointImpl1)

class MovableJointImpl2(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl2, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl2
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl2_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl2_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl2_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl2_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl2_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl2_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl2_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl2_getDOFsOffset(self)
MovableJointImpl2_swigregister = _iDynTree.MovableJointImpl2_swigregister
MovableJointImpl2_swigregister(MovableJointImpl2)

class MovableJointImpl3(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl3, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl3, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl3
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl3_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl3_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl3_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl3_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl3_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl3_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl3_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl3_getDOFsOffset(self)
MovableJointImpl3_swigregister = _iDynTree.MovableJointImpl3_swigregister
MovableJointImpl3_swigregister(MovableJointImpl3)

class MovableJointImpl4(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl4, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl4, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl4
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl4_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl4_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl4_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl4_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl4_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl4_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl4_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl4_getDOFsOffset(self)
MovableJointImpl4_swigregister = _iDynTree.MovableJointImpl4_swigregister
MovableJointImpl4_swigregister(MovableJointImpl4)

class MovableJointImpl5(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl5, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl5, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl5
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl5_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl5_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl5_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl5_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl5_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl5_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl5_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl5_getDOFsOffset(self)
MovableJointImpl5_swigregister = _iDynTree.MovableJointImpl5_swigregister
MovableJointImpl5_swigregister(MovableJointImpl5)

class MovableJointImpl6(IJoint):
    __swig_setmethods__ = {}
    for _s in [IJoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovableJointImpl6, name, value)
    __swig_getmethods__ = {}
    for _s in [IJoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovableJointImpl6, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl6
    __del__ = lambda self: None

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl6_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl6_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl6_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl6_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl6_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl6_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl6_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl6_getDOFsOffset(self)
MovableJointImpl6_swigregister = _iDynTree.MovableJointImpl6_swigregister
MovableJointImpl6_swigregister(MovableJointImpl6)

class RevoluteJoint(MovableJointImpl1):
    __swig_setmethods__ = {}
    for _s in [MovableJointImpl1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RevoluteJoint, name, value)
    __swig_getmethods__ = {}
    for _s in [MovableJointImpl1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RevoluteJoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_RevoluteJoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_RevoluteJoint
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.RevoluteJoint_clone(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.RevoluteJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.RevoluteJoint_setRestTransform(self, link1_X_link2)

    def setAxis(self, *args):
        return _iDynTree.RevoluteJoint_setAxis(self, *args)

    def getFirstAttachedLink(self):
        return _iDynTree.RevoluteJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.RevoluteJoint_getSecondAttachedLink(self)

    def getAxis(self, *args):
        return _iDynTree.RevoluteJoint_getAxis(self, *args)

    def getRestTransform(self, child, parent):
        return _iDynTree.RevoluteJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.RevoluteJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.RevoluteJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, *args):
        return _iDynTree.RevoluteJoint_getMotionSubspaceVector(self, *args)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.RevoluteJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.RevoluteJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def hasPosLimits(self):
        return _iDynTree.RevoluteJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.RevoluteJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.RevoluteJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.RevoluteJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.RevoluteJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.RevoluteJoint_setPosLimits(self, _index, min, max)
RevoluteJoint_swigregister = _iDynTree.RevoluteJoint_swigregister
RevoluteJoint_swigregister(RevoluteJoint)

class PrismaticJoint(MovableJointImpl1):
    __swig_setmethods__ = {}
    for _s in [MovableJointImpl1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrismaticJoint, name, value)
    __swig_getmethods__ = {}
    for _s in [MovableJointImpl1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrismaticJoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_PrismaticJoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_PrismaticJoint
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.PrismaticJoint_clone(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.PrismaticJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.PrismaticJoint_setRestTransform(self, link1_X_link2)

    def setAxis(self, *args):
        return _iDynTree.PrismaticJoint_setAxis(self, *args)

    def getFirstAttachedLink(self):
        return _iDynTree.PrismaticJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.PrismaticJoint_getSecondAttachedLink(self)

    def getAxis(self, *args):
        return _iDynTree.PrismaticJoint_getAxis(self, *args)

    def getRestTransform(self, child, parent):
        return _iDynTree.PrismaticJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.PrismaticJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.PrismaticJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, *args):
        return _iDynTree.PrismaticJoint_getMotionSubspaceVector(self, *args)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.PrismaticJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.PrismaticJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def hasPosLimits(self):
        return _iDynTree.PrismaticJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.PrismaticJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.PrismaticJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.PrismaticJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.PrismaticJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.PrismaticJoint_setPosLimits(self, _index, min, max)
PrismaticJoint_swigregister = _iDynTree.PrismaticJoint_swigregister
PrismaticJoint_swigregister(PrismaticJoint)

class Traversal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Traversal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Traversal, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_Traversal()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_Traversal
    __del__ = lambda self: None

    def getNrOfVisitedLinks(self):
        return _iDynTree.Traversal_getNrOfVisitedLinks(self)

    def getLink(self, traversalIndex):
        return _iDynTree.Traversal_getLink(self, traversalIndex)

    def getBaseLink(self):
        return _iDynTree.Traversal_getBaseLink(self)

    def getParentLink(self, traversalIndex):
        return _iDynTree.Traversal_getParentLink(self, traversalIndex)

    def getParentJoint(self, traversalIndex):
        return _iDynTree.Traversal_getParentJoint(self, traversalIndex)

    def getParentLinkFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getParentLinkFromLinkIndex(self, linkIndex)

    def getParentJointFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getParentJointFromLinkIndex(self, linkIndex)

    def getTraversalIndexFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getTraversalIndexFromLinkIndex(self, linkIndex)

    def reset(self, *args):
        return _iDynTree.Traversal_reset(self, *args)

    def addTraversalBase(self, link):
        return _iDynTree.Traversal_addTraversalBase(self, link)

    def addTraversalElement(self, link, jointToParent, parentLink):
        return _iDynTree.Traversal_addTraversalElement(self, link, jointToParent, parentLink)

    def isParentOf(self, parentCandidate, childCandidate):
        return _iDynTree.Traversal_isParentOf(self, parentCandidate, childCandidate)

    def getChildLinkIndexFromJointIndex(self, model, jntIdx):
        return _iDynTree.Traversal_getChildLinkIndexFromJointIndex(self, model, jntIdx)

    def getParentLinkIndexFromJointIndex(self, model, jntIdx):
        return _iDynTree.Traversal_getParentLinkIndexFromJointIndex(self, model, jntIdx)

    def toString(self, model):
        return _iDynTree.Traversal_toString(self, model)
Traversal_swigregister = _iDynTree.Traversal_swigregister
Traversal_swigregister(Traversal)

class Material(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Material, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Material, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Material(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        return _iDynTree.Material_name(self)

    def hasColor(self):
        return _iDynTree.Material_hasColor(self)

    def color(self):
        return _iDynTree.Material_color(self)

    def setColor(self, color):
        return _iDynTree.Material_setColor(self, color)

    def hasTexture(self):
        return _iDynTree.Material_hasTexture(self)

    def texture(self):
        return _iDynTree.Material_texture(self)

    def setTexture(self, texture):
        return _iDynTree.Material_setTexture(self, texture)
    __swig_destroy__ = _iDynTree.delete_Material
    __del__ = lambda self: None
Material_swigregister = _iDynTree.Material_swigregister
Material_swigregister(Material)

class SolidShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SolidShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SolidShape, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_SolidShape
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.SolidShape_clone(self)

    def getName(self):
        return _iDynTree.SolidShape_getName(self)

    def setName(self, name):
        return _iDynTree.SolidShape_setName(self, name)

    def isNameValid(self):
        return _iDynTree.SolidShape_isNameValid(self)

    def getLink_H_geometry(self):
        return _iDynTree.SolidShape_getLink_H_geometry(self)

    def setLink_H_geometry(self, newTransform):
        return _iDynTree.SolidShape_setLink_H_geometry(self, newTransform)

    def isMaterialSet(self):
        return _iDynTree.SolidShape_isMaterialSet(self)

    def getMaterial(self):
        return _iDynTree.SolidShape_getMaterial(self)

    def setMaterial(self, material):
        return _iDynTree.SolidShape_setMaterial(self, material)

    def isSphere(self):
        return _iDynTree.SolidShape_isSphere(self)

    def isBox(self):
        return _iDynTree.SolidShape_isBox(self)

    def isCylinder(self):
        return _iDynTree.SolidShape_isCylinder(self)

    def isExternalMesh(self):
        return _iDynTree.SolidShape_isExternalMesh(self)

    def asSphere(self, *args):
        return _iDynTree.SolidShape_asSphere(self, *args)

    def asBox(self, *args):
        return _iDynTree.SolidShape_asBox(self, *args)

    def asCylinder(self, *args):
        return _iDynTree.SolidShape_asCylinder(self, *args)

    def asExternalMesh(self, *args):
        return _iDynTree.SolidShape_asExternalMesh(self, *args)
SolidShape_swigregister = _iDynTree.SolidShape_swigregister
SolidShape_swigregister(SolidShape)

class Sphere(SolidShape):
    __swig_setmethods__ = {}
    for _s in [SolidShape]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sphere, name, value)
    __swig_getmethods__ = {}
    for _s in [SolidShape]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sphere, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Sphere
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.Sphere_clone(self)

    def getRadius(self):
        return _iDynTree.Sphere_getRadius(self)

    def setRadius(self, radius):
        return _iDynTree.Sphere_setRadius(self, radius)

    def __init__(self):
        this = _iDynTree.new_Sphere()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Sphere_swigregister = _iDynTree.Sphere_swigregister
Sphere_swigregister(Sphere)

class Box(SolidShape):
    __swig_setmethods__ = {}
    for _s in [SolidShape]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Box, name, value)
    __swig_getmethods__ = {}
    for _s in [SolidShape]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Box, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Box
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.Box_clone(self)

    def getX(self):
        return _iDynTree.Box_getX(self)

    def setX(self, x):
        return _iDynTree.Box_setX(self, x)

    def getY(self):
        return _iDynTree.Box_getY(self)

    def setY(self, y):
        return _iDynTree.Box_setY(self, y)

    def getZ(self):
        return _iDynTree.Box_getZ(self)

    def setZ(self, z):
        return _iDynTree.Box_setZ(self, z)

    def __init__(self):
        this = _iDynTree.new_Box()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Box_swigregister = _iDynTree.Box_swigregister
Box_swigregister(Box)

class Cylinder(SolidShape):
    __swig_setmethods__ = {}
    for _s in [SolidShape]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cylinder, name, value)
    __swig_getmethods__ = {}
    for _s in [SolidShape]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Cylinder, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Cylinder
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.Cylinder_clone(self)

    def getLength(self):
        return _iDynTree.Cylinder_getLength(self)

    def setLength(self, length):
        return _iDynTree.Cylinder_setLength(self, length)

    def getRadius(self):
        return _iDynTree.Cylinder_getRadius(self)

    def setRadius(self, radius):
        return _iDynTree.Cylinder_setRadius(self, radius)

    def __init__(self):
        this = _iDynTree.new_Cylinder()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Cylinder_swigregister = _iDynTree.Cylinder_swigregister
Cylinder_swigregister(Cylinder)

class ExternalMesh(SolidShape):
    __swig_setmethods__ = {}
    for _s in [SolidShape]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExternalMesh, name, value)
    __swig_getmethods__ = {}
    for _s in [SolidShape]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExternalMesh, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ExternalMesh
    __del__ = lambda self: None

    def clone(self):
        return _iDynTree.ExternalMesh_clone(self)

    def getFilename(self):
        return _iDynTree.ExternalMesh_getFilename(self)

    def setFilename(self, filename):
        return _iDynTree.ExternalMesh_setFilename(self, filename)

    def getScale(self):
        return _iDynTree.ExternalMesh_getScale(self)

    def setScale(self, scale):
        return _iDynTree.ExternalMesh_setScale(self, scale)

    def __init__(self):
        this = _iDynTree.new_ExternalMesh()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
ExternalMesh_swigregister = _iDynTree.ExternalMesh_swigregister
ExternalMesh_swigregister(ExternalMesh)

class ModelSolidShapes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelSolidShapes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelSolidShapes, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ModelSolidShapes
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _iDynTree.new_ModelSolidShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clear(self):
        return _iDynTree.ModelSolidShapes_clear(self)

    def resize(self, *args):
        return _iDynTree.ModelSolidShapes_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.ModelSolidShapes_isConsistent(self, model)

    def getLinkSolidShapes(self, *args):
        return _iDynTree.ModelSolidShapes_getLinkSolidShapes(self, *args)
ModelSolidShapes_swigregister = _iDynTree.ModelSolidShapes_swigregister
ModelSolidShapes_swigregister(ModelSolidShapes)

class Neighbor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Neighbor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Neighbor, name)
    __repr__ = _swig_repr
    __swig_setmethods__["neighborLink"] = _iDynTree.Neighbor_neighborLink_set
    __swig_getmethods__["neighborLink"] = _iDynTree.Neighbor_neighborLink_get
    if _newclass:
        neighborLink = _swig_property(_iDynTree.Neighbor_neighborLink_get, _iDynTree.Neighbor_neighborLink_set)
    __swig_setmethods__["neighborJoint"] = _iDynTree.Neighbor_neighborJoint_set
    __swig_getmethods__["neighborJoint"] = _iDynTree.Neighbor_neighborJoint_get
    if _newclass:
        neighborJoint = _swig_property(_iDynTree.Neighbor_neighborJoint_get, _iDynTree.Neighbor_neighborJoint_set)

    def __init__(self):
        this = _iDynTree.new_Neighbor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_Neighbor
    __del__ = lambda self: None
Neighbor_swigregister = _iDynTree.Neighbor_swigregister
Neighbor_swigregister(Neighbor)

class Model(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_Model(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy(self):
        return _iDynTree.Model_copy(self)
    __swig_destroy__ = _iDynTree.delete_Model
    __del__ = lambda self: None

    def getNrOfLinks(self):
        return _iDynTree.Model_getNrOfLinks(self)

    def getLinkName(self, linkIndex):
        return _iDynTree.Model_getLinkName(self, linkIndex)

    def getLinkIndex(self, linkName):
        return _iDynTree.Model_getLinkIndex(self, linkName)

    def isValidLinkIndex(self, index):
        return _iDynTree.Model_isValidLinkIndex(self, index)

    def getLink(self, *args):
        return _iDynTree.Model_getLink(self, *args)

    def addLink(self, name, link):
        return _iDynTree.Model_addLink(self, name, link)

    def getNrOfJoints(self):
        return _iDynTree.Model_getNrOfJoints(self)

    def getJointName(self, index):
        return _iDynTree.Model_getJointName(self, index)

    def getTotalMass(self):
        return _iDynTree.Model_getTotalMass(self)

    def getJointIndex(self, jointName):
        return _iDynTree.Model_getJointIndex(self, jointName)

    def getJoint(self, *args):
        return _iDynTree.Model_getJoint(self, *args)

    def isValidJointIndex(self, index):
        return _iDynTree.Model_isValidJointIndex(self, index)

    def isLinkNameUsed(self, linkName):
        return _iDynTree.Model_isLinkNameUsed(self, linkName)

    def isJointNameUsed(self, jointName):
        return _iDynTree.Model_isJointNameUsed(self, jointName)

    def isFrameNameUsed(self, frameName):
        return _iDynTree.Model_isFrameNameUsed(self, frameName)

    def addJoint(self, *args):
        return _iDynTree.Model_addJoint(self, *args)

    def addJointAndLink(self, existingLink, jointName, joint, newLinkName, newLink):
        return _iDynTree.Model_addJointAndLink(self, existingLink, jointName, joint, newLinkName, newLink)

    def insertLinkToExistingJointAndAddJointForDisplacedLink(self, existingJoint, unmovableLink, _unmovableLink_X_newLink, jointName, joint, newLinkName, newLink):
        return _iDynTree.Model_insertLinkToExistingJointAndAddJointForDisplacedLink(self, existingJoint, unmovableLink, _unmovableLink_X_newLink, jointName, joint, newLinkName, newLink)

    def getNrOfPosCoords(self):
        return _iDynTree.Model_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.Model_getNrOfDOFs(self)

    def getNrOfFrames(self):
        return _iDynTree.Model_getNrOfFrames(self)

    def addAdditionalFrameToLink(self, linkName, frameName, link_H_frame):
        return _iDynTree.Model_addAdditionalFrameToLink(self, linkName, frameName, link_H_frame)

    def getFrameName(self, frameIndex):
        return _iDynTree.Model_getFrameName(self, frameIndex)

    def getFrameIndex(self, frameName):
        return _iDynTree.Model_getFrameIndex(self, frameName)

    def isValidFrameIndex(self, index):
        return _iDynTree.Model_isValidFrameIndex(self, index)

    def getFrameTransform(self, frameIndex):
        return _iDynTree.Model_getFrameTransform(self, frameIndex)

    def getFrameLink(self, frameIndex):
        return _iDynTree.Model_getFrameLink(self, frameIndex)

    def getLinkAdditionalFrames(self, lnkIndex, frameIndeces):
        return _iDynTree.Model_getLinkAdditionalFrames(self, lnkIndex, frameIndeces)

    def getNrOfNeighbors(self, link):
        return _iDynTree.Model_getNrOfNeighbors(self, link)

    def getNeighbor(self, link, neighborIndex):
        return _iDynTree.Model_getNeighbor(self, link, neighborIndex)

    def setDefaultBaseLink(self, linkIndex):
        return _iDynTree.Model_setDefaultBaseLink(self, linkIndex)

    def getDefaultBaseLink(self):
        return _iDynTree.Model_getDefaultBaseLink(self)

    def computeFullTreeTraversal(self, *args):
        return _iDynTree.Model_computeFullTreeTraversal(self, *args)

    def getInertialParameters(self, modelInertialParams):
        return _iDynTree.Model_getInertialParameters(self, modelInertialParams)

    def updateInertialParameters(self, modelInertialParams):
        return _iDynTree.Model_updateInertialParameters(self, modelInertialParams)

    def visualSolidShapes(self, *args):
        return _iDynTree.Model_visualSolidShapes(self, *args)

    def collisionSolidShapes(self, *args):
        return _iDynTree.Model_collisionSolidShapes(self, *args)

    def toString(self):
        return _iDynTree.Model_toString(self)
Model_swigregister = _iDynTree.Model_swigregister
Model_swigregister(Model)

class JointPosDoubleArray(VectorDynSize):
    __swig_setmethods__ = {}
    for _s in [VectorDynSize]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointPosDoubleArray, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorDynSize]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointPosDoubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_JointPosDoubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.JointPosDoubleArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.JointPosDoubleArray_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_JointPosDoubleArray
    __del__ = lambda self: None
JointPosDoubleArray_swigregister = _iDynTree.JointPosDoubleArray_swigregister
JointPosDoubleArray_swigregister(JointPosDoubleArray)

class JointDOFsDoubleArray(VectorDynSize):
    __swig_setmethods__ = {}
    for _s in [VectorDynSize]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointDOFsDoubleArray, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorDynSize]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointDOFsDoubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_JointDOFsDoubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.JointDOFsDoubleArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.JointDOFsDoubleArray_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_JointDOFsDoubleArray
    __del__ = lambda self: None
JointDOFsDoubleArray_swigregister = _iDynTree.JointDOFsDoubleArray_swigregister
JointDOFsDoubleArray_swigregister(JointDOFsDoubleArray)

class DOFSpatialForceArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DOFSpatialForceArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DOFSpatialForceArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_DOFSpatialForceArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.DOFSpatialForceArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.DOFSpatialForceArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.DOFSpatialForceArray___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_DOFSpatialForceArray
    __del__ = lambda self: None
DOFSpatialForceArray_swigregister = _iDynTree.DOFSpatialForceArray_swigregister
DOFSpatialForceArray_swigregister(DOFSpatialForceArray)

class DOFSpatialMotionArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DOFSpatialMotionArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DOFSpatialMotionArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_DOFSpatialMotionArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.DOFSpatialMotionArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.DOFSpatialMotionArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.DOFSpatialMotionArray___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_DOFSpatialMotionArray
    __del__ = lambda self: None
DOFSpatialMotionArray_swigregister = _iDynTree.DOFSpatialMotionArray_swigregister
DOFSpatialMotionArray_swigregister(DOFSpatialMotionArray)

INERTIAL_FIXED_REPRESENTATION = _iDynTree.INERTIAL_FIXED_REPRESENTATION
BODY_FIXED_REPRESENTATION = _iDynTree.BODY_FIXED_REPRESENTATION
MIXED_REPRESENTATION = _iDynTree.MIXED_REPRESENTATION
class FrameFreeFloatingJacobian(MatrixDynSize):
    __swig_setmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameFreeFloatingJacobian, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameFreeFloatingJacobian, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FrameFreeFloatingJacobian(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FrameFreeFloatingJacobian_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.FrameFreeFloatingJacobian_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_FrameFreeFloatingJacobian
    __del__ = lambda self: None
FrameFreeFloatingJacobian_swigregister = _iDynTree.FrameFreeFloatingJacobian_swigregister
FrameFreeFloatingJacobian_swigregister(FrameFreeFloatingJacobian)

class MomentumFreeFloatingJacobian(MatrixDynSize):
    __swig_setmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MomentumFreeFloatingJacobian, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MomentumFreeFloatingJacobian, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_MomentumFreeFloatingJacobian(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.MomentumFreeFloatingJacobian_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.MomentumFreeFloatingJacobian_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_MomentumFreeFloatingJacobian
    __del__ = lambda self: None
MomentumFreeFloatingJacobian_swigregister = _iDynTree.MomentumFreeFloatingJacobian_swigregister
MomentumFreeFloatingJacobian_swigregister(MomentumFreeFloatingJacobian)

class FreeFloatingMassMatrix(MatrixDynSize):
    __swig_setmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeFloatingMassMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixDynSize]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FreeFloatingMassMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FreeFloatingMassMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FreeFloatingMassMatrix_resize(self, model)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingMassMatrix
    __del__ = lambda self: None
FreeFloatingMassMatrix_swigregister = _iDynTree.FreeFloatingMassMatrix_swigregister
FreeFloatingMassMatrix_swigregister(FreeFloatingMassMatrix)

class FreeFloatingPos(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeFloatingPos, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FreeFloatingPos, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FreeFloatingPos(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FreeFloatingPos_resize(self, model)

    def worldBasePos(self, *args):
        return _iDynTree.FreeFloatingPos_worldBasePos(self, *args)

    def jointPos(self, *args):
        return _iDynTree.FreeFloatingPos_jointPos(self, *args)

    def getNrOfPosCoords(self):
        return _iDynTree.FreeFloatingPos_getNrOfPosCoords(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingPos
    __del__ = lambda self: None
FreeFloatingPos_swigregister = _iDynTree.FreeFloatingPos_swigregister
FreeFloatingPos_swigregister(FreeFloatingPos)

class FreeFloatingGeneralizedTorques(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeFloatingGeneralizedTorques, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FreeFloatingGeneralizedTorques, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FreeFloatingGeneralizedTorques(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FreeFloatingGeneralizedTorques_resize(self, model)

    def baseWrench(self, *args):
        return _iDynTree.FreeFloatingGeneralizedTorques_baseWrench(self, *args)

    def jointTorques(self, *args):
        return _iDynTree.FreeFloatingGeneralizedTorques_jointTorques(self, *args)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingGeneralizedTorques_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingGeneralizedTorques
    __del__ = lambda self: None
FreeFloatingGeneralizedTorques_swigregister = _iDynTree.FreeFloatingGeneralizedTorques_swigregister
FreeFloatingGeneralizedTorques_swigregister(FreeFloatingGeneralizedTorques)

class FreeFloatingVel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeFloatingVel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FreeFloatingVel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FreeFloatingVel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FreeFloatingVel_resize(self, model)

    def baseVel(self, *args):
        return _iDynTree.FreeFloatingVel_baseVel(self, *args)

    def jointVel(self, *args):
        return _iDynTree.FreeFloatingVel_jointVel(self, *args)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingVel_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingVel
    __del__ = lambda self: None
FreeFloatingVel_swigregister = _iDynTree.FreeFloatingVel_swigregister
FreeFloatingVel_swigregister(FreeFloatingVel)

class FreeFloatingAcc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FreeFloatingAcc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FreeFloatingAcc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_FreeFloatingAcc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.FreeFloatingAcc_resize(self, model)

    def baseAcc(self, *args):
        return _iDynTree.FreeFloatingAcc_baseAcc(self, *args)

    def jointAcc(self, *args):
        return _iDynTree.FreeFloatingAcc_jointAcc(self, *args)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingAcc_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingAcc
    __del__ = lambda self: None
FreeFloatingAcc_swigregister = _iDynTree.FreeFloatingAcc_swigregister
FreeFloatingAcc_swigregister(FreeFloatingAcc)

class ContactWrench(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContactWrench, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ContactWrench, name)
    __repr__ = _swig_repr

    def contactId(self):
        return _iDynTree.ContactWrench_contactId(self)

    def contactPoint(self, *args):
        return _iDynTree.ContactWrench_contactPoint(self, *args)

    def contactWrench(self, *args):
        return _iDynTree.ContactWrench_contactWrench(self, *args)

    def __init__(self):
        this = _iDynTree.new_ContactWrench()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ContactWrench
    __del__ = lambda self: None
ContactWrench_swigregister = _iDynTree.ContactWrench_swigregister
ContactWrench_swigregister(ContactWrench)

class LinkContactWrenches(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkContactWrenches, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkContactWrenches, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkContactWrenches(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.LinkContactWrenches_resize(self, *args)

    def getNrOfContactsForLink(self, linkIndex):
        return _iDynTree.LinkContactWrenches_getNrOfContactsForLink(self, linkIndex)

    def setNrOfContactsForLink(self, linkIndex, nrOfContacts):
        return _iDynTree.LinkContactWrenches_setNrOfContactsForLink(self, linkIndex, nrOfContacts)

    def getNrOfLinks(self):
        return _iDynTree.LinkContactWrenches_getNrOfLinks(self)

    def contactWrench(self, *args):
        return _iDynTree.LinkContactWrenches_contactWrench(self, *args)

    def computeNetWrenches(self, netWrenches):
        return _iDynTree.LinkContactWrenches_computeNetWrenches(self, netWrenches)

    def toString(self, model):
        return _iDynTree.LinkContactWrenches_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkContactWrenches
    __del__ = lambda self: None
LinkContactWrenches_swigregister = _iDynTree.LinkContactWrenches_swigregister
LinkContactWrenches_swigregister(LinkContactWrenches)

class SolidShapesVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SolidShapesVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SolidShapesVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.SolidShapesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.SolidShapesVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.SolidShapesVector___bool__(self)

    def __len__(self):
        return _iDynTree.SolidShapesVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.SolidShapesVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.SolidShapesVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.SolidShapesVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.SolidShapesVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.SolidShapesVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.SolidShapesVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.SolidShapesVector_pop(self)

    def append(self, x):
        return _iDynTree.SolidShapesVector_append(self, x)

    def empty(self):
        return _iDynTree.SolidShapesVector_empty(self)

    def size(self):
        return _iDynTree.SolidShapesVector_size(self)

    def swap(self, v):
        return _iDynTree.SolidShapesVector_swap(self, v)

    def begin(self):
        return _iDynTree.SolidShapesVector_begin(self)

    def end(self):
        return _iDynTree.SolidShapesVector_end(self)

    def rbegin(self):
        return _iDynTree.SolidShapesVector_rbegin(self)

    def rend(self):
        return _iDynTree.SolidShapesVector_rend(self)

    def clear(self):
        return _iDynTree.SolidShapesVector_clear(self)

    def get_allocator(self):
        return _iDynTree.SolidShapesVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.SolidShapesVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.SolidShapesVector_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_SolidShapesVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.SolidShapesVector_push_back(self, x)

    def front(self):
        return _iDynTree.SolidShapesVector_front(self)

    def back(self):
        return _iDynTree.SolidShapesVector_back(self)

    def assign(self, n, x):
        return _iDynTree.SolidShapesVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.SolidShapesVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.SolidShapesVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.SolidShapesVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.SolidShapesVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_SolidShapesVector
    __del__ = lambda self: None
SolidShapesVector_swigregister = _iDynTree.SolidShapesVector_swigregister
SolidShapesVector_swigregister(SolidShapesVector)

class LinksSolidShapesVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinksSolidShapesVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinksSolidShapesVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.LinksSolidShapesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.LinksSolidShapesVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.LinksSolidShapesVector___bool__(self)

    def __len__(self):
        return _iDynTree.LinksSolidShapesVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.LinksSolidShapesVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.LinksSolidShapesVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.LinksSolidShapesVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.LinksSolidShapesVector_pop(self)

    def append(self, x):
        return _iDynTree.LinksSolidShapesVector_append(self, x)

    def empty(self):
        return _iDynTree.LinksSolidShapesVector_empty(self)

    def size(self):
        return _iDynTree.LinksSolidShapesVector_size(self)

    def swap(self, v):
        return _iDynTree.LinksSolidShapesVector_swap(self, v)

    def begin(self):
        return _iDynTree.LinksSolidShapesVector_begin(self)

    def end(self):
        return _iDynTree.LinksSolidShapesVector_end(self)

    def rbegin(self):
        return _iDynTree.LinksSolidShapesVector_rbegin(self)

    def rend(self):
        return _iDynTree.LinksSolidShapesVector_rend(self)

    def clear(self):
        return _iDynTree.LinksSolidShapesVector_clear(self)

    def get_allocator(self):
        return _iDynTree.LinksSolidShapesVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.LinksSolidShapesVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.LinksSolidShapesVector_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_LinksSolidShapesVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.LinksSolidShapesVector_push_back(self, x)

    def front(self):
        return _iDynTree.LinksSolidShapesVector_front(self)

    def back(self):
        return _iDynTree.LinksSolidShapesVector_back(self)

    def assign(self, n, x):
        return _iDynTree.LinksSolidShapesVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.LinksSolidShapesVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.LinksSolidShapesVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.LinksSolidShapesVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.LinksSolidShapesVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_LinksSolidShapesVector
    __del__ = lambda self: None
LinksSolidShapesVector_swigregister = _iDynTree.LinksSolidShapesVector_swigregister
LinksSolidShapesVector_swigregister(LinksSolidShapesVector)


def ForwardPositionKinematics(*args):
    return _iDynTree.ForwardPositionKinematics(*args)
ForwardPositionKinematics = _iDynTree.ForwardPositionKinematics

def ForwardVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc):
    return _iDynTree.ForwardVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc)
ForwardVelAccKinematics = _iDynTree.ForwardVelAccKinematics

def ForwardPosVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkPos, linkVel, linkAcc):
    return _iDynTree.ForwardPosVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkPos, linkVel, linkAcc)
ForwardPosVelAccKinematics = _iDynTree.ForwardPosVelAccKinematics

def ForwardPosVelKinematics(model, traversal, robotPos, robotVel, linkPos, linkVel):
    return _iDynTree.ForwardPosVelKinematics(model, traversal, robotPos, robotVel, linkPos, linkVel)
ForwardPosVelKinematics = _iDynTree.ForwardPosVelKinematics

def ForwardAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc):
    return _iDynTree.ForwardAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc)
ForwardAccKinematics = _iDynTree.ForwardAccKinematics

def ForwardBiasAccKinematics(*args):
    return _iDynTree.ForwardBiasAccKinematics(*args)
ForwardBiasAccKinematics = _iDynTree.ForwardBiasAccKinematics

def ComputeLinearAndAngularMomentum(model, linkPositions, linkVels, totalMomentum):
    return _iDynTree.ComputeLinearAndAngularMomentum(model, linkPositions, linkVels, totalMomentum)
ComputeLinearAndAngularMomentum = _iDynTree.ComputeLinearAndAngularMomentum

def ComputeLinearAndAngularMomentumDerivativeBias(model, linkPositions, linkVel, linkBiasAcc, totalMomentumBias):
    return _iDynTree.ComputeLinearAndAngularMomentumDerivativeBias(model, linkPositions, linkVel, linkBiasAcc, totalMomentumBias)
ComputeLinearAndAngularMomentumDerivativeBias = _iDynTree.ComputeLinearAndAngularMomentumDerivativeBias

def RNEADynamicPhase(model, traversal, jointPos, linksVel, linksProperAcc, linkExtForces, linkIntWrenches, baseForceAndJointTorques):
    return _iDynTree.RNEADynamicPhase(model, traversal, jointPos, linksVel, linksProperAcc, linkExtForces, linkIntWrenches, baseForceAndJointTorques)
RNEADynamicPhase = _iDynTree.RNEADynamicPhase

def CompositeRigidBodyAlgorithm(model, traversal, jointPos, linkCRBs, massMatrix):
    return _iDynTree.CompositeRigidBodyAlgorithm(model, traversal, jointPos, linkCRBs, massMatrix)
CompositeRigidBodyAlgorithm = _iDynTree.CompositeRigidBodyAlgorithm
class ArticulatedBodyAlgorithmInternalBuffers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ArticulatedBodyAlgorithmInternalBuffers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ArticulatedBodyAlgorithmInternalBuffers, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_ArticulatedBodyAlgorithmInternalBuffers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, model):
        return _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_isConsistent(self, model)
    __swig_setmethods__["S"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_set
    __swig_getmethods__["S"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_get
    if _newclass:
        S = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_set)
    __swig_setmethods__["U"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_set
    __swig_getmethods__["U"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_get
    if _newclass:
        U = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_set)
    __swig_setmethods__["D"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_set
    __swig_getmethods__["D"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_get
    if _newclass:
        D = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_set)
    __swig_setmethods__["u"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_set
    __swig_getmethods__["u"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_get
    if _newclass:
        u = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_set)
    __swig_setmethods__["linksVel"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_set
    __swig_getmethods__["linksVel"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_get
    if _newclass:
        linksVel = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_set)
    __swig_setmethods__["linksBiasAcceleration"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set
    __swig_getmethods__["linksBiasAcceleration"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get
    if _newclass:
        linksBiasAcceleration = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set)
    __swig_setmethods__["linksAccelerations"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set
    __swig_getmethods__["linksAccelerations"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get
    if _newclass:
        linksAccelerations = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set)
    __swig_setmethods__["linkABIs"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set
    __swig_getmethods__["linkABIs"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get
    if _newclass:
        linkABIs = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set)
    __swig_setmethods__["linksBiasWrench"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set
    __swig_getmethods__["linksBiasWrench"] = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get
    if _newclass:
        linksBiasWrench = _swig_property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set)
    __swig_destroy__ = _iDynTree.delete_ArticulatedBodyAlgorithmInternalBuffers
    __del__ = lambda self: None
ArticulatedBodyAlgorithmInternalBuffers_swigregister = _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_swigregister
ArticulatedBodyAlgorithmInternalBuffers_swigregister(ArticulatedBodyAlgorithmInternalBuffers)


def ArticulatedBodyAlgorithm(model, traversal, robotPos, robotVel, linkExtWrenches, jointTorques, buffers, robotAcc):
    return _iDynTree.ArticulatedBodyAlgorithm(model, traversal, robotPos, robotVel, linkExtWrenches, jointTorques, buffers, robotAcc)
ArticulatedBodyAlgorithm = _iDynTree.ArticulatedBodyAlgorithm

def InverseDynamicsInertialParametersRegressor(model, traversal, referenceFrame_H_link, linksVel, linksAcc, baseForceAndJointTorquesRegressor):
    return _iDynTree.InverseDynamicsInertialParametersRegressor(model, traversal, referenceFrame_H_link, linksVel, linksAcc, baseForceAndJointTorquesRegressor)
InverseDynamicsInertialParametersRegressor = _iDynTree.InverseDynamicsInertialParametersRegressor
SIX_AXIS_FORCE_TORQUE = _iDynTree.SIX_AXIS_FORCE_TORQUE
ACCELEROMETER = _iDynTree.ACCELEROMETER
GYROSCOPE = _iDynTree.GYROSCOPE
THREE_AXIS_ANGULAR_ACCELEROMETER = _iDynTree.THREE_AXIS_ANGULAR_ACCELEROMETER
THREE_AXIS_FORCE_TORQUE_CONTACT = _iDynTree.THREE_AXIS_FORCE_TORQUE_CONTACT

def isLinkSensor(type):
    return _iDynTree.isLinkSensor(type)
isLinkSensor = _iDynTree.isLinkSensor

def isJointSensor(type):
    return _iDynTree.isJointSensor(type)
isJointSensor = _iDynTree.isJointSensor

def getSensorTypeSize(type):
    return _iDynTree.getSensorTypeSize(type)
getSensorTypeSize = _iDynTree.getSensorTypeSize
class Sensor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sensor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Sensor
    __del__ = lambda self: None

    def getName(self):
        return _iDynTree.Sensor_getName(self)

    def getSensorType(self):
        return _iDynTree.Sensor_getSensorType(self)

    def isValid(self):
        return _iDynTree.Sensor_isValid(self)

    def setName(self, arg2):
        return _iDynTree.Sensor_setName(self, arg2)

    def clone(self):
        return _iDynTree.Sensor_clone(self)

    def isConsistent(self, model):
        return _iDynTree.Sensor_isConsistent(self, model)

    def updateIndices(self, model):
        return _iDynTree.Sensor_updateIndices(self, model)
Sensor_swigregister = _iDynTree.Sensor_swigregister
Sensor_swigregister(Sensor)
NR_OF_SENSOR_TYPES = cvar.NR_OF_SENSOR_TYPES

class JointSensor(Sensor):
    __swig_setmethods__ = {}
    for _s in [Sensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JointSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [Sensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JointSensor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_JointSensor
    __del__ = lambda self: None

    def getParentJoint(self):
        return _iDynTree.JointSensor_getParentJoint(self)

    def getParentJointIndex(self):
        return _iDynTree.JointSensor_getParentJointIndex(self)

    def setParentJoint(self, parentJointName):
        return _iDynTree.JointSensor_setParentJoint(self, parentJointName)

    def setParentJointIndex(self, arg2):
        return _iDynTree.JointSensor_setParentJointIndex(self, arg2)

    def isConsistent(self, model):
        return _iDynTree.JointSensor_isConsistent(self, model)
JointSensor_swigregister = _iDynTree.JointSensor_swigregister
JointSensor_swigregister(JointSensor)

class LinkSensor(Sensor):
    __swig_setmethods__ = {}
    for _s in [Sensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [Sensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinkSensor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_LinkSensor
    __del__ = lambda self: None

    def getParentLink(self):
        return _iDynTree.LinkSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.LinkSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.LinkSensor_getLinkSensorTransform(self)

    def setParentLink(self, parentLinkName):
        return _iDynTree.LinkSensor_setParentLink(self, parentLinkName)

    def setParentLinkIndex(self, arg2):
        return _iDynTree.LinkSensor_setParentLinkIndex(self, arg2)

    def setLinkSensorTransform(self, arg2):
        return _iDynTree.LinkSensor_setLinkSensorTransform(self, arg2)

    def isConsistent(self, model):
        return _iDynTree.LinkSensor_isConsistent(self, model)
LinkSensor_swigregister = _iDynTree.LinkSensor_swigregister
LinkSensor_swigregister(LinkSensor)

class SensorsList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SensorsList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SensorsList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SensorsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SensorsList
    __del__ = lambda self: None

    def addSensor(self, sensor):
        return _iDynTree.SensorsList_addSensor(self, sensor)

    def setSerialization(self, sensor_type, serializaton):
        return _iDynTree.SensorsList_setSerialization(self, sensor_type, serializaton)

    def getSerialization(self, sensor_type, serializaton):
        return _iDynTree.SensorsList_getSerialization(self, sensor_type, serializaton)

    def getNrOfSensors(self, sensor_type):
        return _iDynTree.SensorsList_getNrOfSensors(self, sensor_type)

    def getSensorIndex(self, *args):
        return _iDynTree.SensorsList_getSensorIndex(self, *args)

    def getSizeOfAllSensorsMeasurements(self):
        return _iDynTree.SensorsList_getSizeOfAllSensorsMeasurements(self)

    def getSensor(self, sensor_type, sensor_index):
        return _iDynTree.SensorsList_getSensor(self, sensor_type, sensor_index)

    def isConsistent(self, model):
        return _iDynTree.SensorsList_isConsistent(self, model)

    def removeSensor(self, *args):
        return _iDynTree.SensorsList_removeSensor(self, *args)

    def removeAllSensorsOfType(self, sensor_type):
        return _iDynTree.SensorsList_removeAllSensorsOfType(self, sensor_type)

    def getSixAxisForceTorqueSensor(self, sensor_index):
        return _iDynTree.SensorsList_getSixAxisForceTorqueSensor(self, sensor_index)

    def getAccelerometerSensor(self, sensor_index):
        return _iDynTree.SensorsList_getAccelerometerSensor(self, sensor_index)

    def getGyroscopeSensor(self, sensor_index):
        return _iDynTree.SensorsList_getGyroscopeSensor(self, sensor_index)

    def getThreeAxisAngularAccelerometerSensor(self, sensor_index):
        return _iDynTree.SensorsList_getThreeAxisAngularAccelerometerSensor(self, sensor_index)

    def getThreeAxisForceTorqueContactSensor(self, sensor_index):
        return _iDynTree.SensorsList_getThreeAxisForceTorqueContactSensor(self, sensor_index)
SensorsList_swigregister = _iDynTree.SensorsList_swigregister
SensorsList_swigregister(SensorsList)

class SensorsMeasurements(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SensorsMeasurements, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SensorsMeasurements, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SensorsMeasurements(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SensorsMeasurements
    __del__ = lambda self: None

    def setNrOfSensors(self, sensor_type, nrOfSensors):
        return _iDynTree.SensorsMeasurements_setNrOfSensors(self, sensor_type, nrOfSensors)

    def getNrOfSensors(self, sensor_type):
        return _iDynTree.SensorsMeasurements_getNrOfSensors(self, sensor_type)

    def resize(self, sensorsList):
        return _iDynTree.SensorsMeasurements_resize(self, sensorsList)

    def toVector(self, measurementVector):
        return _iDynTree.SensorsMeasurements_toVector(self, measurementVector)

    def setMeasurement(self, *args):
        return _iDynTree.SensorsMeasurements_setMeasurement(self, *args)

    def getMeasurement(self, *args):
        return _iDynTree.SensorsMeasurements_getMeasurement(self, *args)

    def getSizeOfAllSensorsMeasurements(self):
        return _iDynTree.SensorsMeasurements_getSizeOfAllSensorsMeasurements(self)
SensorsMeasurements_swigregister = _iDynTree.SensorsMeasurements_swigregister
SensorsMeasurements_swigregister(SensorsMeasurements)

class SixAxisForceTorqueSensor(JointSensor):
    __swig_setmethods__ = {}
    for _s in [JointSensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SixAxisForceTorqueSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [JointSensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SixAxisForceTorqueSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_SixAxisForceTorqueSensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SixAxisForceTorqueSensor
    __del__ = lambda self: None

    def setName(self, _name):
        return _iDynTree.SixAxisForceTorqueSensor_setName(self, _name)

    def setFirstLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_setFirstLinkSensorTransform(self, link_index, link_H_sensor)

    def setSecondLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_setSecondLinkSensorTransform(self, link_index, link_H_sensor)

    def getFirstLinkIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getFirstLinkIndex(self)

    def getSecondLinkIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSecondLinkIndex(self)

    def setFirstLinkName(self, name):
        return _iDynTree.SixAxisForceTorqueSensor_setFirstLinkName(self, name)

    def setSecondLinkName(self, name):
        return _iDynTree.SixAxisForceTorqueSensor_setSecondLinkName(self, name)

    def getFirstLinkName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getFirstLinkName(self)

    def getSecondLinkName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSecondLinkName(self)

    def setParentJoint(self, parent):
        return _iDynTree.SixAxisForceTorqueSensor_setParentJoint(self, parent)

    def setParentJointIndex(self, parent_index):
        return _iDynTree.SixAxisForceTorqueSensor_setParentJointIndex(self, parent_index)

    def setAppliedWrenchLink(self, applied_wrench_index):
        return _iDynTree.SixAxisForceTorqueSensor_setAppliedWrenchLink(self, applied_wrench_index)

    def getName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSensorType(self)

    def getParentJoint(self):
        return _iDynTree.SixAxisForceTorqueSensor_getParentJoint(self)

    def getParentJointIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getParentJointIndex(self)

    def isValid(self):
        return _iDynTree.SixAxisForceTorqueSensor_isValid(self)

    def clone(self):
        return _iDynTree.SixAxisForceTorqueSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.SixAxisForceTorqueSensor_updateIndices(self, model)

    def getAppliedWrenchLink(self):
        return _iDynTree.SixAxisForceTorqueSensor_getAppliedWrenchLink(self)

    def isLinkAttachedToSensor(self, link_index):
        return _iDynTree.SixAxisForceTorqueSensor_isLinkAttachedToSensor(self, link_index)

    def getLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_getLinkSensorTransform(self, link_index, link_H_sensor)

    def getWrenchAppliedOnLink(self, link_index, measured_wrench, wrench_applied_on_link):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLink(self, link_index, measured_wrench, wrench_applied_on_link)

    def getWrenchAppliedOnLinkMatrix(self, link_index, wrench_applied_on_link_matrix):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(self, link_index, wrench_applied_on_link_matrix)

    def getWrenchAppliedOnLinkInverseMatrix(self, link_index, wrench_applied_on_link_inverse_matrix):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(self, link_index, wrench_applied_on_link_inverse_matrix)

    def predictMeasurement(self, traversal, intWrenches):
        return _iDynTree.SixAxisForceTorqueSensor_predictMeasurement(self, traversal, intWrenches)

    def toString(self, model):
        return _iDynTree.SixAxisForceTorqueSensor_toString(self, model)
SixAxisForceTorqueSensor_swigregister = _iDynTree.SixAxisForceTorqueSensor_swigregister
SixAxisForceTorqueSensor_swigregister(SixAxisForceTorqueSensor)

class AccelerometerSensor(LinkSensor):
    __swig_setmethods__ = {}
    for _s in [LinkSensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AccelerometerSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [LinkSensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AccelerometerSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_AccelerometerSensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_AccelerometerSensor
    __del__ = lambda self: None

    def setName(self, _name):
        return _iDynTree.AccelerometerSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.AccelerometerSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.AccelerometerSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.AccelerometerSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.AccelerometerSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.AccelerometerSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.AccelerometerSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.AccelerometerSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.AccelerometerSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.AccelerometerSensor_isValid(self)

    def clone(self):
        return _iDynTree.AccelerometerSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.AccelerometerSensor_updateIndices(self, model)

    def predictMeasurement(self, linkAcc, linkTwist):
        return _iDynTree.AccelerometerSensor_predictMeasurement(self, linkAcc, linkTwist)
AccelerometerSensor_swigregister = _iDynTree.AccelerometerSensor_swigregister
AccelerometerSensor_swigregister(AccelerometerSensor)

class GyroscopeSensor(LinkSensor):
    __swig_setmethods__ = {}
    for _s in [LinkSensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GyroscopeSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [LinkSensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GyroscopeSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_GyroscopeSensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_GyroscopeSensor
    __del__ = lambda self: None

    def setName(self, _name):
        return _iDynTree.GyroscopeSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.GyroscopeSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.GyroscopeSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.GyroscopeSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.GyroscopeSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.GyroscopeSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.GyroscopeSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.GyroscopeSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.GyroscopeSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.GyroscopeSensor_isValid(self)

    def clone(self):
        return _iDynTree.GyroscopeSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.GyroscopeSensor_updateIndices(self, model)

    def predictMeasurement(self, linkVel):
        return _iDynTree.GyroscopeSensor_predictMeasurement(self, linkVel)
GyroscopeSensor_swigregister = _iDynTree.GyroscopeSensor_swigregister
GyroscopeSensor_swigregister(GyroscopeSensor)

class ThreeAxisAngularAccelerometerSensor(LinkSensor):
    __swig_setmethods__ = {}
    for _s in [LinkSensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreeAxisAngularAccelerometerSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [LinkSensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreeAxisAngularAccelerometerSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_ThreeAxisAngularAccelerometerSensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ThreeAxisAngularAccelerometerSensor
    __del__ = lambda self: None

    def setName(self, _name):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_isValid(self)

    def clone(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_updateIndices(self, model)

    def predictMeasurement(self, linkAcc):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_predictMeasurement(self, linkAcc)
ThreeAxisAngularAccelerometerSensor_swigregister = _iDynTree.ThreeAxisAngularAccelerometerSensor_swigregister
ThreeAxisAngularAccelerometerSensor_swigregister(ThreeAxisAngularAccelerometerSensor)

class ThreeAxisForceTorqueContactSensor(LinkSensor):
    __swig_setmethods__ = {}
    for _s in [LinkSensor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThreeAxisForceTorqueContactSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [LinkSensor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThreeAxisForceTorqueContactSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_ThreeAxisForceTorqueContactSensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ThreeAxisForceTorqueContactSensor
    __del__ = lambda self: None

    def setName(self, _name):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_isValid(self)

    def clone(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_updateIndices(self, model)

    def setLoadCellLocations(self, loadCellLocations):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setLoadCellLocations(self, loadCellLocations)

    def getLoadCellLocations(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getLoadCellLocations(self)

    def computeThreeAxisForceTorqueFromLoadCellMeasurements(self, loadCellMeasurements):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(self, loadCellMeasurements)

    def computeCenterOfPressureFromLoadCellMeasurements(self, loadCellMeasurements):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(self, loadCellMeasurements)
ThreeAxisForceTorqueContactSensor_swigregister = _iDynTree.ThreeAxisForceTorqueContactSensor_swigregister
ThreeAxisForceTorqueContactSensor_swigregister(ThreeAxisForceTorqueContactSensor)


def predictSensorsMeasurements(model, sensorList, traversal, robotPos, robotVel, robotAcc, gravity, externalWrenches, buf_properRobotAcc, buf_linkPos, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, buf_outputTorques, predictedMeasurement):
    return _iDynTree.predictSensorsMeasurements(model, sensorList, traversal, robotPos, robotVel, robotAcc, gravity, externalWrenches, buf_properRobotAcc, buf_linkPos, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, buf_outputTorques, predictedMeasurement)
predictSensorsMeasurements = _iDynTree.predictSensorsMeasurements

def predictSensorsMeasurementsFromRawBuffers(model, sensorList, traversal, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, predictedMeasurement):
    return _iDynTree.predictSensorsMeasurementsFromRawBuffers(model, sensorList, traversal, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, predictedMeasurement)
predictSensorsMeasurementsFromRawBuffers = _iDynTree.predictSensorsMeasurementsFromRawBuffers

def dofsListFromURDF(urdf_filename, dofs):
    return _iDynTree.dofsListFromURDF(urdf_filename, dofs)
dofsListFromURDF = _iDynTree.dofsListFromURDF

def dofsListFromURDFString(urdf_string, dofs):
    return _iDynTree.dofsListFromURDFString(urdf_string, dofs)
dofsListFromURDFString = _iDynTree.dofsListFromURDFString
class ModelParserOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelParserOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelParserOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["addSensorFramesAsAdditionalFrames"] = _iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_set
    __swig_getmethods__["addSensorFramesAsAdditionalFrames"] = _iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_get
    if _newclass:
        addSensorFramesAsAdditionalFrames = _swig_property(_iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_get, _iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_set)
    __swig_setmethods__["originalFilename"] = _iDynTree.ModelParserOptions_originalFilename_set
    __swig_getmethods__["originalFilename"] = _iDynTree.ModelParserOptions_originalFilename_get
    if _newclass:
        originalFilename = _swig_property(_iDynTree.ModelParserOptions_originalFilename_get, _iDynTree.ModelParserOptions_originalFilename_set)

    def __init__(self):
        this = _iDynTree.new_ModelParserOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ModelParserOptions
    __del__ = lambda self: None
ModelParserOptions_swigregister = _iDynTree.ModelParserOptions_swigregister
ModelParserOptions_swigregister(ModelParserOptions)

class ModelLoader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelLoader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelLoader, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_ModelLoader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ModelLoader
    __del__ = lambda self: None

    def parsingOptions(self):
        return _iDynTree.ModelLoader_parsingOptions(self)

    def setParsingOptions(self, options):
        return _iDynTree.ModelLoader_setParsingOptions(self, options)

    def loadModelFromString(self, *args):
        return _iDynTree.ModelLoader_loadModelFromString(self, *args)

    def loadModelFromFile(self, *args):
        return _iDynTree.ModelLoader_loadModelFromFile(self, *args)

    def loadReducedModelFromFullModel(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromFullModel(self, *args)

    def loadReducedModelFromString(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromString(self, *args)

    def loadReducedModelFromFile(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromFile(self, *args)

    def model(self):
        return _iDynTree.ModelLoader_model(self)

    def sensors(self):
        return _iDynTree.ModelLoader_sensors(self)

    def isValid(self):
        return _iDynTree.ModelLoader_isValid(self)
ModelLoader_swigregister = _iDynTree.ModelLoader_swigregister
ModelLoader_swigregister(ModelLoader)

class ModelExporterOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelExporterOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelExporterOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["baseLink"] = _iDynTree.ModelExporterOptions_baseLink_set
    __swig_getmethods__["baseLink"] = _iDynTree.ModelExporterOptions_baseLink_get
    if _newclass:
        baseLink = _swig_property(_iDynTree.ModelExporterOptions_baseLink_get, _iDynTree.ModelExporterOptions_baseLink_set)
    __swig_setmethods__["exportFirstBaseLinkAdditionalFrameAsFakeURDFBase"] = _iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set
    __swig_getmethods__["exportFirstBaseLinkAdditionalFrameAsFakeURDFBase"] = _iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get
    if _newclass:
        exportFirstBaseLinkAdditionalFrameAsFakeURDFBase = _swig_property(_iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get, _iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set)
    __swig_setmethods__["robotExportedName"] = _iDynTree.ModelExporterOptions_robotExportedName_set
    __swig_getmethods__["robotExportedName"] = _iDynTree.ModelExporterOptions_robotExportedName_get
    if _newclass:
        robotExportedName = _swig_property(_iDynTree.ModelExporterOptions_robotExportedName_get, _iDynTree.ModelExporterOptions_robotExportedName_set)

    def __init__(self):
        this = _iDynTree.new_ModelExporterOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ModelExporterOptions
    __del__ = lambda self: None
ModelExporterOptions_swigregister = _iDynTree.ModelExporterOptions_swigregister
ModelExporterOptions_swigregister(ModelExporterOptions)

class ModelExporter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelExporter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelExporter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_ModelExporter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ModelExporter
    __del__ = lambda self: None

    def exportingOptions(self):
        return _iDynTree.ModelExporter_exportingOptions(self)

    def setExportingOptions(self, options):
        return _iDynTree.ModelExporter_setExportingOptions(self, options)

    def init(self, *args):
        return _iDynTree.ModelExporter_init(self, *args)

    def model(self):
        return _iDynTree.ModelExporter_model(self)

    def sensors(self):
        return _iDynTree.ModelExporter_sensors(self)

    def isValid(self):
        return _iDynTree.ModelExporter_isValid(self)

    def exportModelToString(self, *args):
        return _iDynTree.ModelExporter_exportModelToString(self, *args)

    def exportModelToFile(self, *args):
        return _iDynTree.ModelExporter_exportModelToFile(self, *args)
ModelExporter_swigregister = _iDynTree.ModelExporter_swigregister
ModelExporter_swigregister(ModelExporter)

class ModelCalibrationHelper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelCalibrationHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModelCalibrationHelper, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_ModelCalibrationHelper()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ModelCalibrationHelper
    __del__ = lambda self: None

    def loadModelFromString(self, *args):
        return _iDynTree.ModelCalibrationHelper_loadModelFromString(self, *args)

    def loadModelFromFile(self, *args):
        return _iDynTree.ModelCalibrationHelper_loadModelFromFile(self, *args)

    def updateModelInertialParametersToString(self, *args):
        return _iDynTree.ModelCalibrationHelper_updateModelInertialParametersToString(self, *args)

    def updateModelInertialParametersToFile(self, *args):
        return _iDynTree.ModelCalibrationHelper_updateModelInertialParametersToFile(self, *args)

    def model(self):
        return _iDynTree.ModelCalibrationHelper_model(self)

    def sensors(self):
        return _iDynTree.ModelCalibrationHelper_sensors(self)

    def isValid(self):
        return _iDynTree.ModelCalibrationHelper_isValid(self)
ModelCalibrationHelper_swigregister = _iDynTree.ModelCalibrationHelper_swigregister
ModelCalibrationHelper_swigregister(ModelCalibrationHelper)

FULL_WRENCH = _iDynTree.FULL_WRENCH
PURE_FORCE = _iDynTree.PURE_FORCE
PURE_FORCE_WITH_KNOWN_DIRECTION = _iDynTree.PURE_FORCE_WITH_KNOWN_DIRECTION
NO_UNKNOWNS = _iDynTree.NO_UNKNOWNS
class UnknownWrenchContact(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnknownWrenchContact, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnknownWrenchContact, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_UnknownWrenchContact(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["unknownType"] = _iDynTree.UnknownWrenchContact_unknownType_set
    __swig_getmethods__["unknownType"] = _iDynTree.UnknownWrenchContact_unknownType_get
    if _newclass:
        unknownType = _swig_property(_iDynTree.UnknownWrenchContact_unknownType_get, _iDynTree.UnknownWrenchContact_unknownType_set)
    __swig_setmethods__["contactPoint"] = _iDynTree.UnknownWrenchContact_contactPoint_set
    __swig_getmethods__["contactPoint"] = _iDynTree.UnknownWrenchContact_contactPoint_get
    if _newclass:
        contactPoint = _swig_property(_iDynTree.UnknownWrenchContact_contactPoint_get, _iDynTree.UnknownWrenchContact_contactPoint_set)
    __swig_setmethods__["forceDirection"] = _iDynTree.UnknownWrenchContact_forceDirection_set
    __swig_getmethods__["forceDirection"] = _iDynTree.UnknownWrenchContact_forceDirection_get
    if _newclass:
        forceDirection = _swig_property(_iDynTree.UnknownWrenchContact_forceDirection_get, _iDynTree.UnknownWrenchContact_forceDirection_set)
    __swig_setmethods__["knownWrench"] = _iDynTree.UnknownWrenchContact_knownWrench_set
    __swig_getmethods__["knownWrench"] = _iDynTree.UnknownWrenchContact_knownWrench_get
    if _newclass:
        knownWrench = _swig_property(_iDynTree.UnknownWrenchContact_knownWrench_get, _iDynTree.UnknownWrenchContact_knownWrench_set)
    __swig_setmethods__["contactId"] = _iDynTree.UnknownWrenchContact_contactId_set
    __swig_getmethods__["contactId"] = _iDynTree.UnknownWrenchContact_contactId_get
    if _newclass:
        contactId = _swig_property(_iDynTree.UnknownWrenchContact_contactId_get, _iDynTree.UnknownWrenchContact_contactId_set)
    __swig_destroy__ = _iDynTree.delete_UnknownWrenchContact
    __del__ = lambda self: None
UnknownWrenchContact_swigregister = _iDynTree.UnknownWrenchContact_swigregister
UnknownWrenchContact_swigregister(UnknownWrenchContact)

class LinkUnknownWrenchContacts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkUnknownWrenchContacts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkUnknownWrenchContacts, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_LinkUnknownWrenchContacts(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clear(self):
        return _iDynTree.LinkUnknownWrenchContacts_clear(self)

    def resize(self, *args):
        return _iDynTree.LinkUnknownWrenchContacts_resize(self, *args)

    def getNrOfContactsForLink(self, linkIndex):
        return _iDynTree.LinkUnknownWrenchContacts_getNrOfContactsForLink(self, linkIndex)

    def setNrOfContactsForLink(self, linkIndex, nrOfContacts):
        return _iDynTree.LinkUnknownWrenchContacts_setNrOfContactsForLink(self, linkIndex, nrOfContacts)

    def addNewContactForLink(self, linkIndex, newContact):
        return _iDynTree.LinkUnknownWrenchContacts_addNewContactForLink(self, linkIndex, newContact)

    def addNewContactInFrame(self, model, frameIndex, newContact):
        return _iDynTree.LinkUnknownWrenchContacts_addNewContactInFrame(self, model, frameIndex, newContact)

    def addNewUnknownFullWrenchInFrameOrigin(self, model, frameIndex):
        return _iDynTree.LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin(self, model, frameIndex)

    def contactWrench(self, *args):
        return _iDynTree.LinkUnknownWrenchContacts_contactWrench(self, *args)

    def toString(self, model):
        return _iDynTree.LinkUnknownWrenchContacts_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkUnknownWrenchContacts
    __del__ = lambda self: None
LinkUnknownWrenchContacts_swigregister = _iDynTree.LinkUnknownWrenchContacts_swigregister
LinkUnknownWrenchContacts_swigregister(LinkUnknownWrenchContacts)

class estimateExternalWrenchesBuffers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, estimateExternalWrenchesBuffers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, estimateExternalWrenchesBuffers, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _iDynTree.new_estimateExternalWrenchesBuffers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, *args):
        return _iDynTree.estimateExternalWrenchesBuffers_resize(self, *args)

    def getNrOfSubModels(self):
        return _iDynTree.estimateExternalWrenchesBuffers_getNrOfSubModels(self)

    def getNrOfLinks(self):
        return _iDynTree.estimateExternalWrenchesBuffers_getNrOfLinks(self)

    def isConsistent(self, subModels):
        return _iDynTree.estimateExternalWrenchesBuffers_isConsistent(self, subModels)
    __swig_setmethods__["A"] = _iDynTree.estimateExternalWrenchesBuffers_A_set
    __swig_getmethods__["A"] = _iDynTree.estimateExternalWrenchesBuffers_A_get
    if _newclass:
        A = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_A_get, _iDynTree.estimateExternalWrenchesBuffers_A_set)
    __swig_setmethods__["x"] = _iDynTree.estimateExternalWrenchesBuffers_x_set
    __swig_getmethods__["x"] = _iDynTree.estimateExternalWrenchesBuffers_x_get
    if _newclass:
        x = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_x_get, _iDynTree.estimateExternalWrenchesBuffers_x_set)
    __swig_setmethods__["b"] = _iDynTree.estimateExternalWrenchesBuffers_b_set
    __swig_getmethods__["b"] = _iDynTree.estimateExternalWrenchesBuffers_b_get
    if _newclass:
        b = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_b_get, _iDynTree.estimateExternalWrenchesBuffers_b_set)
    __swig_setmethods__["pinvA"] = _iDynTree.estimateExternalWrenchesBuffers_pinvA_set
    __swig_getmethods__["pinvA"] = _iDynTree.estimateExternalWrenchesBuffers_pinvA_get
    if _newclass:
        pinvA = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_pinvA_get, _iDynTree.estimateExternalWrenchesBuffers_pinvA_set)
    __swig_setmethods__["b_contacts_subtree"] = _iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_set
    __swig_getmethods__["b_contacts_subtree"] = _iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_get
    if _newclass:
        b_contacts_subtree = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_get, _iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_set)
    __swig_setmethods__["subModelBase_H_link"] = _iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_set
    __swig_getmethods__["subModelBase_H_link"] = _iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_get
    if _newclass:
        subModelBase_H_link = _swig_property(_iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_get, _iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_set)
    __swig_destroy__ = _iDynTree.delete_estimateExternalWrenchesBuffers
    __del__ = lambda self: None
estimateExternalWrenchesBuffers_swigregister = _iDynTree.estimateExternalWrenchesBuffers_swigregister
estimateExternalWrenchesBuffers_swigregister(estimateExternalWrenchesBuffers)


def estimateExternalWrenchesWithoutInternalFT(model, traversal, unknownWrenches, jointPos, linkVel, linkProperAcc, bufs, outputContactWrenches):
    return _iDynTree.estimateExternalWrenchesWithoutInternalFT(model, traversal, unknownWrenches, jointPos, linkVel, linkProperAcc, bufs, outputContactWrenches)
estimateExternalWrenchesWithoutInternalFT = _iDynTree.estimateExternalWrenchesWithoutInternalFT

def estimateExternalWrenches(model, subModels, sensors, unknownWrenches, jointPos, linkVel, linkProperAcc, ftSensorsMeasurements, bufs, outputContactWrenches):
    return _iDynTree.estimateExternalWrenches(model, subModels, sensors, unknownWrenches, jointPos, linkVel, linkProperAcc, ftSensorsMeasurements, bufs, outputContactWrenches)
estimateExternalWrenches = _iDynTree.estimateExternalWrenches

def dynamicsEstimationForwardVelAccKinematics(model, traversal, base_classicalProperAcc, base_angularVel, base_angularAcc, jointPos, jointVel, jointAcc, linkVel, linkProperAcc):
    return _iDynTree.dynamicsEstimationForwardVelAccKinematics(model, traversal, base_classicalProperAcc, base_angularVel, base_angularAcc, jointPos, jointVel, jointAcc, linkVel, linkProperAcc)
dynamicsEstimationForwardVelAccKinematics = _iDynTree.dynamicsEstimationForwardVelAccKinematics

def dynamicsEstimationForwardVelKinematics(model, traversal, base_angularVel, jointPos, jointVel, linkVel):
    return _iDynTree.dynamicsEstimationForwardVelKinematics(model, traversal, base_angularVel, jointPos, jointVel, linkVel)
dynamicsEstimationForwardVelKinematics = _iDynTree.dynamicsEstimationForwardVelKinematics

def computeLinkNetWrenchesWithoutGravity(model, linkVel, linkProperAcc, linkNetWrenchesWithoutGravity):
    return _iDynTree.computeLinkNetWrenchesWithoutGravity(model, linkVel, linkProperAcc, linkNetWrenchesWithoutGravity)
computeLinkNetWrenchesWithoutGravity = _iDynTree.computeLinkNetWrenchesWithoutGravity

def estimateLinkContactWrenchesFromLinkNetExternalWrenches(model, unknownWrenches, netExtWrenches, outputContactWrenches):
    return _iDynTree.estimateLinkContactWrenchesFromLinkNetExternalWrenches(model, unknownWrenches, netExtWrenches, outputContactWrenches)
estimateLinkContactWrenchesFromLinkNetExternalWrenches = _iDynTree.estimateLinkContactWrenchesFromLinkNetExternalWrenches
class ExtWrenchesAndJointTorquesEstimator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtWrenchesAndJointTorquesEstimator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExtWrenchesAndJointTorquesEstimator, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_ExtWrenchesAndJointTorquesEstimator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ExtWrenchesAndJointTorquesEstimator
    __del__ = lambda self: None

    def setModelAndSensors(self, _model, _sensors):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_setModelAndSensors(self, _model, _sensors)

    def loadModelAndSensorsFromFile(self, *args):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile(self, *args)

    def loadModelAndSensorsFromFileWithSpecifiedDOFs(self, *args):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs(self, *args)

    def model(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_model(self)

    def sensors(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_sensors(self)

    def submodels(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_submodels(self)

    def updateKinematicsFromFloatingBase(self, jointPos, jointVel, jointAcc, floatingFrame, properClassicalLinearAcceleration, angularVel, angularAcc):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase(self, jointPos, jointVel, jointAcc, floatingFrame, properClassicalLinearAcceleration, angularVel, angularAcc)

    def updateKinematicsFromFixedBase(self, jointPos, jointVel, jointAcc, fixedFrame, gravity):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase(self, jointPos, jointVel, jointAcc, fixedFrame, gravity)

    def computeExpectedFTSensorsMeasurements(self, unknowns, predictedMeasures, estimatedContactWrenches, estimatedJointTorques):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements(self, unknowns, predictedMeasures, estimatedContactWrenches, estimatedJointTorques)

    def estimateExtWrenchesAndJointTorques(self, unknowns, ftSensorsMeasures, estimatedContactWrenches, estimatedJointTorques):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques(self, unknowns, ftSensorsMeasures, estimatedContactWrenches, estimatedJointTorques)

    def checkThatTheModelIsStill(self, gravityNorm, properAccTol, verbose):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill(self, gravityNorm, properAccTol, verbose)

    def estimateLinkNetWrenchesWithoutGravity(self, netWrenches):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity(self, netWrenches)
ExtWrenchesAndJointTorquesEstimator_swigregister = _iDynTree.ExtWrenchesAndJointTorquesEstimator_swigregister
ExtWrenchesAndJointTorquesEstimator_swigregister(ExtWrenchesAndJointTorquesEstimator)

class SimpleLeggedOdometry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleLeggedOdometry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleLeggedOdometry, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_SimpleLeggedOdometry()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_SimpleLeggedOdometry
    __del__ = lambda self: None

    def setModel(self, _model):
        return _iDynTree.SimpleLeggedOdometry_setModel(self, _model)

    def model(self):
        return _iDynTree.SimpleLeggedOdometry_model(self)

    def updateKinematics(self, jointPos):
        return _iDynTree.SimpleLeggedOdometry_updateKinematics(self, jointPos)

    def init(self, *args):
        return _iDynTree.SimpleLeggedOdometry_init(self, *args)

    def changeFixedFrame(self, *args):
        return _iDynTree.SimpleLeggedOdometry_changeFixedFrame(self, *args)

    def getCurrentFixedLink(self):
        return _iDynTree.SimpleLeggedOdometry_getCurrentFixedLink(self)

    def getWorldLinkTransform(self, frame_index):
        return _iDynTree.SimpleLeggedOdometry_getWorldLinkTransform(self, frame_index)

    def getWorldFrameTransform(self, frame_index):
        return _iDynTree.SimpleLeggedOdometry_getWorldFrameTransform(self, frame_index)
SimpleLeggedOdometry_swigregister = _iDynTree.SimpleLeggedOdometry_swigregister
SimpleLeggedOdometry_swigregister(SimpleLeggedOdometry)

ORIGINAL_BERDY_FIXED_BASE = _iDynTree.ORIGINAL_BERDY_FIXED_BASE
BERDY_FLOATING_BASE = _iDynTree.BERDY_FLOATING_BASE
LINK_BODY_PROPER_ACCELERATION = _iDynTree.LINK_BODY_PROPER_ACCELERATION
NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV = _iDynTree.NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV
JOINT_WRENCH = _iDynTree.JOINT_WRENCH
DOF_TORQUE = _iDynTree.DOF_TORQUE
NET_EXT_WRENCH = _iDynTree.NET_EXT_WRENCH
DOF_ACCELERATION = _iDynTree.DOF_ACCELERATION
LINK_BODY_PROPER_CLASSICAL_ACCELERATION = _iDynTree.LINK_BODY_PROPER_CLASSICAL_ACCELERATION
SIX_AXIS_FORCE_TORQUE_SENSOR = _iDynTree.SIX_AXIS_FORCE_TORQUE_SENSOR
ACCELEROMETER_SENSOR = _iDynTree.ACCELEROMETER_SENSOR
GYROSCOPE_SENSOR = _iDynTree.GYROSCOPE_SENSOR
THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR = _iDynTree.THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR
THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR = _iDynTree.THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR
DOF_ACCELERATION_SENSOR = _iDynTree.DOF_ACCELERATION_SENSOR
DOF_TORQUE_SENSOR = _iDynTree.DOF_TORQUE_SENSOR
NET_EXT_WRENCH_SENSOR = _iDynTree.NET_EXT_WRENCH_SENSOR
JOINT_WRENCH_SENSOR = _iDynTree.JOINT_WRENCH_SENSOR

def isLinkBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isLinkBerdyDynamicVariable(dynamicVariableType)
isLinkBerdyDynamicVariable = _iDynTree.isLinkBerdyDynamicVariable

def isJointBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isJointBerdyDynamicVariable(dynamicVariableType)
isJointBerdyDynamicVariable = _iDynTree.isJointBerdyDynamicVariable

def isDOFBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isDOFBerdyDynamicVariable(dynamicVariableType)
isDOFBerdyDynamicVariable = _iDynTree.isDOFBerdyDynamicVariable
class BerdyOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdyOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdyOptions, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_BerdyOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["berdyVariant"] = _iDynTree.BerdyOptions_berdyVariant_set
    __swig_getmethods__["berdyVariant"] = _iDynTree.BerdyOptions_berdyVariant_get
    if _newclass:
        berdyVariant = _swig_property(_iDynTree.BerdyOptions_berdyVariant_get, _iDynTree.BerdyOptions_berdyVariant_set)
    __swig_setmethods__["includeAllNetExternalWrenchesAsDynamicVariables"] = _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set
    __swig_getmethods__["includeAllNetExternalWrenchesAsDynamicVariables"] = _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get
    if _newclass:
        includeAllNetExternalWrenchesAsDynamicVariables = _swig_property(_iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get, _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set)
    __swig_setmethods__["includeAllJointAccelerationsAsSensors"] = _iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_set
    __swig_getmethods__["includeAllJointAccelerationsAsSensors"] = _iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_get
    if _newclass:
        includeAllJointAccelerationsAsSensors = _swig_property(_iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_get, _iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_set)
    __swig_setmethods__["includeAllJointTorquesAsSensors"] = _iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_set
    __swig_getmethods__["includeAllJointTorquesAsSensors"] = _iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_get
    if _newclass:
        includeAllJointTorquesAsSensors = _swig_property(_iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_get, _iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_set)
    __swig_setmethods__["includeAllNetExternalWrenchesAsSensors"] = _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_set
    __swig_getmethods__["includeAllNetExternalWrenchesAsSensors"] = _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_get
    if _newclass:
        includeAllNetExternalWrenchesAsSensors = _swig_property(_iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_get, _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_set)
    __swig_setmethods__["includeFixedBaseExternalWrench"] = _iDynTree.BerdyOptions_includeFixedBaseExternalWrench_set
    __swig_getmethods__["includeFixedBaseExternalWrench"] = _iDynTree.BerdyOptions_includeFixedBaseExternalWrench_get
    if _newclass:
        includeFixedBaseExternalWrench = _swig_property(_iDynTree.BerdyOptions_includeFixedBaseExternalWrench_get, _iDynTree.BerdyOptions_includeFixedBaseExternalWrench_set)
    __swig_setmethods__["jointOnWhichTheInternalWrenchIsMeasured"] = _iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set
    __swig_getmethods__["jointOnWhichTheInternalWrenchIsMeasured"] = _iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get
    if _newclass:
        jointOnWhichTheInternalWrenchIsMeasured = _swig_property(_iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get, _iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set)
    __swig_setmethods__["baseLink"] = _iDynTree.BerdyOptions_baseLink_set
    __swig_getmethods__["baseLink"] = _iDynTree.BerdyOptions_baseLink_get
    if _newclass:
        baseLink = _swig_property(_iDynTree.BerdyOptions_baseLink_get, _iDynTree.BerdyOptions_baseLink_set)

    def checkConsistency(self):
        return _iDynTree.BerdyOptions_checkConsistency(self)
    __swig_destroy__ = _iDynTree.delete_BerdyOptions
    __del__ = lambda self: None
BerdyOptions_swigregister = _iDynTree.BerdyOptions_swigregister
BerdyOptions_swigregister(BerdyOptions)

class BerdySensor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdySensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdySensor, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _iDynTree.BerdySensor_type_set
    __swig_getmethods__["type"] = _iDynTree.BerdySensor_type_get
    if _newclass:
        type = _swig_property(_iDynTree.BerdySensor_type_get, _iDynTree.BerdySensor_type_set)
    __swig_setmethods__["id"] = _iDynTree.BerdySensor_id_set
    __swig_getmethods__["id"] = _iDynTree.BerdySensor_id_get
    if _newclass:
        id = _swig_property(_iDynTree.BerdySensor_id_get, _iDynTree.BerdySensor_id_set)
    __swig_setmethods__["range"] = _iDynTree.BerdySensor_range_set
    __swig_getmethods__["range"] = _iDynTree.BerdySensor_range_get
    if _newclass:
        range = _swig_property(_iDynTree.BerdySensor_range_get, _iDynTree.BerdySensor_range_set)

    def __eq__(self, sensor):
        return _iDynTree.BerdySensor___eq__(self, sensor)

    def __lt__(self, sensor):
        return _iDynTree.BerdySensor___lt__(self, sensor)

    def __init__(self):
        this = _iDynTree.new_BerdySensor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_BerdySensor
    __del__ = lambda self: None
BerdySensor_swigregister = _iDynTree.BerdySensor_swigregister
BerdySensor_swigregister(BerdySensor)

class BerdyDynamicVariable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdyDynamicVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdyDynamicVariable, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _iDynTree.BerdyDynamicVariable_type_set
    __swig_getmethods__["type"] = _iDynTree.BerdyDynamicVariable_type_get
    if _newclass:
        type = _swig_property(_iDynTree.BerdyDynamicVariable_type_get, _iDynTree.BerdyDynamicVariable_type_set)
    __swig_setmethods__["id"] = _iDynTree.BerdyDynamicVariable_id_set
    __swig_getmethods__["id"] = _iDynTree.BerdyDynamicVariable_id_get
    if _newclass:
        id = _swig_property(_iDynTree.BerdyDynamicVariable_id_get, _iDynTree.BerdyDynamicVariable_id_set)
    __swig_setmethods__["range"] = _iDynTree.BerdyDynamicVariable_range_set
    __swig_getmethods__["range"] = _iDynTree.BerdyDynamicVariable_range_get
    if _newclass:
        range = _swig_property(_iDynTree.BerdyDynamicVariable_range_get, _iDynTree.BerdyDynamicVariable_range_set)

    def __eq__(self, variable):
        return _iDynTree.BerdyDynamicVariable___eq__(self, variable)

    def __lt__(self, variable):
        return _iDynTree.BerdyDynamicVariable___lt__(self, variable)

    def __init__(self):
        this = _iDynTree.new_BerdyDynamicVariable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_BerdyDynamicVariable
    __del__ = lambda self: None
BerdyDynamicVariable_swigregister = _iDynTree.BerdyDynamicVariable_swigregister
BerdyDynamicVariable_swigregister(BerdyDynamicVariable)

class BerdyHelper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdyHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdyHelper, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_BerdyHelper()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dynamicTraversal(self):
        return _iDynTree.BerdyHelper_dynamicTraversal(self)

    def model(self, *args):
        return _iDynTree.BerdyHelper_model(self, *args)

    def sensors(self, *args):
        return _iDynTree.BerdyHelper_sensors(self, *args)

    def isValid(self):
        return _iDynTree.BerdyHelper_isValid(self)

    def init(self, *args):
        return _iDynTree.BerdyHelper_init(self, *args)

    def getOptions(self):
        return _iDynTree.BerdyHelper_getOptions(self)

    def getNrOfDynamicVariables(self):
        return _iDynTree.BerdyHelper_getNrOfDynamicVariables(self)

    def getNrOfDynamicEquations(self):
        return _iDynTree.BerdyHelper_getNrOfDynamicEquations(self)

    def getNrOfSensorsMeasurements(self):
        return _iDynTree.BerdyHelper_getNrOfSensorsMeasurements(self)

    def resizeAndZeroBerdyMatrices(self, *args):
        return _iDynTree.BerdyHelper_resizeAndZeroBerdyMatrices(self, *args)

    def getBerdyMatrices(self, *args):
        return _iDynTree.BerdyHelper_getBerdyMatrices(self, *args)

    def getSensorsOrdering(self):
        return _iDynTree.BerdyHelper_getSensorsOrdering(self)

    def getRangeSensorVariable(self, type, sensorIdx):
        return _iDynTree.BerdyHelper_getRangeSensorVariable(self, type, sensorIdx)

    def getRangeDOFSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeDOFSensorVariable(self, sensorType, idx)

    def getRangeJointSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeJointSensorVariable(self, sensorType, idx)

    def getRangeLinkSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeLinkSensorVariable(self, sensorType, idx)

    def getRangeLinkVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeLinkVariable(self, dynamicVariableType, idx)

    def getRangeJointVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeJointVariable(self, dynamicVariableType, idx)

    def getRangeDOFVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeDOFVariable(self, dynamicVariableType, idx)

    def getDynamicVariablesOrdering(self):
        return _iDynTree.BerdyHelper_getDynamicVariablesOrdering(self)

    def serializeDynamicVariables(self, properAccs, netTotalWrenchesWithoutGrav, netExtWrenches, linkJointWrenches, jointTorques, jointAccs, d):
        return _iDynTree.BerdyHelper_serializeDynamicVariables(self, properAccs, netTotalWrenchesWithoutGrav, netExtWrenches, linkJointWrenches, jointTorques, jointAccs, d)

    def serializeSensorVariables(self, sensMeas, netExtWrenches, jointTorques, jointAccs, linkJointWrenches, y):
        return _iDynTree.BerdyHelper_serializeSensorVariables(self, sensMeas, netExtWrenches, jointTorques, jointAccs, linkJointWrenches, y)

    def serializeDynamicVariablesComputedFromFixedBaseRNEA(self, jointAccs, netExtWrenches, d):
        return _iDynTree.BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA(self, jointAccs, netExtWrenches, d)

    def extractJointTorquesFromDynamicVariables(self, d, jointPos, jointTorques):
        return _iDynTree.BerdyHelper_extractJointTorquesFromDynamicVariables(self, d, jointPos, jointTorques)

    def extractLinkNetExternalWrenchesFromDynamicVariables(self, d, netExtWrenches):
        return _iDynTree.BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables(self, d, netExtWrenches)

    def updateKinematicsFromFloatingBase(self, jointPos, jointVel, floatingFrame, angularVel):
        return _iDynTree.BerdyHelper_updateKinematicsFromFloatingBase(self, jointPos, jointVel, floatingFrame, angularVel)

    def updateKinematicsFromFixedBase(self, jointPos, jointVel, fixedFrame, gravity):
        return _iDynTree.BerdyHelper_updateKinematicsFromFixedBase(self, jointPos, jointVel, fixedFrame, gravity)

    def updateKinematicsFromTraversalFixedBase(self, jointPos, jointVel, gravity):
        return _iDynTree.BerdyHelper_updateKinematicsFromTraversalFixedBase(self, jointPos, jointVel, gravity)

    def setNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact):
        return _iDynTree.BerdyHelper_setNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact)

    def getNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact):
        return _iDynTree.BerdyHelper_getNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact)
    __swig_destroy__ = _iDynTree.delete_BerdyHelper
    __del__ = lambda self: None
BerdyHelper_swigregister = _iDynTree.BerdyHelper_swigregister
BerdyHelper_swigregister(BerdyHelper)

class BerdySparseMAPSolver(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BerdySparseMAPSolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BerdySparseMAPSolver, name)
    __repr__ = _swig_repr

    def __init__(self, berdyHelper):
        this = _iDynTree.new_BerdySparseMAPSolver(berdyHelper)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_BerdySparseMAPSolver
    __del__ = lambda self: None

    def setDynamicsConstraintsPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance(self, covariance)

    def setDynamicsRegularizationPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance(self, covariance)

    def setDynamicsRegularizationPriorExpectedValue(self, expectedValue):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue(self, expectedValue)

    def setMeasurementsPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setMeasurementsPriorCovariance(self, covariance)

    def dynamicsConstraintsPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse(self, *args)

    def dynamicsRegularizationPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse(self, *args)

    def dynamicsRegularizationPriorExpectedValue(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue(self, *args)

    def measurementsPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_measurementsPriorCovarianceInverse(self, *args)

    def isValid(self):
        return _iDynTree.BerdySparseMAPSolver_isValid(self)

    def initialize(self):
        return _iDynTree.BerdySparseMAPSolver_initialize(self)

    def updateEstimateInformationFixedBase(self, jointsConfiguration, jointsVelocity, fixedFrame, gravityInFixedFrame, measurements):
        return _iDynTree.BerdySparseMAPSolver_updateEstimateInformationFixedBase(self, jointsConfiguration, jointsVelocity, fixedFrame, gravityInFixedFrame, measurements)

    def updateEstimateInformationFloatingBase(self, jointsConfiguration, jointsVelocity, floatingFrame, bodyAngularVelocityOfSpecifiedFrame, measurements):
        return _iDynTree.BerdySparseMAPSolver_updateEstimateInformationFloatingBase(self, jointsConfiguration, jointsVelocity, floatingFrame, bodyAngularVelocityOfSpecifiedFrame, measurements)

    def doEstimate(self):
        return _iDynTree.BerdySparseMAPSolver_doEstimate(self)

    def getLastEstimate(self, *args):
        return _iDynTree.BerdySparseMAPSolver_getLastEstimate(self, *args)
BerdySparseMAPSolver_swigregister = _iDynTree.BerdySparseMAPSolver_swigregister
BerdySparseMAPSolver_swigregister(BerdySparseMAPSolver)

class AttitudeEstimatorState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttitudeEstimatorState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttitudeEstimatorState, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_orientation"] = _iDynTree.AttitudeEstimatorState_m_orientation_set
    __swig_getmethods__["m_orientation"] = _iDynTree.AttitudeEstimatorState_m_orientation_get
    if _newclass:
        m_orientation = _swig_property(_iDynTree.AttitudeEstimatorState_m_orientation_get, _iDynTree.AttitudeEstimatorState_m_orientation_set)
    __swig_setmethods__["m_angular_velocity"] = _iDynTree.AttitudeEstimatorState_m_angular_velocity_set
    __swig_getmethods__["m_angular_velocity"] = _iDynTree.AttitudeEstimatorState_m_angular_velocity_get
    if _newclass:
        m_angular_velocity = _swig_property(_iDynTree.AttitudeEstimatorState_m_angular_velocity_get, _iDynTree.AttitudeEstimatorState_m_angular_velocity_set)
    __swig_setmethods__["m_gyroscope_bias"] = _iDynTree.AttitudeEstimatorState_m_gyroscope_bias_set
    __swig_getmethods__["m_gyroscope_bias"] = _iDynTree.AttitudeEstimatorState_m_gyroscope_bias_get
    if _newclass:
        m_gyroscope_bias = _swig_property(_iDynTree.AttitudeEstimatorState_m_gyroscope_bias_get, _iDynTree.AttitudeEstimatorState_m_gyroscope_bias_set)

    def __init__(self):
        this = _iDynTree.new_AttitudeEstimatorState()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_AttitudeEstimatorState
    __del__ = lambda self: None
AttitudeEstimatorState_swigregister = _iDynTree.AttitudeEstimatorState_swigregister
AttitudeEstimatorState_swigregister(AttitudeEstimatorState)

class IAttitudeEstimator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAttitudeEstimator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAttitudeEstimator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IAttitudeEstimator
    __del__ = lambda self: None

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.IAttitudeEstimator_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.IAttitudeEstimator_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.IAttitudeEstimator_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.IAttitudeEstimator_setInternalStateInitialOrientation(self, orientationBuffer)
IAttitudeEstimator_swigregister = _iDynTree.IAttitudeEstimator_swigregister
IAttitudeEstimator_swigregister(IAttitudeEstimator)

class AttitudeMahonyFilterParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttitudeMahonyFilterParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttitudeMahonyFilterParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["time_step_in_seconds"] = _iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_set
    __swig_getmethods__["time_step_in_seconds"] = _iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_get
    if _newclass:
        time_step_in_seconds = _swig_property(_iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_get, _iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_set)
    __swig_setmethods__["kp"] = _iDynTree.AttitudeMahonyFilterParameters_kp_set
    __swig_getmethods__["kp"] = _iDynTree.AttitudeMahonyFilterParameters_kp_get
    if _newclass:
        kp = _swig_property(_iDynTree.AttitudeMahonyFilterParameters_kp_get, _iDynTree.AttitudeMahonyFilterParameters_kp_set)
    __swig_setmethods__["ki"] = _iDynTree.AttitudeMahonyFilterParameters_ki_set
    __swig_getmethods__["ki"] = _iDynTree.AttitudeMahonyFilterParameters_ki_get
    if _newclass:
        ki = _swig_property(_iDynTree.AttitudeMahonyFilterParameters_ki_get, _iDynTree.AttitudeMahonyFilterParameters_ki_set)
    __swig_setmethods__["use_magnetometer_measurements"] = _iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_set
    __swig_getmethods__["use_magnetometer_measurements"] = _iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_get
    if _newclass:
        use_magnetometer_measurements = _swig_property(_iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_get, _iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_set)
    __swig_setmethods__["confidence_magnetometer_measurements"] = _iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set
    __swig_getmethods__["confidence_magnetometer_measurements"] = _iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get
    if _newclass:
        confidence_magnetometer_measurements = _swig_property(_iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get, _iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set)

    def __init__(self):
        this = _iDynTree.new_AttitudeMahonyFilterParameters()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_AttitudeMahonyFilterParameters
    __del__ = lambda self: None
AttitudeMahonyFilterParameters_swigregister = _iDynTree.AttitudeMahonyFilterParameters_swigregister
AttitudeMahonyFilterParameters_swigregister(AttitudeMahonyFilterParameters)

class AttitudeMahonyFilter(IAttitudeEstimator):
    __swig_setmethods__ = {}
    for _s in [IAttitudeEstimator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttitudeMahonyFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [IAttitudeEstimator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AttitudeMahonyFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_AttitudeMahonyFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def useMagnetoMeterMeasurements(self, flag):
        return _iDynTree.AttitudeMahonyFilter_useMagnetoMeterMeasurements(self, flag)

    def setConfidenceForMagnetometerMeasurements(self, confidence):
        return _iDynTree.AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements(self, confidence)

    def setGainkp(self, kp):
        return _iDynTree.AttitudeMahonyFilter_setGainkp(self, kp)

    def setGainki(self, ki):
        return _iDynTree.AttitudeMahonyFilter_setGainki(self, ki)

    def setTimeStepInSeconds(self, timestepInSeconds):
        return _iDynTree.AttitudeMahonyFilter_setTimeStepInSeconds(self, timestepInSeconds)

    def setGravityDirection(self, gravity_dir):
        return _iDynTree.AttitudeMahonyFilter_setGravityDirection(self, gravity_dir)

    def setParameters(self, params):
        return _iDynTree.AttitudeMahonyFilter_setParameters(self, params)

    def getParameters(self, params):
        return _iDynTree.AttitudeMahonyFilter_getParameters(self, params)

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.AttitudeMahonyFilter_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.AttitudeMahonyFilter_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.AttitudeMahonyFilter_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.AttitudeMahonyFilter_setInternalStateInitialOrientation(self, orientationBuffer)
    __swig_destroy__ = _iDynTree.delete_AttitudeMahonyFilter
    __del__ = lambda self: None
AttitudeMahonyFilter_swigregister = _iDynTree.AttitudeMahonyFilter_swigregister
AttitudeMahonyFilter_swigregister(AttitudeMahonyFilter)

class DiscreteExtendedKalmanFilterHelper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteExtendedKalmanFilterHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteExtendedKalmanFilterHelper, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ekf_f(self, x_k, u_k, xhat_k_plus_one):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekf_f(self, x_k, u_k, xhat_k_plus_one)

    def ekf_h(self, xhat_k_plus_one, zhat_k_plus_one):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekf_h(self, xhat_k_plus_one, zhat_k_plus_one)

    def ekfComputeJacobianF(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF(self, *args)

    def ekfComputeJacobianH(self, x, H):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH(self, x, H)

    def ekfPredict(self):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfPredict(self)

    def ekfUpdate(self):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfUpdate(self)

    def ekfInit(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfInit(self, *args)

    def ekfReset(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfReset(self, *args)

    def ekfSetMeasurementVector(self, y):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector(self, y)

    def ekfSetInputVector(self, u):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInputVector(self, u)

    def ekfSetInitialState(self, x0):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInitialState(self, x0)

    def ekfSetStateCovariance(self, P):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance(self, P)

    def ekfSetSystemNoiseCovariance(self, Q):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance(self, Q)

    def ekfSetMeasurementNoiseCovariance(self, R):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance(self, R)

    def ekfSetStateSize(self, dim_X):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetStateSize(self, dim_X)

    def ekfSetInputSize(self, dim_U):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInputSize(self, dim_U)

    def ekfSetOutputSize(self, dim_Y):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize(self, dim_Y)

    def ekfGetStates(self, x):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfGetStates(self, x)

    def ekfGetStateCovariance(self, P):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance(self, P)
    __swig_destroy__ = _iDynTree.delete_DiscreteExtendedKalmanFilterHelper
    __del__ = lambda self: None
DiscreteExtendedKalmanFilterHelper_swigregister = _iDynTree.DiscreteExtendedKalmanFilterHelper_swigregister
DiscreteExtendedKalmanFilterHelper_swigregister(DiscreteExtendedKalmanFilterHelper)

class AttitudeQuaternionEKFParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttitudeQuaternionEKFParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttitudeQuaternionEKFParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["time_step_in_seconds"] = _iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_set
    __swig_getmethods__["time_step_in_seconds"] = _iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_get
    if _newclass:
        time_step_in_seconds = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_get, _iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_set)
    __swig_setmethods__["bias_correlation_time_factor"] = _iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set
    __swig_getmethods__["bias_correlation_time_factor"] = _iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get
    if _newclass:
        bias_correlation_time_factor = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get, _iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set)
    __swig_setmethods__["accelerometer_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set
    __swig_getmethods__["accelerometer_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get
    if _newclass:
        accelerometer_noise_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set)
    __swig_setmethods__["magnetometer_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set
    __swig_getmethods__["magnetometer_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get
    if _newclass:
        magnetometer_noise_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set)
    __swig_setmethods__["gyroscope_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set
    __swig_getmethods__["gyroscope_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get
    if _newclass:
        gyroscope_noise_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set)
    __swig_setmethods__["gyro_bias_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set
    __swig_getmethods__["gyro_bias_noise_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get
    if _newclass:
        gyro_bias_noise_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set)
    __swig_setmethods__["initial_orientation_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set
    __swig_getmethods__["initial_orientation_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get
    if _newclass:
        initial_orientation_error_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set)
    __swig_setmethods__["initial_ang_vel_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set
    __swig_getmethods__["initial_ang_vel_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get
    if _newclass:
        initial_ang_vel_error_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set)
    __swig_setmethods__["initial_gyro_bias_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set
    __swig_getmethods__["initial_gyro_bias_error_variance"] = _iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get
    if _newclass:
        initial_gyro_bias_error_variance = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set)
    __swig_setmethods__["use_magnetometer_measurements"] = _iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set
    __swig_getmethods__["use_magnetometer_measurements"] = _iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get
    if _newclass:
        use_magnetometer_measurements = _swig_property(_iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get, _iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set)

    def __init__(self):
        this = _iDynTree.new_AttitudeQuaternionEKFParameters()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_AttitudeQuaternionEKFParameters
    __del__ = lambda self: None
AttitudeQuaternionEKFParameters_swigregister = _iDynTree.AttitudeQuaternionEKFParameters_swigregister
AttitudeQuaternionEKFParameters_swigregister(AttitudeQuaternionEKFParameters)
output_dimensions_with_magnetometer = cvar.output_dimensions_with_magnetometer
output_dimensions_without_magnetometer = cvar.output_dimensions_without_magnetometer
input_dimensions = cvar.input_dimensions

class AttitudeQuaternionEKF(IAttitudeEstimator, DiscreteExtendedKalmanFilterHelper):
    __swig_setmethods__ = {}
    for _s in [IAttitudeEstimator, DiscreteExtendedKalmanFilterHelper]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttitudeQuaternionEKF, name, value)
    __swig_getmethods__ = {}
    for _s in [IAttitudeEstimator, DiscreteExtendedKalmanFilterHelper]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AttitudeQuaternionEKF, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_AttitudeQuaternionEKF()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getParameters(self, params):
        return _iDynTree.AttitudeQuaternionEKF_getParameters(self, params)

    def setParameters(self, params):
        return _iDynTree.AttitudeQuaternionEKF_setParameters(self, params)

    def setGravityDirection(self, gravity_dir):
        return _iDynTree.AttitudeQuaternionEKF_setGravityDirection(self, gravity_dir)

    def setTimeStepInSeconds(self, time_step_in_seconds):
        return _iDynTree.AttitudeQuaternionEKF_setTimeStepInSeconds(self, time_step_in_seconds)

    def setBiasCorrelationTimeFactor(self, bias_correlation_time_factor):
        return _iDynTree.AttitudeQuaternionEKF_setBiasCorrelationTimeFactor(self, bias_correlation_time_factor)

    def useMagnetometerMeasurements(self, use_magnetometer_measurements):
        return _iDynTree.AttitudeQuaternionEKF_useMagnetometerMeasurements(self, use_magnetometer_measurements)

    def setMeasurementNoiseVariance(self, acc, mag):
        return _iDynTree.AttitudeQuaternionEKF_setMeasurementNoiseVariance(self, acc, mag)

    def setSystemNoiseVariance(self, gyro, gyro_bias):
        return _iDynTree.AttitudeQuaternionEKF_setSystemNoiseVariance(self, gyro, gyro_bias)

    def setInitialStateCovariance(self, orientation_var, ang_vel_var, gyro_bias_var):
        return _iDynTree.AttitudeQuaternionEKF_setInitialStateCovariance(self, orientation_var, ang_vel_var, gyro_bias_var)

    def initializeFilter(self):
        return _iDynTree.AttitudeQuaternionEKF_initializeFilter(self)

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.AttitudeQuaternionEKF_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.AttitudeQuaternionEKF_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.AttitudeQuaternionEKF_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.AttitudeQuaternionEKF_setInternalStateInitialOrientation(self, orientationBuffer)
    __swig_destroy__ = _iDynTree.delete_AttitudeQuaternionEKF
    __del__ = lambda self: None
AttitudeQuaternionEKF_swigregister = _iDynTree.AttitudeQuaternionEKF_swigregister
AttitudeQuaternionEKF_swigregister(AttitudeQuaternionEKF)


def estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(totalMass, model, estimatedInertialParams):
    return _iDynTree.estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(totalMass, model, estimatedInertialParams)
estimateInertialParametersFromLinkBoundingBoxesAndTotalMass = _iDynTree.estimateInertialParametersFromLinkBoundingBoxesAndTotalMass
class KinDynComputations(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KinDynComputations, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KinDynComputations, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_KinDynComputations()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_KinDynComputations
    __del__ = lambda self: None

    def loadRobotModel(self, model):
        return _iDynTree.KinDynComputations_loadRobotModel(self, model)

    def isValid(self):
        return _iDynTree.KinDynComputations_isValid(self)

    def setFrameVelocityRepresentation(self, frameVelRepr):
        return _iDynTree.KinDynComputations_setFrameVelocityRepresentation(self, frameVelRepr)

    def getFrameVelocityRepresentation(self):
        return _iDynTree.KinDynComputations_getFrameVelocityRepresentation(self)

    def getNrOfDegreesOfFreedom(self):
        return _iDynTree.KinDynComputations_getNrOfDegreesOfFreedom(self)

    def getDescriptionOfDegreeOfFreedom(self, dof_index):
        return _iDynTree.KinDynComputations_getDescriptionOfDegreeOfFreedom(self, dof_index)

    def getDescriptionOfDegreesOfFreedom(self):
        return _iDynTree.KinDynComputations_getDescriptionOfDegreesOfFreedom(self)

    def getNrOfLinks(self):
        return _iDynTree.KinDynComputations_getNrOfLinks(self)

    def getNrOfFrames(self):
        return _iDynTree.KinDynComputations_getNrOfFrames(self)

    def getFloatingBase(self):
        return _iDynTree.KinDynComputations_getFloatingBase(self)

    def setFloatingBase(self, floatingBaseName):
        return _iDynTree.KinDynComputations_setFloatingBase(self, floatingBaseName)

    def model(self):
        return _iDynTree.KinDynComputations_model(self)

    def getRobotModel(self):
        return _iDynTree.KinDynComputations_getRobotModel(self)

    def getRelativeJacobianSparsityPattern(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobianSparsityPattern(self, *args)

    def getFrameFreeFloatingJacobianSparsityPattern(self, *args):
        return _iDynTree.KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern(self, *args)

    def setJointPos(self, *args):
        return _iDynTree.KinDynComputations_setJointPos(self, *args)

    def setRobotState(self, *args):
        return _iDynTree.KinDynComputations_setRobotState(self, *args)

    def getRobotState(self, *args):
        return _iDynTree.KinDynComputations_getRobotState(self, *args)

    def getWorldBaseTransform(self, *args):
        return _iDynTree.KinDynComputations_getWorldBaseTransform(self, *args)

    def getBaseTwist(self, *args):
        return _iDynTree.KinDynComputations_getBaseTwist(self, *args)

    def getJointPos(self, *args):
        return _iDynTree.KinDynComputations_getJointPos(self, *args)

    def getJointVel(self, *args):
        return _iDynTree.KinDynComputations_getJointVel(self, *args)

    def getModelVel(self, *args):
        return _iDynTree.KinDynComputations_getModelVel(self, *args)

    def getFrameIndex(self, frameName):
        return _iDynTree.KinDynComputations_getFrameIndex(self, frameName)

    def getFrameName(self, frameIndex):
        return _iDynTree.KinDynComputations_getFrameName(self, frameIndex)

    def getWorldTransform(self, *args):
        return _iDynTree.KinDynComputations_getWorldTransform(self, *args)

    def getWorldTransformsAsHomogeneous(self, frameNames):
        return _iDynTree.KinDynComputations_getWorldTransformsAsHomogeneous(self, frameNames)

    def getRelativeTransformExplicit(self, *args):
        return _iDynTree.KinDynComputations_getRelativeTransformExplicit(self, *args)

    def getRelativeTransform(self, *args):
        return _iDynTree.KinDynComputations_getRelativeTransform(self, *args)

    def getFrameVel(self, *args):
        return _iDynTree.KinDynComputations_getFrameVel(self, *args)

    def getFrameAcc(self, *args):
        return _iDynTree.KinDynComputations_getFrameAcc(self, *args)

    def getFrameFreeFloatingJacobian(self, *args):
        return _iDynTree.KinDynComputations_getFrameFreeFloatingJacobian(self, *args)

    def getRelativeJacobian(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobian(self, *args)

    def getRelativeJacobianExplicit(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobianExplicit(self, *args)

    def getFrameBiasAcc(self, *args):
        return _iDynTree.KinDynComputations_getFrameBiasAcc(self, *args)

    def getCenterOfMassPosition(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassPosition(self, *args)

    def getCenterOfMassVelocity(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassVelocity(self, *args)

    def getCenterOfMassJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassJacobian(self, *args)

    def getCenterOfMassBiasAcc(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassBiasAcc(self, *args)

    def getAverageVelocity(self, *args):
        return _iDynTree.KinDynComputations_getAverageVelocity(self, *args)

    def getAverageVelocityJacobian(self, *args):
        return _iDynTree.KinDynComputations_getAverageVelocityJacobian(self, *args)

    def getCentroidalAverageVelocity(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalAverageVelocity(self, *args)

    def getCentroidalAverageVelocityJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalAverageVelocityJacobian(self, *args)

    def getLinearAngularMomentum(self, *args):
        return _iDynTree.KinDynComputations_getLinearAngularMomentum(self, *args)

    def getLinearAngularMomentumJacobian(self, *args):
        return _iDynTree.KinDynComputations_getLinearAngularMomentumJacobian(self, *args)

    def getCentroidalTotalMomentum(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalTotalMomentum(self, *args)

    def getCentroidalTotalMomentumJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalTotalMomentumJacobian(self, *args)

    def getFreeFloatingMassMatrix(self, *args):
        return _iDynTree.KinDynComputations_getFreeFloatingMassMatrix(self, *args)

    def inverseDynamics(self, *args):
        return _iDynTree.KinDynComputations_inverseDynamics(self, *args)

    def generalizedBiasForces(self, *args):
        return _iDynTree.KinDynComputations_generalizedBiasForces(self, *args)

    def generalizedGravityForces(self, *args):
        return _iDynTree.KinDynComputations_generalizedGravityForces(self, *args)

    def generalizedExternalForces(self, linkExtForces, generalizedExternalForces):
        return _iDynTree.KinDynComputations_generalizedExternalForces(self, linkExtForces, generalizedExternalForces)

    def inverseDynamicsInertialParametersRegressor(self, baseAcc, s_ddot, baseForceAndJointTorquesRegressor):
        return _iDynTree.KinDynComputations_inverseDynamicsInertialParametersRegressor(self, baseAcc, s_ddot, baseForceAndJointTorquesRegressor)
KinDynComputations_swigregister = _iDynTree.KinDynComputations_swigregister
KinDynComputations_swigregister(KinDynComputations)

class Matrix4x4Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix4x4Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix4x4Vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.Matrix4x4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.Matrix4x4Vector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.Matrix4x4Vector___bool__(self)

    def __len__(self):
        return _iDynTree.Matrix4x4Vector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.Matrix4x4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.Matrix4x4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.Matrix4x4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.Matrix4x4Vector_pop(self)

    def append(self, x):
        return _iDynTree.Matrix4x4Vector_append(self, x)

    def empty(self):
        return _iDynTree.Matrix4x4Vector_empty(self)

    def size(self):
        return _iDynTree.Matrix4x4Vector_size(self)

    def swap(self, v):
        return _iDynTree.Matrix4x4Vector_swap(self, v)

    def begin(self):
        return _iDynTree.Matrix4x4Vector_begin(self)

    def end(self):
        return _iDynTree.Matrix4x4Vector_end(self)

    def rbegin(self):
        return _iDynTree.Matrix4x4Vector_rbegin(self)

    def rend(self):
        return _iDynTree.Matrix4x4Vector_rend(self)

    def clear(self):
        return _iDynTree.Matrix4x4Vector_clear(self)

    def get_allocator(self):
        return _iDynTree.Matrix4x4Vector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.Matrix4x4Vector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.Matrix4x4Vector_erase(self, *args)

    def __init__(self, *args):
        this = _iDynTree.new_Matrix4x4Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _iDynTree.Matrix4x4Vector_push_back(self, x)

    def front(self):
        return _iDynTree.Matrix4x4Vector_front(self)

    def back(self):
        return _iDynTree.Matrix4x4Vector_back(self)

    def assign(self, n, x):
        return _iDynTree.Matrix4x4Vector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.Matrix4x4Vector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.Matrix4x4Vector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.Matrix4x4Vector_reserve(self, n)

    def capacity(self):
        return _iDynTree.Matrix4x4Vector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_Matrix4x4Vector
    __del__ = lambda self: None
Matrix4x4Vector_swigregister = _iDynTree.Matrix4x4Vector_swigregister
Matrix4x4Vector_swigregister(Matrix4x4Vector)

class ICamera(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICamera, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICamera, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ICamera
    __del__ = lambda self: None

    def setPosition(self, cameraPos):
        return _iDynTree.ICamera_setPosition(self, cameraPos)

    def setTarget(self, cameraPos):
        return _iDynTree.ICamera_setTarget(self, cameraPos)

    def setUpVector(self, upVector):
        return _iDynTree.ICamera_setUpVector(self, upVector)
ICamera_swigregister = _iDynTree.ICamera_swigregister
ICamera_swigregister(ICamera)

class ColorViz(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ColorViz, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ColorViz, name)
    __repr__ = _swig_repr
    __swig_setmethods__["r"] = _iDynTree.ColorViz_r_set
    __swig_getmethods__["r"] = _iDynTree.ColorViz_r_get
    if _newclass:
        r = _swig_property(_iDynTree.ColorViz_r_get, _iDynTree.ColorViz_r_set)
    __swig_setmethods__["g"] = _iDynTree.ColorViz_g_set
    __swig_getmethods__["g"] = _iDynTree.ColorViz_g_get
    if _newclass:
        g = _swig_property(_iDynTree.ColorViz_g_get, _iDynTree.ColorViz_g_set)
    __swig_setmethods__["b"] = _iDynTree.ColorViz_b_set
    __swig_getmethods__["b"] = _iDynTree.ColorViz_b_get
    if _newclass:
        b = _swig_property(_iDynTree.ColorViz_b_get, _iDynTree.ColorViz_b_set)
    __swig_setmethods__["a"] = _iDynTree.ColorViz_a_set
    __swig_getmethods__["a"] = _iDynTree.ColorViz_a_get
    if _newclass:
        a = _swig_property(_iDynTree.ColorViz_a_get, _iDynTree.ColorViz_a_set)

    def __init__(self, *args):
        this = _iDynTree.new_ColorViz(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ColorViz
    __del__ = lambda self: None
ColorViz_swigregister = _iDynTree.ColorViz_swigregister
ColorViz_swigregister(ColorViz)

POINT_LIGHT = _iDynTree.POINT_LIGHT
DIRECTIONAL_LIGHT = _iDynTree.DIRECTIONAL_LIGHT
class ILight(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ILight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ILight, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ILight
    __del__ = lambda self: None

    def getName(self):
        return _iDynTree.ILight_getName(self)

    def setType(self, type):
        return _iDynTree.ILight_setType(self, type)

    def getType(self):
        return _iDynTree.ILight_getType(self)

    def setPosition(self, cameraPos):
        return _iDynTree.ILight_setPosition(self, cameraPos)

    def getPosition(self):
        return _iDynTree.ILight_getPosition(self)

    def setDirection(self, lightDirection):
        return _iDynTree.ILight_setDirection(self, lightDirection)

    def getDirection(self):
        return _iDynTree.ILight_getDirection(self)

    def setAmbientColor(self, ambientColor):
        return _iDynTree.ILight_setAmbientColor(self, ambientColor)

    def getAmbientColor(self):
        return _iDynTree.ILight_getAmbientColor(self)

    def setSpecularColor(self, ambientColor):
        return _iDynTree.ILight_setSpecularColor(self, ambientColor)

    def getSpecularColor(self):
        return _iDynTree.ILight_getSpecularColor(self)

    def setDiffuseColor(self, ambientColor):
        return _iDynTree.ILight_setDiffuseColor(self, ambientColor)

    def getDiffuseColor(self):
        return _iDynTree.ILight_getDiffuseColor(self)
ILight_swigregister = _iDynTree.ILight_swigregister
ILight_swigregister(ILight)

class IEnvironment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEnvironment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEnvironment, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IEnvironment
    __del__ = lambda self: None

    def getElements(self):
        return _iDynTree.IEnvironment_getElements(self)

    def setElementVisibility(self, elementKey, isVisible):
        return _iDynTree.IEnvironment_setElementVisibility(self, elementKey, isVisible)

    def setBackgroundColor(self, backgroundColor):
        return _iDynTree.IEnvironment_setBackgroundColor(self, backgroundColor)

    def setAmbientLight(self, ambientLight):
        return _iDynTree.IEnvironment_setAmbientLight(self, ambientLight)

    def getLights(self):
        return _iDynTree.IEnvironment_getLights(self)

    def addLight(self, lightName):
        return _iDynTree.IEnvironment_addLight(self, lightName)

    def lightViz(self, lightName):
        return _iDynTree.IEnvironment_lightViz(self, lightName)

    def removeLight(self, lightName):
        return _iDynTree.IEnvironment_removeLight(self, lightName)
IEnvironment_swigregister = _iDynTree.IEnvironment_swigregister
IEnvironment_swigregister(IEnvironment)

class IJetsVisualization(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IJetsVisualization, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IJetsVisualization, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IJetsVisualization
    __del__ = lambda self: None

    def setJetsFrames(self, jetsFrames):
        return _iDynTree.IJetsVisualization_setJetsFrames(self, jetsFrames)

    def getNrOfJets(self):
        return _iDynTree.IJetsVisualization_getNrOfJets(self)

    def getJetDirection(self, jetIndex):
        return _iDynTree.IJetsVisualization_getJetDirection(self, jetIndex)

    def setJetDirection(self, jetIndex, jetDirection):
        return _iDynTree.IJetsVisualization_setJetDirection(self, jetIndex, jetDirection)

    def setJetColor(self, jetIndex, jetColor):
        return _iDynTree.IJetsVisualization_setJetColor(self, jetIndex, jetColor)

    def setJetsDimensions(self, minRadius, maxRadius, maxLenght):
        return _iDynTree.IJetsVisualization_setJetsDimensions(self, minRadius, maxRadius, maxLenght)

    def setJetsIntensity(self, jetsIntensity):
        return _iDynTree.IJetsVisualization_setJetsIntensity(self, jetsIntensity)
IJetsVisualization_swigregister = _iDynTree.IJetsVisualization_swigregister
IJetsVisualization_swigregister(IJetsVisualization)

class IVectorsVisualization(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorsVisualization, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorsVisualization, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IVectorsVisualization
    __del__ = lambda self: None

    def addVector(self, *args):
        return _iDynTree.IVectorsVisualization_addVector(self, *args)

    def getNrOfVectors(self):
        return _iDynTree.IVectorsVisualization_getNrOfVectors(self)

    def getVector(self, *args):
        return _iDynTree.IVectorsVisualization_getVector(self, *args)

    def updateVector(self, *args):
        return _iDynTree.IVectorsVisualization_updateVector(self, *args)

    def setVectorColor(self, vectorIndex, vectorColor):
        return _iDynTree.IVectorsVisualization_setVectorColor(self, vectorIndex, vectorColor)

    def setVectorsAspect(self, zeroModulusRadius, modulusMultiplier, heightScale):
        return _iDynTree.IVectorsVisualization_setVectorsAspect(self, zeroModulusRadius, modulusMultiplier, heightScale)
IVectorsVisualization_swigregister = _iDynTree.IVectorsVisualization_swigregister
IVectorsVisualization_swigregister(IVectorsVisualization)

class IModelVisualization(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IModelVisualization, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IModelVisualization, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IModelVisualization
    __del__ = lambda self: None

    def setPositions(self, world_H_base, jointPos):
        return _iDynTree.IModelVisualization_setPositions(self, world_H_base, jointPos)

    def setLinkPositions(self, linkPos):
        return _iDynTree.IModelVisualization_setLinkPositions(self, linkPos)

    def model(self):
        return _iDynTree.IModelVisualization_model(self)

    def getInstanceName(self):
        return _iDynTree.IModelVisualization_getInstanceName(self)

    def setModelVisibility(self, isVisible):
        return _iDynTree.IModelVisualization_setModelVisibility(self, isVisible)

    def setModelColor(self, modelColor):
        return _iDynTree.IModelVisualization_setModelColor(self, modelColor)

    def resetModelColor(self):
        return _iDynTree.IModelVisualization_resetModelColor(self)

    def setLinkColor(self, linkIndex, linkColor):
        return _iDynTree.IModelVisualization_setLinkColor(self, linkIndex, linkColor)

    def resetLinkColor(self, linkIndex):
        return _iDynTree.IModelVisualization_resetLinkColor(self, linkIndex)

    def getLinkNames(self):
        return _iDynTree.IModelVisualization_getLinkNames(self)

    def setLinkVisibility(self, linkName, isVisible):
        return _iDynTree.IModelVisualization_setLinkVisibility(self, linkName, isVisible)

    def getFeatures(self):
        return _iDynTree.IModelVisualization_getFeatures(self)

    def setFeatureVisibility(self, elementKey, isVisible):
        return _iDynTree.IModelVisualization_setFeatureVisibility(self, elementKey, isVisible)

    def jets(self):
        return _iDynTree.IModelVisualization_jets(self)

    def getWorldModelTransform(self):
        return _iDynTree.IModelVisualization_getWorldModelTransform(self)

    def getWorldLinkTransform(self, linkIndex):
        return _iDynTree.IModelVisualization_getWorldLinkTransform(self, linkIndex)
IModelVisualization_swigregister = _iDynTree.IModelVisualization_swigregister
IModelVisualization_swigregister(IModelVisualization)

class VisualizerOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VisualizerOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VisualizerOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["verbose"] = _iDynTree.VisualizerOptions_verbose_set
    __swig_getmethods__["verbose"] = _iDynTree.VisualizerOptions_verbose_get
    if _newclass:
        verbose = _swig_property(_iDynTree.VisualizerOptions_verbose_get, _iDynTree.VisualizerOptions_verbose_set)
    __swig_setmethods__["winWidth"] = _iDynTree.VisualizerOptions_winWidth_set
    __swig_getmethods__["winWidth"] = _iDynTree.VisualizerOptions_winWidth_get
    if _newclass:
        winWidth = _swig_property(_iDynTree.VisualizerOptions_winWidth_get, _iDynTree.VisualizerOptions_winWidth_set)
    __swig_setmethods__["winHeight"] = _iDynTree.VisualizerOptions_winHeight_set
    __swig_getmethods__["winHeight"] = _iDynTree.VisualizerOptions_winHeight_get
    if _newclass:
        winHeight = _swig_property(_iDynTree.VisualizerOptions_winHeight_get, _iDynTree.VisualizerOptions_winHeight_set)
    __swig_setmethods__["rootFrameArrowsDimension"] = _iDynTree.VisualizerOptions_rootFrameArrowsDimension_set
    __swig_getmethods__["rootFrameArrowsDimension"] = _iDynTree.VisualizerOptions_rootFrameArrowsDimension_get
    if _newclass:
        rootFrameArrowsDimension = _swig_property(_iDynTree.VisualizerOptions_rootFrameArrowsDimension_get, _iDynTree.VisualizerOptions_rootFrameArrowsDimension_set)

    def __init__(self):
        this = _iDynTree.new_VisualizerOptions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_VisualizerOptions
    __del__ = lambda self: None
VisualizerOptions_swigregister = _iDynTree.VisualizerOptions_swigregister
VisualizerOptions_swigregister(VisualizerOptions)

class Visualizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Visualizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Visualizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_Visualizer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_Visualizer
    __del__ = lambda self: None

    def init(self, *args):
        return _iDynTree.Visualizer_init(self, *args)

    def getNrOfVisualizedModels(self):
        return _iDynTree.Visualizer_getNrOfVisualizedModels(self)

    def getModelInstanceName(self, modelInstanceIndex):
        return _iDynTree.Visualizer_getModelInstanceName(self, modelInstanceIndex)

    def getModelInstanceIndex(self, instanceName):
        return _iDynTree.Visualizer_getModelInstanceIndex(self, instanceName)

    def addModel(self, model, instanceName):
        return _iDynTree.Visualizer_addModel(self, model, instanceName)

    def modelViz(self, *args):
        return _iDynTree.Visualizer_modelViz(self, *args)

    def camera(self):
        return _iDynTree.Visualizer_camera(self)

    def enviroment(self):
        return _iDynTree.Visualizer_enviroment(self)

    def vectors(self):
        return _iDynTree.Visualizer_vectors(self)

    def run(self):
        return _iDynTree.Visualizer_run(self)

    def draw(self):
        return _iDynTree.Visualizer_draw(self)

    def drawToFile(self, *args):
        return _iDynTree.Visualizer_drawToFile(self, *args)

    def close(self):
        return _iDynTree.Visualizer_close(self)
Visualizer_swigregister = _iDynTree.Visualizer_swigregister
Visualizer_swigregister(Visualizer)

class Polygon(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Polygon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Polygon, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_vertices"] = _iDynTree.Polygon_m_vertices_set
    __swig_getmethods__["m_vertices"] = _iDynTree.Polygon_m_vertices_get
    if _newclass:
        m_vertices = _swig_property(_iDynTree.Polygon_m_vertices_get, _iDynTree.Polygon_m_vertices_set)

    def __init__(self):
        this = _iDynTree.new_Polygon()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setNrOfVertices(self, size):
        return _iDynTree.Polygon_setNrOfVertices(self, size)

    def getNrOfVertices(self):
        return _iDynTree.Polygon_getNrOfVertices(self)

    def isValid(self):
        return _iDynTree.Polygon_isValid(self)

    def applyTransform(self, newFrame_X_oldFrame):
        return _iDynTree.Polygon_applyTransform(self, newFrame_X_oldFrame)

    def __call__(self, *args):
        return _iDynTree.Polygon___call__(self, *args)
    if _newclass:
        XYRectangleFromOffsets = staticmethod(_iDynTree.Polygon_XYRectangleFromOffsets)
    else:
        XYRectangleFromOffsets = _iDynTree.Polygon_XYRectangleFromOffsets
    __swig_destroy__ = _iDynTree.delete_Polygon
    __del__ = lambda self: None
Polygon_swigregister = _iDynTree.Polygon_swigregister
Polygon_swigregister(Polygon)

def Polygon_XYRectangleFromOffsets(front, back, left, right):
    return _iDynTree.Polygon_XYRectangleFromOffsets(front, back, left, right)
Polygon_XYRectangleFromOffsets = _iDynTree.Polygon_XYRectangleFromOffsets

class Polygon2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Polygon2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Polygon2D, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_vertices"] = _iDynTree.Polygon2D_m_vertices_set
    __swig_getmethods__["m_vertices"] = _iDynTree.Polygon2D_m_vertices_get
    if _newclass:
        m_vertices = _swig_property(_iDynTree.Polygon2D_m_vertices_get, _iDynTree.Polygon2D_m_vertices_set)

    def __init__(self):
        this = _iDynTree.new_Polygon2D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setNrOfVertices(self, size):
        return _iDynTree.Polygon2D_setNrOfVertices(self, size)

    def getNrOfVertices(self):
        return _iDynTree.Polygon2D_getNrOfVertices(self)

    def isValid(self):
        return _iDynTree.Polygon2D_isValid(self)

    def __call__(self, *args):
        return _iDynTree.Polygon2D___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_Polygon2D
    __del__ = lambda self: None
Polygon2D_swigregister = _iDynTree.Polygon2D_swigregister
Polygon2D_swigregister(Polygon2D)

class ConvexHullProjectionConstraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConvexHullProjectionConstraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConvexHullProjectionConstraint, name)
    __repr__ = _swig_repr

    def setActive(self, isActive):
        return _iDynTree.ConvexHullProjectionConstraint_setActive(self, isActive)

    def isActive(self):
        return _iDynTree.ConvexHullProjectionConstraint_isActive(self)

    def getNrOfConstraints(self):
        return _iDynTree.ConvexHullProjectionConstraint_getNrOfConstraints(self)
    __swig_setmethods__["projectedConvexHull"] = _iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_set
    __swig_getmethods__["projectedConvexHull"] = _iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_get
    if _newclass:
        projectedConvexHull = _swig_property(_iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_get, _iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_set)
    __swig_setmethods__["A"] = _iDynTree.ConvexHullProjectionConstraint_A_set
    __swig_getmethods__["A"] = _iDynTree.ConvexHullProjectionConstraint_A_get
    if _newclass:
        A = _swig_property(_iDynTree.ConvexHullProjectionConstraint_A_get, _iDynTree.ConvexHullProjectionConstraint_A_set)
    __swig_setmethods__["b"] = _iDynTree.ConvexHullProjectionConstraint_b_set
    __swig_getmethods__["b"] = _iDynTree.ConvexHullProjectionConstraint_b_get
    if _newclass:
        b = _swig_property(_iDynTree.ConvexHullProjectionConstraint_b_get, _iDynTree.ConvexHullProjectionConstraint_b_set)
    __swig_setmethods__["P"] = _iDynTree.ConvexHullProjectionConstraint_P_set
    __swig_getmethods__["P"] = _iDynTree.ConvexHullProjectionConstraint_P_get
    if _newclass:
        P = _swig_property(_iDynTree.ConvexHullProjectionConstraint_P_get, _iDynTree.ConvexHullProjectionConstraint_P_set)
    __swig_setmethods__["Pdirection"] = _iDynTree.ConvexHullProjectionConstraint_Pdirection_set
    __swig_getmethods__["Pdirection"] = _iDynTree.ConvexHullProjectionConstraint_Pdirection_get
    if _newclass:
        Pdirection = _swig_property(_iDynTree.ConvexHullProjectionConstraint_Pdirection_get, _iDynTree.ConvexHullProjectionConstraint_Pdirection_set)
    __swig_setmethods__["AtimesP"] = _iDynTree.ConvexHullProjectionConstraint_AtimesP_set
    __swig_getmethods__["AtimesP"] = _iDynTree.ConvexHullProjectionConstraint_AtimesP_get
    if _newclass:
        AtimesP = _swig_property(_iDynTree.ConvexHullProjectionConstraint_AtimesP_get, _iDynTree.ConvexHullProjectionConstraint_AtimesP_set)
    __swig_setmethods__["o"] = _iDynTree.ConvexHullProjectionConstraint_o_set
    __swig_getmethods__["o"] = _iDynTree.ConvexHullProjectionConstraint_o_get
    if _newclass:
        o = _swig_property(_iDynTree.ConvexHullProjectionConstraint_o_get, _iDynTree.ConvexHullProjectionConstraint_o_set)

    def buildConvexHull(self, xAxisOfPlaneInWorld, yAxisOfPlaneInWorld, originOfPlaneInWorld, supportPolygonsExpressedInSupportFrame, absoluteFrame_X_supportFrame):
        return _iDynTree.ConvexHullProjectionConstraint_buildConvexHull(self, xAxisOfPlaneInWorld, yAxisOfPlaneInWorld, originOfPlaneInWorld, supportPolygonsExpressedInSupportFrame, absoluteFrame_X_supportFrame)
    __swig_setmethods__["supportFrameIndices"] = _iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_set
    __swig_getmethods__["supportFrameIndices"] = _iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_get
    if _newclass:
        supportFrameIndices = _swig_property(_iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_get, _iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_set)
    __swig_setmethods__["absoluteFrame_X_supportFrame"] = _iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set
    __swig_getmethods__["absoluteFrame_X_supportFrame"] = _iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get
    if _newclass:
        absoluteFrame_X_supportFrame = _swig_property(_iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get, _iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set)

    def project(self, posIn3dInAbsoluteFrame):
        return _iDynTree.ConvexHullProjectionConstraint_project(self, posIn3dInAbsoluteFrame)

    def computeMargin(self, posIn2D):
        return _iDynTree.ConvexHullProjectionConstraint_computeMargin(self, posIn2D)

    def setProjectionAlongDirection(self, direction):
        return _iDynTree.ConvexHullProjectionConstraint_setProjectionAlongDirection(self, direction)

    def projectAlongDirection(self, posIn3dInAbsoluteFrame):
        return _iDynTree.ConvexHullProjectionConstraint_projectAlongDirection(self, posIn3dInAbsoluteFrame)

    def __init__(self):
        this = _iDynTree.new_ConvexHullProjectionConstraint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_ConvexHullProjectionConstraint
    __del__ = lambda self: None
ConvexHullProjectionConstraint_swigregister = _iDynTree.ConvexHullProjectionConstraint_swigregister
ConvexHullProjectionConstraint_swigregister(ConvexHullProjectionConstraint)

InverseKinematicsRotationParametrizationQuaternion = _iDynTree.InverseKinematicsRotationParametrizationQuaternion
InverseKinematicsRotationParametrizationRollPitchYaw = _iDynTree.InverseKinematicsRotationParametrizationRollPitchYaw

def sizeOfRotationParametrization(rotationParametrization):
    return _iDynTree.sizeOfRotationParametrization(rotationParametrization)
sizeOfRotationParametrization = _iDynTree.sizeOfRotationParametrization
InverseKinematicsTreatTargetAsConstraintNone = _iDynTree.InverseKinematicsTreatTargetAsConstraintNone
InverseKinematicsTreatTargetAsConstraintPositionOnly = _iDynTree.InverseKinematicsTreatTargetAsConstraintPositionOnly
InverseKinematicsTreatTargetAsConstraintRotationOnly = _iDynTree.InverseKinematicsTreatTargetAsConstraintRotationOnly
InverseKinematicsTreatTargetAsConstraintFull = _iDynTree.InverseKinematicsTreatTargetAsConstraintFull
class InverseKinematics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InverseKinematics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InverseKinematics, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _iDynTree.new_InverseKinematics()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _iDynTree.delete_InverseKinematics
    __del__ = lambda self: None

    def loadModelFromFile(self, *args):
        return _iDynTree.InverseKinematics_loadModelFromFile(self, *args)

    def setModel(self, *args):
        return _iDynTree.InverseKinematics_setModel(self, *args)

    def setJointLimits(self, jointLimits):
        return _iDynTree.InverseKinematics_setJointLimits(self, jointLimits)

    def getJointLimits(self, jointLimits):
        return _iDynTree.InverseKinematics_getJointLimits(self, jointLimits)

    def clearProblem(self):
        return _iDynTree.InverseKinematics_clearProblem(self)

    def setFloatingBaseOnFrameNamed(self, floatingBaseFrameName):
        return _iDynTree.InverseKinematics_setFloatingBaseOnFrameNamed(self, floatingBaseFrameName)

    def setCurrentRobotConfiguration(self, baseConfiguration, jointConfiguration):
        return _iDynTree.InverseKinematics_setCurrentRobotConfiguration(self, baseConfiguration, jointConfiguration)

    def setJointConfiguration(self, jointName, jointConfiguration):
        return _iDynTree.InverseKinematics_setJointConfiguration(self, jointName, jointConfiguration)

    def setRotationParametrization(self, parametrization):
        return _iDynTree.InverseKinematics_setRotationParametrization(self, parametrization)

    def rotationParametrization(self):
        return _iDynTree.InverseKinematics_rotationParametrization(self)

    def setMaxIterations(self, max_iter):
        return _iDynTree.InverseKinematics_setMaxIterations(self, max_iter)

    def maxIterations(self):
        return _iDynTree.InverseKinematics_maxIterations(self)

    def setMaxCPUTime(self, max_cpu_time):
        return _iDynTree.InverseKinematics_setMaxCPUTime(self, max_cpu_time)

    def maxCPUTime(self):
        return _iDynTree.InverseKinematics_maxCPUTime(self)

    def setCostTolerance(self, tol):
        return _iDynTree.InverseKinematics_setCostTolerance(self, tol)

    def costTolerance(self):
        return _iDynTree.InverseKinematics_costTolerance(self)

    def setConstraintsTolerance(self, constr_tol):
        return _iDynTree.InverseKinematics_setConstraintsTolerance(self, constr_tol)

    def constraintsTolerance(self):
        return _iDynTree.InverseKinematics_constraintsTolerance(self)

    def setVerbosity(self, verbose):
        return _iDynTree.InverseKinematics_setVerbosity(self, verbose)

    def linearSolverName(self):
        return _iDynTree.InverseKinematics_linearSolverName(self)

    def setLinearSolverName(self, solverName):
        return _iDynTree.InverseKinematics_setLinearSolverName(self, solverName)

    def addFrameConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFrameConstraint(self, *args)

    def addFramePositionConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFramePositionConstraint(self, *args)

    def addFrameRotationConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFrameRotationConstraint(self, *args)

    def activateFrameConstraint(self, frameName, newConstraintValue):
        return _iDynTree.InverseKinematics_activateFrameConstraint(self, frameName, newConstraintValue)

    def deactivateFrameConstraint(self, frameName):
        return _iDynTree.InverseKinematics_deactivateFrameConstraint(self, frameName)

    def isFrameConstraintActive(self, frameName):
        return _iDynTree.InverseKinematics_isFrameConstraintActive(self, frameName)

    def addCenterOfMassProjectionConstraint(self, *args):
        return _iDynTree.InverseKinematics_addCenterOfMassProjectionConstraint(self, *args)

    def getCenterOfMassProjectionMargin(self):
        return _iDynTree.InverseKinematics_getCenterOfMassProjectionMargin(self)

    def getCenterOfMassProjectConstraintConvexHull(self, convexHull):
        return _iDynTree.InverseKinematics_getCenterOfMassProjectConstraintConvexHull(self, convexHull)

    def addTarget(self, frameName, targetValue, positionWeight=1.0, rotationWeight=1.0):
        return _iDynTree.InverseKinematics_addTarget(self, frameName, targetValue, positionWeight, rotationWeight)

    def addPositionTarget(self, *args):
        return _iDynTree.InverseKinematics_addPositionTarget(self, *args)

    def addRotationTarget(self, *args):
        return _iDynTree.InverseKinematics_addRotationTarget(self, *args)

    def updateTarget(self, frameName, targetValue, positionWeight=-1.0, rotationWeight=-1.0):
        return _iDynTree.InverseKinematics_updateTarget(self, frameName, targetValue, positionWeight, rotationWeight)

    def updatePositionTarget(self, frameName, targetValue, positionWeight=-1.0):
        return _iDynTree.InverseKinematics_updatePositionTarget(self, frameName, targetValue, positionWeight)

    def updateRotationTarget(self, frameName, targetValue, rotationWeight=-1.0):
        return _iDynTree.InverseKinematics_updateRotationTarget(self, frameName, targetValue, rotationWeight)

    def setDefaultTargetResolutionMode(self, mode):
        return _iDynTree.InverseKinematics_setDefaultTargetResolutionMode(self, mode)

    def defaultTargetResolutionMode(self):
        return _iDynTree.InverseKinematics_defaultTargetResolutionMode(self)

    def setTargetResolutionMode(self, targetName, mode):
        return _iDynTree.InverseKinematics_setTargetResolutionMode(self, targetName, mode)

    def targetResolutionMode(self, frameName):
        return _iDynTree.InverseKinematics_targetResolutionMode(self, frameName)

    def setDesiredFullJointsConfiguration(self, *args):
        return _iDynTree.InverseKinematics_setDesiredFullJointsConfiguration(self, *args)

    def setDesiredReducedJointConfiguration(self, *args):
        return _iDynTree.InverseKinematics_setDesiredReducedJointConfiguration(self, *args)

    def setFullJointsInitialCondition(self, baseTransform, initialCondition):
        return _iDynTree.InverseKinematics_setFullJointsInitialCondition(self, baseTransform, initialCondition)

    def setReducedInitialCondition(self, baseTransform, initialCondition):
        return _iDynTree.InverseKinematics_setReducedInitialCondition(self, baseTransform, initialCondition)

    def solve(self):
        return _iDynTree.InverseKinematics_solve(self)

    def getFullJointsSolution(self, baseTransformSolution, shapeSolution):
        return _iDynTree.InverseKinematics_getFullJointsSolution(self, baseTransformSolution, shapeSolution)

    def getReducedSolution(self, baseTransformSolution, shapeSolution):
        return _iDynTree.InverseKinematics_getReducedSolution(self, baseTransformSolution, shapeSolution)

    def getPoseForFrame(self, frameName, transform):
        return _iDynTree.InverseKinematics_getPoseForFrame(self, frameName, transform)

    def fullModel(self):
        return _iDynTree.InverseKinematics_fullModel(self)

    def reducedModel(self):
        return _iDynTree.InverseKinematics_reducedModel(self)

    def setCOMTarget(self, desiredPosition, weight=1.0):
        return _iDynTree.InverseKinematics_setCOMTarget(self, desiredPosition, weight)

    def setCOMAsConstraint(self, asConstraint=True):
        return _iDynTree.InverseKinematics_setCOMAsConstraint(self, asConstraint)

    def setCOMAsConstraintTolerance(self, tolerance=1e-8):
        return _iDynTree.InverseKinematics_setCOMAsConstraintTolerance(self, tolerance)

    def isCOMAConstraint(self):
        return _iDynTree.InverseKinematics_isCOMAConstraint(self)

    def isCOMTargetActive(self):
        return _iDynTree.InverseKinematics_isCOMTargetActive(self)

    def deactivateCOMTarget(self):
        return _iDynTree.InverseKinematics_deactivateCOMTarget(self)

    def setCOMConstraintProjectionDirection(self, direction):
        return _iDynTree.InverseKinematics_setCOMConstraintProjectionDirection(self, direction)
InverseKinematics_swigregister = _iDynTree.InverseKinematics_swigregister
InverseKinematics_swigregister(InverseKinematics)

# This file is compatible with both classic and new-style classes.


